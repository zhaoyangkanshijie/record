# 前端实战案例

- [数组模拟dictionary与二重排序](#数组模拟dictionary与二重排序)
- [前端截图上传服务器实现](#前端截图上传服务器实现)
- [日历的实现](#日历的实现)
- [简单实现双向数据绑定mvvm](#简单实现双向数据绑定mvvm)
- [便捷的函数与方法](#便捷的函数与方法)
- [图片懒加载](#图片懒加载)
- [正则获取URL参数](#正则获取URL参数)
- [js操作cookie](#js操作cookie)
- [文件切片上传](#文件切片上传)
- [长列表优化](#长列表优化)
- [活动倒计时](#活动倒计时)
- [数据埋点与错误监控](#数据埋点与错误监控)
- [npm版本号的区别](npm版本号的区别)
- [摄像头抓拍与RTC音视频会议](#摄像头抓拍与RTC音视频会议)
- [js加解密哈希编码](#js加解密哈希编码)
- [页面复制文字时自动加版权](#页面复制文字时自动加版权)
- [文件内容读取](#文件内容读取)
- [自动化测试](#自动化测试)
- [jenkins自动部署](#jenkins自动部署)
- [隐藏滚动条与伪元素控制](#隐藏滚动条与伪元素控制)
- [浏览器识别](浏览器识别)
- [HTML5特性](HTML5特性)
- [微信扫码登录实现](#微信扫码登录实现)
- [Dom转图片](#Dom转图片)
- [nodejs版本管理](#nodejs版本管理)
- [js监听url变化](#js监听url变化)
- [html5相关](#html5相关)
- [css解决height:auto动画问题](#css解决height:auto动画问题)
- [在线预览文件](#在线预览文件)
- [移动端开发指南](#移动端开发指南)
- [如何找到当前页面出现次数最多的HTML标签](#如何找到当前页面出现次数最多的HTML标签)
- [导入ics日历日程](#导入ics日历日程)

---

### 数组模拟dictionary与二重排序

1. 参考链接：

   [js 字典排序](https://blog.csdn.net/juyuyh/article/details/89948380)
   [JS sort()排序及 JS sort()双重排序](https://blog.csdn.net/qq416761940/article/details/79632018)
   [前 K 个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/submissions/)

2. 详解：

   - 关于 sort

     - sort([function(a,b){return ±num}])

     - 不传 function 则按照字典序升序排序，传 function 则按数字大小排序，负数为升序排序，正数为降序排序

       - 注意：
       
          上面的字典序指按 unicode 编码序，若要按拼音序，需要 str.sort (function(a,b){return a.localeCompare(b)})

          如果需要对象属性按拼音排序，可先用Object.keys，把key排序好，再赋值到新对象

     - sort 按照字典序降序排序方法，通过比较 if(a>b)，返回正数还是负数，控制排序顺序

     - 多重排序也可通过 if 判断，返回正负数控制排序顺序，其中 if 里面的参数可以与原数组 array1 无关，如 array2[a]>array2[b]

   - 样例

     统计词频，按照词频降序排序，词频相同按照字典序升序排序

     ```js
     let words = [
       "plpaboutit",
       "jnoqzdute",
       "sfvkdqf",
       "mjc",
       "nkpllqzjzp",
       "foqqenbey",
       "ssnanizsav",
       "nkpllqzjzp",
       "sfvkdqf",
       "isnjmy",
       "pnqsz",
       "hhqpvvt",
       "fvvdtpnzx",
       "jkqonvenhx",
       "cyxwlef",
       "hhqpvvt",
       "fvvdtpnzx",
       "plpaboutit",
       "sfvkdqf",
       "mjc",
       "fvvdtpnzx",
       "bwumsj",
       "foqqenbey",
       "isnjmy",
       "nkpllqzjzp",
       "hhqpvvt",
       "foqqenbey",
       "fvvdtpnzx",
       "bwumsj",
       "hhqpvvt",
       "fvvdtpnzx",
       "jkqonvenhx",
       "jnoqzdute",
       "foqqenbey",
       "jnoqzdute",
       "foqqenbey",
       "hhqpvvt",
       "ssnanizsav",
       "mjc",
       "foqqenbey",
       "bwumsj",
       "ssnanizsav",
       "fvvdtpnzx",
       "nkpllqzjzp",
       "jkqonvenhx",
       "hhqpvvt",
       "mjc",
       "isnjmy",
       "bwumsj",
       "pnqsz",
       "hhqpvvt",
       "nkpllqzjzp",
       "jnoqzdute",
       "pnqsz",
       "nkpllqzjzp",
       "jnoqzdute",
       "foqqenbey",
       "nkpllqzjzp",
       "hhqpvvt",
       "fvvdtpnzx",
       "plpaboutit",
       "jnoqzdute",
       "sfvkdqf",
       "fvvdtpnzx",
       "jkqonvenhx",
       "jnoqzdute",
       "nkpllqzjzp",
       "jnoqzdute",
       "fvvdtpnzx",
       "jkqonvenhx",
       "hhqpvvt",
       "isnjmy",
       "jkqonvenhx",
       "ssnanizsav",
       "jnoqzdute",
       "jkqonvenhx",
       "fvvdtpnzx",
       "hhqpvvt",
       "bwumsj",
       "nkpllqzjzp",
       "bwumsj",
       "jkqonvenhx",
       "jnoqzdute",
       "pnqsz",
       "foqqenbey",
       "sfvkdqf",
       "sfvkdqf",
     ];
     let dictionary = new Array();
     for (let i = 0; i < words.length; i++) {
       if (!dictionary[words[i]]) {
         dictionary[words[i]] = 1;
       } else {
         dictionary[words[i]]++;
       }
     }
     let result = Object.keys(dictionary).sort((a, b) => {
       if (dictionary[a] == dictionary[b]) {
         if (a > b) {
           return 1;
         } else {
           return -1;
         }
       }
       return dictionary[b] - dictionary[a];
     });
     for (let value of result) {
       console.log(value, dictionary[value]);
     }
     ```


### 前端截图上传服务器实现

1. 参考链接：

   [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

2. 详解：

   - canvas 思路:(html2canvas)

   ```txt
   将dom转换成canvas图片。

   递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

   通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

   遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

   将画好的canvas填充进页面
   ```

   优缺点:复杂度高，稳定性强。

   - svg 思路:(rasterizeHTML.js)

   ```txt
   svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
   通过一系列的hack技巧替我们绕过了许多限制:
   1.将<img/>的url 转为 dataURI
   2.将background-color从style中取出，修改url后重新插入样式表
   3.将link的的样式通过ajax down下来然后注入<style></sytle>
   ```

   优缺点:简单，只能对已经存在的静态资源进行处理，而对 js 动态生成并不能实时处理。

   - 上传

   ```js
   var fd = new FormData();
   fd.append("img", imgBlob);
   $.ajax({
     type: "POST",
     url: "http://tmpfile.coding.io/img",
     dataType: "json",
     data: fd,
     crossDomain: true,
     processData: false,
     contentType: false,
     success: function (data) {
       if (data && data.path) {
         console.log("http://tmpfile.coding.io/tmp" + data.path);
       }
     },
   });
   ```

### 日历的实现

1. 参考链接：

   [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

2. 详解：

   - new Date()

     用法：

     - new Date();
     - new Date(value);
     - new Date(dateString);
     - new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);

     new Date(this.selectedYear,this.selectedMonth,0)会获得当月最后一天的日期

   - set 方法

   凡是 set 方法，传入数超出合理范围，会自动转为毫秒处理，再使用 get 获取信息，因此日月的加减不需要处理进位和退位问题。

   - 6\*7 的日历显示

     - 新开长度为 42 的数组

     - 因为第一行一定会出现本月的数字，于是 getDay 计算本月 1 号时星期几，确定 1 号位于数组的位置

     - 从 1 号开始填充本月进数组

     - 通过日期加减，把数组剩余位置填满

     - 设置 ul 宽度，使 li 每 7 格换一次行

   ```js
   // 根据给定日期算出星期
   getDay(date){
       return new Date(date).getDay();
   }

   // 获取某月的天数
   getMonthNumber(){
       let d = new Date(this.selectedYear,this.selectedMonth,0);
       let num = d.getDate();
       return num;
   }

   // 获取某一天的昨天和明天
   // date 代表指定的日期，格式：2018-09-27
   // day 传-1表始前一天，传1表始后一天
   getNextDate(date,day) {
       var dd = new Date(date);
       dd.setDate(dd.getDate() + day);
       var y = dd.getFullYear();
       var m = dd.getMonth() + 1 < 10 ? "0" + (dd.getMonth() + 1) : dd.getMonth() + 1;
       var d = dd.getDate() < 10 ? "0" + dd.getDate() : dd.getDate();
       return y + "-" + m + "-" + d;
   }

   // 获取日历中某一天的昨天和明天的数字
   getNextDayNumber(date,day){
       var dd = new Date(date);
       dd.setDate(dd.getDate() + day);
       var d = dd.getDate();
       return d;
   }
   ```



### 简单实现双向数据绑定mvvm

1. 参考链接：

   [一年半经验，百度，有赞，阿里前端面试总结](https://zhuanlan.zhihu.com/p/83803079)

2. 详解：

   ```js
   <input id="input" />;
   const data = {};
   const input = document.getElementById("input");
   Object.defineProperty(data, "text", {
     set(value) {
       input.value = value;
       this.value = value;
     },
   });
   input.onchange = function (e) {
     data.text = e.target.value;
   };
   ```


### 便捷的函数与方法

1. 参考链接：

   - [前端常见 20 道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

   - [Javascript 实现嵌套数组扁平化](https://www.cnblogs.com/codejoker/p/10370262.html)

   - [前端面试大厂手写源码系列（上）](https://juejin.im/post/5e77888ff265da57187c7278#heading-16)

   - [十道大厂面试题(含答案)总结](https://mp.weixin.qq.com/s/o553cr1FHLz40PpxbO8oOw)

   - [js 对象的扁平化与反扁平化](https://www.cnblogs.com/mengff/p/7097011.html)

   - [11 个 JavaScript 小技巧](https://mp.weixin.qq.com/s/qBuTTXzt7ZNFttXwu5ryMw)

   - [js 去除数组中的空值,假值](https://blog.csdn.net/zzwwjjdj1/article/details/78642552)

   - [js 用 Set 实现并集（Union）、交集（Intersect）和差集（Difference）](https://blog.csdn.net/mhbsoft/article/details/81487826)

   - [JS 的对象数组去重处理(二十)](https://blog.csdn.net/yjltx1234csdn/article/details/93766707)

   - [JavaScript 工具函数大全（持续更新）](https://github.com/Wscats/CV/issues/27)

   - [【适合收藏】为了多点时间陪女朋友，我向BAT大佬跪求了这15条JS技巧](https://juejin.im/post/5f15444df265da22c9671b03)

   - [js实现trim方法](https://www.cnblogs.com/wayowe/p/7779555.html)

   - [实现一个数组（包含对象等类型元素）去重函数](https://mp.weixin.qq.com/s/UAnAMDMt2dAsYMFXYn5G9Q)

2. 详解

   - 嵌套数组扁平化

     es6 flat(扁平层数)

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]];
     testArr.flat(Infinity);
     ```

     toString

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]]
     [...testArr.toString().split(',')]
     ```

     join/split/map

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]];
     testArr.toString().split(",").map(Number);
     testArr.join().split(",").map(Number);
     ```

     包含非数字类型

     ```js
     const flattern = (arr) => {
       const result = [];
       arr.forEach((item) => {
         if (Array.isArray(item)) {
           result.push(...flattern(item));
         } else {
           result.push(item);
         }
       });
       return result;
     };
     ```

   - 嵌套对象的扁平化和反扁平化

     扁平化输入

     ```js
     var obj = {
       a: {
         b: {
           c: {
             d: 1,
           },
         },
       },
       aa: 2,
       c: [1, 2],
     };
     ```

     输出

     ```js
     { 'a.b.c.d': 1, 'aa': 2, 'c[0]': 1, 'c[1]': 2 }
     ```

     扁平化 1

     ```js
     let str = "";
     let o = {};
     function objFlatten(obj) {
       Object.keys(obj).map((item) => {
         if (Object.prototype.toString.call(obj[item]) === "[object Object]") {
           //如果是对象，记录"item1.item2.",不断递归
           str += item + ".";
           objFlatten(obj[item]);
         } else if (
           Object.prototype.toString.call(obj[item]) === "[object Array]"
         ) {
           //如果是数组，向对象循环添加属性，o.c[0]，o.c[1]
           obj[item].forEach((ele, index) => (o[item + `[${index}]`] = ele));
         } else {
           //如果是基础类型,加入最后的item变为"item1.item2.item3",向o添加str记录的属性并赋值，清空str
           str += item;
           o[str] = obj[item];
           str = "";
         }
       });
     }
     ```

     扁平化 2

     ```js
     Object.flatten = function (obj) {
       var result = {};

       function recurse(src, prop) {
         var toString = Object.prototype.toString;
         if (toString.call(src) == "[object Object]") {
           var isEmpty = true;
           for (var p in src) {
             isEmpty = false;
             recurse(src[p], prop ? prop + "." + p : p);
           }
           if (isEmpty && prop) {
             result[prop] = {};
           }
         } else if (toString.call(src) == "[object Array]") {
           var len = src.length;
           if (len > 0) {
             src.forEach(function (item, index) {
               recurse(item, prop ? prop + ".[" + index + "]" : index);
             });
           } else {
             result[prop] = [];
           }
         } else {
           result[prop] = src;
         }
       }
       recurse(obj, "");

       return result;
     };
     ```

     反扁平化 1

     ```js
     Object.unflatten = function (data) {
       if (Object(data) !== data || Array.isArray(data)) return data;
       var regex = /\.?([^.\[\]]+)|\[(\d+)\]/g,
         resultholder = {};
       for (var p in data) {
         var cur = resultholder,
           prop = "",
           m;
         while ((m = regex.exec(p))) {
           cur = cur[prop] || (cur[prop] = m[2] ? [] : {});
           prop = m[2] || m[1];
         }
         cur[prop] = data[p];
       }
       return resultholder[""] || resultholder;
     };
     ```

     反扁平化 2

     ```js
     Object.unflatten2 = function (data) {
       if (Object(data) !== data || Array.isArray(data)) return data;
       var result = {},
         cur,
         prop,
         idx,
         last,
         temp;
       for (var p in data) {
         (cur = result), (prop = ""), (last = 0);
         do {
           idx = p.indexOf(".", last);
           temp = p.substring(last, idx !== -1 ? idx : undefined);
           cur = cur[prop] || (cur[prop] = !isNaN(parseInt(temp)) ? [] : {});
           prop = temp;
           last = idx + 1;
         } while (idx >= 0);
         cur[prop] = data[p];
       }
       return result[""];
     };
     ```

   - 数组去重

     set

     ```js
     var testArr = [1,2,2,3,4,4]
     [... new Set(testArr)]
     ```

     处理对象

     ```js
     let arr1 = [
       { id: 1, name: "汤小梦" },
       { id: 2, name: "石小明" },
       { id: 3, name: "前端开发" },
       { id: 1, name: "web前端" },
     ];
     const unique = (arr, key) => {
       return [...new Map(arr.map((item) => [item[key], item])).values()];
     };
     console.log(unique(arr1, "id"));
     ```

   - 合并数组

     es5

     ```js
     let arr5 = arr3.concat(arr4);
     ```

     es6

     ```js
     let arr6 = [...arr3, ...arr4];
     ```

   - 是否为数组

     instanceof

     ```js
     console.log(arr instanceof Array);
     ```

     constructor

     ```js
     console.log(arr.constructor === Array);
     ```

     是否数组的方法

     ```js
     console.log(!!arr.push && !!arr.concat);
     ```

     toString

     ```js
     console.log(Object.prototype.toString.call(arr) === "[object Array]");
     ```

     isArray

     ```js
     console.log(Array.isArray(arr));
     ```

   - 交换两个数

     ```js
     a = a + b;
     b = a - b;
     a = a - b;
     //或
     a = a ^ b;
     b = a ^ b;
     a = a ^ b;
     ```

   - 快速浮点数转整数

     ```js
     console.log(23.9 | 0); // Result: 23
     console.log(-23.9 | 0); // Result: -23
     ```

   - 删除最后一个数字

     ```js
     let str = "1553";
     Number(str.substring(0, str.length - 1));

     console.log((1553 / 10) | 0); // Result: 155
     console.log((1553 / 100) | 0); // Result: 15
     console.log((1553 / 1000) | 0); // Result: 1
     ```

   - 去除数组中的空值,假值

     ```js
     var u = [undefined, undefined, 1, "", "false", false, true, null, "null"];
     u.filter((d) => d);
     ```

   - Set 实现并集（Union）、交集（Intersect）和差集（Difference）

     ```js
     let a = new Set([1, 2, 3]);
     let b = new Set([4, 3, 2]);

     // 并集
     let union = new Set([...a, ...b]);
     // Set {1, 2, 3, 4}

     // 交集
     let intersect = new Set([...a].filter((x) => b.has(x))); //ES6
     var intersect = new Set(
       [...a].filter(function (x) {
         return b.has(x);
       })
     );
     // set {2, 3}

     // 差集
     let difference = new Set([...a].filter((x) => !b.has(x)));
     // Set {1}
     ```

   - 对象数组去重

     ```js
     let arr = [
       { a: 1, b: 2 },
       { b: 2, a: 1 },
       { a: 2, b: 2 },
       { a: "1", b: "2" },
     ];
     let sortObjectByKeys = (obj) => {
       let keys = Object.keys(obj).sort();
       let newObj = {};
       keys.forEach((value, index, array) => {
         newObj[value] = obj[value];
       });
       return newObj;
     };
     let uniqueObjectArray = (arr) => {
       let set = new Set();
       arr.forEach((value, index, array) => {
         let newValue = sortObjectByKeys(value);
         set.add(JSON.stringify(newValue));
       });
       let newArr = [...set];
       newArr.forEach((value, index, array) => {
         newArr[index] = JSON.parse(value);
       });
       return newArr;
     };
     console.log(uniqueObjectArray(arr));
     ```

   - 平滑滚动到页面顶部

     ```js
     function scrollToTop() {
       var c = document.documentElement.scrollTop || document.body.scrollTop;

       if (c > 0) {
         window.requestAnimationFrame(scrollToTop);
         window.scrollTo(0, c - c / 8);
       }
     }
     ```

   - 日期格式转换

     ```js
     Date.prototype.format = function (formatStr) {
       var str = formatStr;
       var Week = ["日", "一", "二", "三", "四", "五", "六"];
       str = str.replace(/yyyy|YYYY/, this.getFullYear());
       str = str.replace(
         /yy|YY/,
         this.getYear() % 100 > 9
           ? (this.getYear() % 100).toString()
           : "0" + (this.getYear() % 100)
       );
       str = str.replace(
         /MM/,
         this.getMonth() + 1 > 9
           ? (this.getMonth() + 1).toString()
           : "0" + (this.getMonth() + 1)
       );
       str = str.replace(/M/g, this.getMonth() + 1);
       str = str.replace(/w|W/g, Week[this.getDay()]);
       str = str.replace(
         /dd|DD/,
         this.getDate() > 9 ? this.getDate().toString() : "0" + this.getDate()
       );
       str = str.replace(/d|D/g, this.getDate());
       str = str.replace(
         /hh|HH/,
         this.getHours() > 9
           ? this.getHours().toString()
           : "0" + this.getHours()
       );
       str = str.replace(/h|H/g, this.getHours());
       str = str.replace(
         /mm/,
         this.getMinutes() > 9
           ? this.getMinutes().toString()
           : "0" + this.getMinutes()
       );
       str = str.replace(/m/g, this.getMinutes());
       str = str.replace(
         /ss|SS/,
         this.getSeconds() > 9
           ? this.getSeconds().toString()
           : "0" + this.getSeconds()
       );
       str = str.replace(/s|S/g, this.getSeconds());
       return str;
     };

     // 或
     Date.prototype.format = function (format) {
       var o = {
         "M+": this.getMonth() + 1, //month
         "d+": this.getDate(), //day
         "h+": this.getHours(), //hour
         "m+": this.getMinutes(), //minute
         "s+": this.getSeconds(), //second
         "q+": Math.floor((this.getMonth() + 3) / 3), //quarter
         S: this.getMilliseconds(), //millisecond
       };
       if (/(y+)/.test(format))
         format = format.replace(
           RegExp.$1,
           (this.getFullYear() + "").substr(4 - RegExp.$1.length)
         );
       for (var k in o) {
         if (new RegExp("(" + k + ")").test(format))
           format = format.replace(
             RegExp.$1,
             RegExp.$1.length == 1
               ? o[k]
               : ("00" + o[k]).substr(("" + o[k]).length)
           );
       }
       return format;
     };

     alert(new Date().format("yyyy-MM-dd hh:mm:ss"));
     ```

   - 返回日期数列里与目标数列最近的日期下标

      ```js
      const getNearestDateIndex = (targetDate, dates) => {
          if (!targetDate || !dates) {
              throw new Error('Argument(s) is illegal !')
          }
          if (!dates.length) {
              return -1
          }
          const distances = dates.map(date => Math.abs(date - targetDate))
          return distances.indexOf(Math.min(...distances))
      }

      // e.g.
      const targetDate = new Date(2019, 7, 20)
      const dates = [
        new Date(2018, 0, 1),
        new Date(2019, 0, 1),
        new Date(2020, 0, 1),
      ]
      getNearestDateIndex(targetDate, dates) // 2
      ```

   - 返回日期数列里最小的日期

      ```js
      const getMinDate = dates => {
          if (!dates) {
              throw new Error('Argument(s) is illegal !')
          }
          if (!dates.length) {
              return dates
        }
          return new Date(Math.min.apply(null, dates)).toISOString()
      }

      // e.g.
      const dates = [
        new Date(2018, 3, 10),
        new Date(2019, 3, 10),
        new Date(2020, 3, 10),
      ]
      getMinDate(dates) // 2018-04-09T16:00:00.000Z
      ```

   - 打乱数组

      ```js
      const arrayShuffle = array => {
          if (!Array.isArray(array)) {
              throw new Error('Argument must be an array')
        }
          let end = array.length
          if (!end) {
              return array
          }
          while (end) {
              let start = Math.floor(Math.random() * end--);
              [array[start], array[end]] = [array[end], array[start]]
          }
          return array
      }

      // e.g.
      arrayShuffle([1, 2, 3])
      ```

   - 判断是否支持webp图片格式

      ```js
      const canUseWebp = () => (document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0)

      // e.g.
      canUseWebp() // 新版的chrome里为true，火狐里为false
      ```

   - 连字符与驼峰互转

      ```js
      const toCamelCase = (str = '', separator = '-') => {
          if (typeof str !== 'string') {
              throw new Error('Argument must be a string')
          }
          if (str === '') {
              return str
          }
          const newExp = new RegExp('\\-\(\\w\)', 'g')
          return str.replace(newExp, (matched, $1) => {
              return $1.toUpperCase()
          })
      }

      // e.g.
      toCamelCase('hello-world') // helloWorld

      const fromCamelCase = (str = '', separator = '-') => {
          if (typeof str !== 'string') {
              throw new Error('Argument must be a string')
          }
          if (str === '') {
              return str
          }
          return str.replace(/([A-Z])/g, `${separator}$1`).toLowerCase()
      }

      // e.g.
      fromCamelCase('helloWorld') // hello-world
      ```

   - 等级判断

      ```js
      const getLevel = (value = 0, ratio = 50, levels = '一二三四五') => {
          if (typeof value !== 'number') {
              throw new Error('Argument must be a number')
          }
          const levelHash = '一二三四五'.split('')
        const max = levelHash[levelHash.length - 1]
        return levelHash[Math.floor(value / ratio)] || max
      }

      // e.g.
      getLevel(0) // 一
      getLevel(40) // 一
      getLevel(77) // 二
      ```

   - 判断dom是否相等

      ```js
      const isEqualNode = (dom1, dom2) => dom1.isEqualNode(dom2)
      ```

   - 文件尺寸格式化

      ```js
      const formatSize = size => {
          if (typeof +size !== 'number') {
              throw new Error('Argument(s) is illegal !')
        }
          const unitsHash = 'B,KB,MB,GB'.split(',')
          let index = 0
          while (size > 1024 && index < unitsHash.length) {
              size /= 1024
              index++
          }
          return Math.round(size * 100) / 100 + unitsHash[index]
      }
      formatSize('10240') // 10KB
      formatSize('10240000') // 9.77MB
      ```

   - trim与其它去空格方法

      ```js
      String.prototype.trim = function(){
          return this.replace(/^(\s*)|(\s*)$/g, '');
      }
      '  a aaa bbb  b  c cc  ccc   '.replace(/(\S)\s+(\b)/g,'$1$2'); // "  aaaabbbbcccccc   "
      ```

   - 复杂类型数组去重

      1. 如传入的数组元素为 [123, "meili", "123", "mogu", 123] ，则输出： [123, "meili", "123", "mogu"]
      2. 如传入的数组元素为 [123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"] ，则输出： [123, [1, 2, 3], [1, "2", 3], "meili"]
      3. 如传入的数组元素为 [123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"] ，则输出： [123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]
      4. 如传入的数组元素为 [{a:1, b:2}, {b:2, a:1}] ，则输出： [{a: 1, b: 2}]

      * 解决思路：

      一个数组（包含对象等类型元素）去重函数，需要在基础类型判断相等条件下满足以下条件：

      如果元素是数组类型，则需要数组中的每一项相等
      如果元素是对象类型，则需要对象中的每个键值对相等
      去重本身就是遍历数组，然后比较数组中的每一项是否相等而已，所以关键步骤有两步：比较、去重

      * 比较：

      首先判断类型是否一致，类型不一致则返回认为两个数组元素是不同的，否则继续
      如果是数组类型，则递归比较数组中的每个元素是否相等
      如果是对象类型，则递归比较对象中的每个键值对是否相等
      否则，直接 === 比较
      
      * 去重：

      采用 reduce 去重，初始 accumulator 为 []
      采用 findIndex 找到 accumulator 是否包含相同元素，如果不包含则加入，否则不加入
      返回最终的 accumulator ，则为去重后的数组

      ```js
      // 获取类型
      const getType = (function() {
          const class2type = { '[object Boolean]': 'boolean', '[object Number]': 'number', '[object String]': 'string', '[object Function]': 'function', '[object Array]': 'array', '[object Date]': 'date', '[object RegExp]': 'regexp', '[object Object]': 'object', '[object Error]': 'error', '[object Symbol]': 'symbol' }

          return function getType(obj) {
              if (obj == null) {
                  return obj + ''
              }
              // javascript高级程序设计中提供了一种方法,可以通用的来判断原始数据类型和引用数据类型
              const str = Object.prototype.toString.call(obj)
              return typeof obj === 'object' || typeof obj === 'function' ? class2type[str] || 'object' : typeof obj
          };
      })();

      /**
      * 判断两个元素是否相等
      * @param {any} o1 比较元素
      * @param {any} o2 其他元素
      * @returns {Boolean} 是否相等
      */
      const isEqual = (o1, o2) => {
          const t1 = getType(o1)
          const t2 = getType(o2)

          // 比较类型是否一致
          if (t1 !== t2) return false
          
          // 类型一致
          if (t1 === 'array') {
              // 首先判断数组包含元素个数是否相等
              if (o1.length !== o2.length) return false 
              // 比较两个数组中的每个元素
              return o1.every((item, i) => {
                  // return item === target
                  return isEqual(item, o2[i])
              })
          }

          if (t2 === 'object') {
              // object类型比较类似数组
              const keysArr = Object.keys(o1)
              if (keysArr.length !== Object.keys(o2).length) return false
              // 比较每一个元素
              return keysArr.every(k => {
                  return isEqual(o1[k], o2[k])
              })
          }

          return o1 === o2
      }

      // 数组去重
      const removeDuplicates = (arr) => {
          return arr.reduce((accumulator, current) => {
              const hasIndex = accumulator.findIndex(item => isEqual(current, item))
              if (hasIndex === -1) {
                  accumulator.push(current)
              }
              return accumulator
          }, [])
      }

      // 测试
      removeDuplicates([123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili", {a:1, b:2}, {b:2, a:1}])
      // [123, {a: 1}, a: {b: 1}, {a: "1"}, "meili", {a: 1, b: 2}]
      ```

### 图片懒加载

1. 参考链接

   [js 实现图片懒加载原理](https://blog.csdn.net/w1418899532/article/details/90515969)

   [图片懒加载原理及实现](https://www.jianshu.com/p/8e2a73638153)

2. 详解

   - 描述

     一个网页包含大量图片，并发加载会影响渲染速度和占用带宽，如果改为可视区域加载，则能优化性能。

   - 原理

     图片是否加载取决于 img 标签的 src，先不给 src 赋值，等到进入可视区域再赋值，这时候才请求图片

   - 思路

     1. loading 图片
     2. 判断可视区域：$img.offset().top <= $(window).height()+\$(window).scrollTop() 元素距离顶部的距离<=可视区域高度+窗口滚动距离
     3. 替换图片

   - 实现

     ```html
     <div class="imgList">
       <img class="lazy" src="img/loading.gif" data-src="img/pic1" alt="pic" />
       <img class="lazy" src="img/loading.gif" data-src="img/pic2" alt="pic" />
       <img class="lazy" src="img/loading.gif" data-src="img/pic3" alt="pic" />
     </div>
     <script>
       $(() => {
         let lazyload = () => {
           for (let i = 0; i < $(".lazy").length; i++) {
             if (
               $(".lazy").eq(i).offset().top <=
               $(window).height() + $(window).scrollTop()
             ) {
               $(".lazy").eq(i).attr("src", $(".lazy").eq(i).data("src"));
             }
           }
         };
         lazyload();
         $(window).on("scroll", function () {
           lazyload();
         });
       });
     </script>
     ```

### 正则获取URL参数

1. 参考链接

   [正则获取 URL 参数](https://www.cnblogs.com/elexiang/p/4732364.html)

2. 详解

   - 获取指定 URL 参数

   ```js
   function getUrlParams(name) {
     //(^|&)从头开始或匹配字符&,([^&]*)匹配不是&的任何内容,(&|$)遇到下一个&或者结束
     //在正则表达式中，增加一个()代表着匹配数组中增加一个值, 因此代码中的正则匹配后数组中应包含4个值(完整匹配+3个括号)
     var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
     var r = window.location.search.substr(1).match(reg);
     if (r != null) return unescape(r[2]); //获取([^&]*)的结果
     return null;
   }

   window.location = "http://www.baidu.com?name=elephant&age=25&sex=male";
   var name = getUrlParams("name"); //elephant
   var age = getUrlParams("age"); //25
   var sex = getUrlParams("sex"); //male
   ```

   - 获取所有的 URL 参数

   ```js
   function parse_url(_url) {
     //定义函数
     var pattern = /(\w+)=(\w+)/gi; //定义正则表达式
     var parames = {}; //定义数组
     url.replace(pattern, function (a, b, c) {
       //替换函数(完整匹配+2个括号)
       parames[b] = c;
     });
     return parames; //返回这个数组.
   }

   var url = "http://www.baidu.com?name=elephant&age=25&sex=male";
   var params = parse_url(url); // ["name=elephant", "age=25", "sex=male"]
   ```

### js操作cookie

1. 参考链接：

   - [十道大厂面试题(含答案)总结](https://mp.weixin.qq.com/s/o553cr1FHLz40PpxbO8oOw)
   - [JS 中 cookie 的设置，读取，删除，更新覆盖等](https://blog.csdn.net/baidu_31683691/article/details/52516413)
   - [运用 JS 设置 cookie、读取 cookie、删除 cookie](https://www.cnblogs.com/limeiky/p/6927305.html)

2. 详解：

   - 获取

   ```js
   function getCookie(name) {
     var arr,
       reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
     if ((arr = document.cookie.match(reg))) return unescape(arr[2]);
     else return null;
   }
   ```

   - 设置/添加

   ```js
   function setCookie(name, value) {
     var Days = 30;
     var exp = new Date();
     exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);
     document.cookie =
       name + "=" + escape(value) + ";expires=" + exp.toGMTString();
   }
   ```

   - 更新

   ```js
   function updateCookie(name, value) {
     var exp = new Date();
     exp.setTime(exp.getTime() - 1);
     var currentValue = getCookie(name);
     if (currentValue != null) {
       document.cookie =
         name + "=" + escape(value) + ";expires=" + exp.toGMTString();
     }
   }
   ```

   - 删除

   ```js
   function delCookie(name) {
     var exp = new Date();
     exp.setTime(exp.getTime() - 1);
     var cval = getCookie(name);
     if (cval != null)
       document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString();
   }
   ```


### 文件切片上传

1. 参考链接

   [前端 h5 文件切片上传,后台 php 接收切片并合并](https://www.ucloud.cn/yun/29610.html)

2. 详解

   没法实现错误重传，中途断网则中断，因为：

   1. 重传则快速递归 ajax 卡死浏览器，没法实现休眠 3 秒(js 单线程原因)来使 ajax 间隔开，因为 settimeout 没法同步执行，await 也没用
   2. 如果改为保存状态，把后面的执行完，再回头执行，也无法避免快速递归卡死的情况
   3. 无法通过服务器响应来阻塞程序，因为断网服务器不会有响应

   解决的办法：上传文件前，通过文件名(文件名相同，文件不同，则自行负责)向服务器询问是否有此文件的片段，有则返回序号，从序号开始继续分片上传。

   上传内容：

   1. 文件名
   2. 分片名
   3. 文件二进制流
   4. 分片序号
   5. 分片大小
   6. (总文件大小)
   7. (分片总数)

   ```html
   <input id="in" type="file" />
   <script>
     $(function () {
       let pieceSize = 10;
       var totalSize = 0;

       $("#in").on("change", function () {
         handleFiles(this.files);
       });

       async function handleFiles(fileList) {
         var i = 0;
         while (i < fileList.length) {
           console.log("=================================================");
           console.log(
             "开始处理第" +
               i +
               "个文件, 文件是" +
               fileList[i]["name"] +
               "大小是:" +
               fileList[i]["size"]
           );
           var targetFile = fileList[i];
           totalSize += targetFile.size;
           await uploadFile(targetFile, i);
           i++;
           if (i == fileList.length) return;
         }
       }

       async function uploadFile(targetFile, index) {
         //console.log(targetFile);
         var tmp = targetFile.name.split(".");
         //var filename = "file-" + guid() + '.' + tmp[tmp.length - 1];
         var fileSize = targetFile.size;
         var total = Math.ceil(fileSize / pieceSize);

         await handle();

         async function handle() {
           var i = 0;
           var start = (end = 0);
           while (i < total) {
             end = start + pieceSize;

             if (end >= fileSize) {
               end = fileSize;
             }

             console.log(
               "文件的index:" + index + "| 处理文件切片 i:" + i,
               "start:" + start,
               "end:" + end
             );
             var frag = targetFile.slice(start, end);

             var filename = "file-" + i + "." + tmp[tmp.length - 1];

             await send(filename, frag, i, total, function () {
               console.log(
                 "文件的index:" + index + "| 切片上传完成 回调 res111",
                 i
               );
             });

             start = end;
             i++;
           }
         }
       }

       //send
       async function send(filename, frag, index, total, cb) {
         var formData = new FormData();
         var fragname = "frag-" + index;

         formData.append("filename", filename);
         formData.append("fragname", fragname);
         formData.append("file", frag);
         formData.append("fragindex", index);
         formData.append("total", total);

         await $.ajax({
           url: "/cms/test1",
           type: "POST",
           cache: false,
           data: formData,
           processData: false,
           contentType: false,
         })
           .done(function (res) {
             //console.log('res:' + index);
             cb && cb();
           })
           .fail(function (res) {});
       }
     });
   </script>
   ```

### 长列表优化

1. 参考链接：

   [简洁、巧妙、高效的长列表，无限下拉方案](https://mp.weixin.qq.com/s/FVxt3ORsN6dq09t8rzHdRw)

   [vue-virtual-scroll-list 源代码](http://www.github.com/tangbc/vue-virtual-scroll-list)

   [Intersection Observer](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)

2. 详解

   - 两个要素

     1. intersection observer

        - 作用

          IntersectionObserver 接口 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根

          异步查询元素相对于其他元素或视窗的位置，消除了昂贵的 DOM 查询和样式读取成本。兼容性较差，需要 polyfill。

        - 场景

          1. 页面滚动时的懒加载实现。
          2. 无限下拉（本文的实现）。
          3. 监测某些广告元素的曝光情况来做相关数据统计。
          4. 监测用户的滚动行为是否到达了目标位置来实现一些交互逻辑（比如视频元素滚动到隐藏位置时暂停播放）。

     2. padding

   - 长列表优化思路

     - 监听一个固定长度列表的首尾元素是否进入视窗;
     - 更新当前页面内渲染的第一个元素对应的序号;
     - 根据上述序号，获取目标数据元素，列表内容重新渲染成对应内容;
     - 容器 padding 调整，模拟滚动实现。

     核心：利用父元素的 padding 去填充随着无限下拉而本该有的、越来越多的 DOM 元素，仅仅保留视窗区域上下一定数量的 DOM 元素来进行数据渲染。

   - 实现

     1. 监听一个固定长度列表的首尾元素是否进入视窗

        ```js
        // 观察者创建
        this.observer = new IntersectionObserver(callback, options);

        // 观察列表第一个以及最后一个元素
        this.observer.observe(this.firstItem);
        this.observer.observe(this.lastItem);

        //当他们其中一个重新进入视窗时，callback 函数就会触发
        const callback = (entries) => {
          entries.forEach((entry) => {
            if (entry.target.id === firstItemId) {
              // 当第一个元素进入视窗
            } else if (entry.target.id === lastItemId) {
              // 当最后一个元素进入视窗
            }
          });
        };
        ```

     2. 更新当前页面渲染的第一个元素对应的序号 (firstIndex)

        - 用一个数组来维护需要渲染到页面中的数据。数组的长度会随着不断请求新的数据而不断变大，而渲染的始终是其中一定数量的元素,比如 20 个

        - 最开始渲染的是数组中序号为 0 - 19 的元素，即此时对应的 firstIndex 为 0

        - 当序号为 19 的元素（即上一步的 lastItem ）进入视窗时，我们就会往后渲染 10 个元素，即渲染序号为 10 - 29 的元素，那么此时的 firstIndex 为 10

        - 下一次就是，当序号为 29 的元素进入视窗时，继续往后渲染 10 个元素，即渲染序号为 20 - 39 的元素，那么此时的 firstIndex 为 20，以此类推

        ```js
        // 我们对原先的 firstIndex 做了缓存
        const { currentIndex } = this.domDataCache;

        // 以全部容器内所有元素的一半作为每一次渲染的增量
        const increment = Math.floor(this.listSize / 2);

        let firstIndex;

        //更新 firstIndex，是为了根据页面的滚动情况，知道接下来哪些数据应该被获取、渲染
        if (isScrollDown) {
          // 向下滚动时序号增加
          firstIndex = currentIndex + increment;
        } else {
          // 向上滚动时序号减少
          firstIndex = currentIndex - increment;
        }
        ```

     3. 根据上述序号，获取对应数据元素，列表重新渲染成新的内容

        ```js
        //根据 firstIndex 查询数据，然后将目标数据渲染到页面上
        const renderFunction = (firstIndex) => {
          // offset = firstIndex, limit = 10 => getData
          // getData Done =>  new dataItems => render DOM
        };
        ```

     4. padding 调整，模拟滚动实现

        这 10 个新的数据元素，我们用原来已有的 DOM 元素去渲染，替换掉已经离开视窗、不可见的数据元素;而本该由更多 DOM 元素进一步撑开容器高度的部分，我们用 padding 填充来模拟实现。

        向下滚动

        ```js
        // padding的增量 = 每一个item的高度 x 新的数据项的数目
        const remPaddingsVal = itemHeight * Math.floor(this.listSize / 2);

        if (isScrollDown) {
          // paddingTop新增，填充顶部位置
          newCurrentPaddingTop = currentPaddingTop + remPaddingsVal;

          if (currentPaddingBottom === 0) {
            newCurrentPaddingBottom = 0;
          } else {
            // 如果原来有paddingBottom则减去，会有滚动到底部的元素进行替代
            newCurrentPaddingBottom = currentPaddingBottom - remPaddingsVal;
          }
        }
        ```

        向上滚动

        ```js
        // padding的增量 = 每一个item的高度 x 新的数据项的数目
        const remPaddingsVal = itemHeight * Math.floor(this.listSize / 2);

        if (!isScrollDown) {
          // paddingBottom新增，填充底部位置
          newCurrentPaddingBottom = currentPaddingBottom + remPaddingsVal;

          if (currentPaddingTop === 0) {
            newCurrentPaddingTop = 0;
          } else {
            // 如果原来有paddingTop则减去，会有滚动到顶部的元素进行替代
            newCurrentPaddingTop = currentPaddingTop - remPaddingsVal;
          }
        }
        ```

        最后是 padding 设置更新以及相关缓存数据更新

        ```js
        // 容器padding重新设置
        this.updateContainerPadding({
          newCurrentPaddingBottom,
          newCurrentPaddingTop,
        });

        // DOM元素相关数据缓存更新
        this.updateDomDataCache({
          currentPaddingTop: newCurrentPaddingTop,
          currentPaddingBottom: newCurrentPaddingBottom,
        });
        ```

     - 优势

       把同步触发的滚动事件变为异步，无需做防抖

     - 缺陷

       1. padding 计算依赖列表项固定高度
       2. 数据请求过程需要 loading 效果
       3. 需要兼容用户难以预测的滚动行为

   - 其它库

     - iScroll

       scroll 事件监听，translate 上下移，视窗外元素插入队尾，循环队列，无限下拉

### 活动倒计时

1.  参考链接：

    [js 计算两个时间时间差（天时分秒）](https://www.jianshu.com/p/e5bb679f92c7)

    [js 计算两个时间差 年月日时分秒](https://blog.csdn.net/qq_36279445/article/details/103493495)

2.  详解

    1.  方法概述

        计算时间 getTime()的时间戳差值，换算为年月日时分秒，setInterval 调用一次逻辑

    2.  实现

        ```js
        var future = "2017-04-04";

        var calculationTime = function (future) {
          var s1 = new Date(future.replace(/-/g, "/")),
            s2 = new Date(),
            runTime = parseInt((s1.getTime() - s2.getTime()) / 1000);
          var year = Math.floor(runTime / 86400 / 365);
          runTime = runTime % (86400 * 365);
          var month = Math.floor(runTime / 86400 / 30);
          runTime = runTime % (86400 * 30);
          var day = Math.floor(runTime / 86400);
          runTime = runTime % 86400;
          var hour = Math.floor(runTime / 3600);
          runTime = runTime % 3600;
          var minute = Math.floor(runTime / 60);
          runTime = runTime % 60;
          var second = runTime;
          return [year, month, day, hour, minute, second];
        };
        setInterval(function () {
          var result = calculationTime(future);
          //更新视图
        }, 1000);
        ```

### 数据埋点与错误监控

1. 参考链接：

   [关于数据埋点](https://www.jianshu.com/p/9303296f59e5)

   [第五期 | 前端监控怎么玩？](https://juejin.im/post/5ea3eb326fb9a03c485791f9)

   [如何清楚易懂的解释“UV 和 PV＂的定义？](https://www.zhihu.com/question/20448467)

   [有关 cookie 实现统计 pv,uv 的一些用法](https://blog.csdn.net/lfcss/article/details/45247577)

   [原生 js 操作 cookie](https://www.cnblogs.com/tutuj/p/10991283.html)

   [js 记录用户在网站的浏览记录和停留时间](https://blog.csdn.net/canglingyue/article/details/52409265)

   [前端性能优化指南 6--Web 性能标准](https://juejin.im/post/5eb745b35188256d7a3cae01#heading-1)

   [搭建前端监控系统（二）JS 错误监控篇](https://www.cnblogs.com/warm-stranger/p/9417084.html)

   [window onerror 各浏览器下表现总结](https://segmentfault.com/a/1190000011041164)

   [JS 错误监控总结](https://segmentfault.com/a/1190000014672384)

   [Sentry 的使用](https://www.jianshu.com/p/280ed215c0d2)

   [一文读懂产品曝光埋点](http://www.woshipm.com/pd/3226195.html)

   [埋点与动态创建<img>、<script>](https://segmentfault.com/a/1190000020002603?utm_source=tag-newest)

   [前端监控平台系列：JS SDK（已开源）](https://juejin.im/post/6862559324632252430#heading-26)

   [webfunny_monitor](https://github.com/a597873885/webfunny_monitor)

   [前端监控方案](https://github.com/xpsilvester/Notes/blob/master/Project/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88.md)

   [手把手带你入门前端工程化——超详细教程](https://juejin.im/post/6892003555818143752#heading-57)

   [vue声明式埋点实践](https://blog.csdn.net/weixin_34283445/article/details/91428551)

   [如何从零打造 web 性能监控系统？](https://mp.weixin.qq.com/s/YFoI1w1bS1lguv04hamumw)

2. 详解

   ![错误监控](./errorMonitor.jpg)

   ![错误采集](./errorCapture.jpg)

   [前端监控方案](https://github.com/xpsilvester/Notes/blob/master/Project/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88.md)

   - 国内常用的监控平台

      - sentry ：从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵
      - fundebug：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐
      - webfunny：也是含有监控错误的功能，可以支持千万级别日PV量，额外的亮点是可以远程调试、性能分析，也可以docker私有化部署（免费），业务代码加密过，[webfunny_monitor](https://github.com/a597873885/webfunny_monitor)

   - 合成监控工具

      * 优缺点

        * 无侵入性。
        * 简单快捷。缺点：
        * 不是真实的用户访问情况，只是模拟的。
        * 没法考虑到登录的情况，对于需要登录的页面就无法监控到。

      * chrome插件

        lighthouse

      * node

        * lighthouse
        
          npm install -g lighthouse

          lighthouse https://www.cnblogs.com/

      * 站点

        webpagetest：https://www.webpagetest.org/

        Pingdom：https://tools.pingdom.com/

     - 真实用户监控平台

        * 优缺点

          * 是真实用户访问情况。
          * 可以观察历史性能趋势。
          * 有一些额外的功能：报表推送、监控告警等等。缺点：
          * 有侵入性，会一定程度上响应 web 性能。

        * oneapm：https://www.oneapm.com/bi/feature.html
        * Datadog：https://www.datadoghq.com/rum/
        * FrontJs：https://www.frontjs.com/

   - 自研监控平台需要做三个部分：

      - APP监控SDK：收集错误信息并上报
      - server端：接收错误信息，处理数据并做持久化，而后根据告警规则通知对应的开发人员
      - 可视化平台：从数据存储引擎拿出相关错误信息进行渲染，用于快速定位问题

   - 单页面埋点方案

      - 命令式埋点：在用户产生行为的地方使用js方法进行数据上报，优点是埋点方式比较简单，缺点是与业务耦合度较高
      - 声明式埋点：在具体DOM元素上进行数据绑定，只需组件开发人员在sdk上制定埋点方案，业务开发人员设置数据即可，优点是埋点代码与具体的交互和业务逻辑解耦
      - 可视化埋点：通过可视化工具配置埋点，需要另外配套一个平台控制埋点的埋入，优点是自动生成埋点代码嵌入到页面中，减轻业务开发人员的埋点负担，目前做得好得例如Mixpanel
      - 无埋点：前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是完全无需业务参与，完全与业务解耦，目前比较流行的例如GrowingIO

   - 数据埋点

     - 数据埋点的方式

       1. 注入自己研发的代码和搭建后台统计
       2. 第三方统计工具，如百度统计、友盟、神策、数极客、Talkingdata、GrowingIO、Fundebug、FrontJS、Sentry 等

     - 关键指标

       1. 访问次数（Visits）与访问人数（Vistors）
       2. 停留时长

          - 采集数据：最小时长，最大时长，平均时长，中位数
          - 采集事件：鼠标、滚动、键盘、自定义事件

       3. 跳出率(用户只访问了一个页面所占的会话比例,分为应用的跳出率、着陆页的跳出率)
       4. 退出率(某个页面有多少用户离开了应用,退出率高不一定是坏事,流程的最终节点的退出率就应该是高的)
       5. 转化率(某种产出,如订单,除以独立访客或是访问量,或某条路径的转化率)
       6. 参与度(访问深度，访问频次，播放次数等)
       7. 用户地域分布(ip)
       8. 页面来源分布：内链、外链、搜索引擎(referer)
       9. 广告位点击率：点击次数/曝光次数

     - 注意

       埋点贵精不贵多

     - 曝光埋点

       点击率的计算：CTR=点击数/曝光数

       场景：活动入口有一张 banner，要统计用户是否有看此 banner，即曝光数

       条件：用户需要滑动到推荐区域，至少露出一个卡片的高度，至少需要在推荐区域停留时长不少于 15s，一定时间内重复滑动不重复上报

   - 组件监控

     - 关键指标

       1. 引用量，引用次数高对此组件的优先级也高
       2. 曝光点击率： 引导转化率 = 引导成交量/点击量/曝光量
       3. 数据接口： 加载时间、组件异常、白屏率
       4. 配置复杂度：比如输入转选择类型，预设默认值，减少用户配置时间
       5. 代码质量：编译过程中，ESlint 上报不合规

     - 监控场景

       1. 用户监控： 埋点-> 采集 -> 计算 -> 分析
       2. 错误监控：错误收集-> 错误上报 -> 数据清洗 -> 数据持久化 -> 平台可视化、监控

   - 埋点样例

     1. UV（Unique visitor）

        - 定义

          访问您网站的一台电脑客户端为一个访客。00:00-24:00 内相同的客户端只被计算一次。

        - 统计方法

          1. 计入页面查找 cookie 预设字段是否存在
          2. 不存在则设置 cookie 预设字段，设置此信息 expire 为 24 小时，带 jwt 发送请求，包含用户 id、当天首次进入时间等信息

     2. PV（Page View）

        - 定义

          页面浏览量，或点击量;用户每 1 次对网站中的每个网页访问均被记录 1 次。用户对同一页面的多次访问，访问量累计。

        - 统计方法

          进入页面即发请求，可包含进入时间、用户 id 等信息

     3. IP（Internet Protocol）

        - 定义

          1 天内独立 IP 访问数至多计算 1 次

        - 统计方法

          同 UV

     4. VV（Visit View）

        - 定义

          统一访客访问网站的次数，从打开网站，到点击各标签，到完全关闭，计数加一

        - 统计方法

          总体上类似 UV，使用 cookie 统计，不同之处是打开页面 onload 时 cookie 信息中的页面数+1，关闭页面 beforeunload，cookie 信息中的页面数-1，页面数为 0 时发送请求，清除这段 cookie

     5. 用户停留时间

        - 统计方法

          1. window 的 focus 和 blur 能找出用户是否在浏览当前页面
          2. setInterval 统计时间，window 的 blur 可停止计时，window 的 focus 可读取信息，合并并继续计时
          3. localstorage 因存储量比 cookie 大，可用来记录信息，信息为 json，通过 stringify 和 parse 保存和提取，信息包括当前 url(location.href)、停留时间、来源 url(document.referer)、进入时间、离开时间等
          4. onload(包括刷新)可记录进入时间，读取上次保存的信息(如有)，可继续计时等操作
          5. beforeunload 可记录离开时间，发送请求，清除信息

     6. 动态创建 img 或 script

        - 使用原因

          - 埋点一般不用关心请求的结果
          - 可以实现跨域请求
          - 无需使用 ajax 就能达到发请求的目的
          - 都是原生实现，兼容性好

        - 动态创建 img

          ```js
          function sendByImg(src) {
            var img = document.createElement("img");
            img.src = src;
          }
          ```

          ```js
          function sendByImage(src) {
            var img = new Image();
            img.src = src;
          }
          ```

        - 动态创建 script

          ```js
          function sendByScript(src) {
            var script = document.createElement("script");
            script.src = src;
            (
              document.getElementsByTagName("head")[0] ||
              document.getElementsByTagName("body")[0]
            ).appendChild(script);
          }
          ```

        - 区别

          1. 触发请求，script 必须插入到 DOM，而 img 均不需要
          2. script 可以借助类似 jsonp 实现原理处理请求结果，img 不能

        - 推荐使用

          首选 script 方式：拓展性和兼容性好，能处理回调，不怕禁用图片模式

   - 错误监控

    - 情况

      1. js 编译时异常（开发阶段就能排）
      2. js 运行时异常
      3. 加载静态资源异常（路径写错、资源服务器异常、CDN 异常、跨域）
      4. 接口请求异常

    - 流程

      监控错误 -> 搜集错误 -> 存储错误 -> 分析错误 -> 错误报警-> 定位错误 -> 解决错误

    - 必要的数据

      应用 JS 报错的走势(chart 图表)、JS 错误发生率、JS 错误在 PC 端发生的概率、JS 错误在 IOS 端发生的概率、JS 错误在 Android 端发生的概率，以及 JS 错误的归类

    - 辅助信息

      JS 错误类型、 JS 错误信息、JS 错误堆栈、JS 错误发生的位置以及相关位置的代码;JS 错误发生的几率、浏览器的类型，版本号，设备机型等等辅助信息

    - 数据代码封装

      ```js
      // 设置日志对象类的通用属性
      function setCommonProperty() {
        this.happenTime = new Date().getTime(); // 日志发生时间
        this.webMonitorId = WEB_MONITOR_ID; // 用于区分应用的唯一标识（一个项目对应一个）
        this.simpleUrl = window.location.href.split("?")[0].replace("#", ""); // 页面的url
        this.customerKey = utils.getCustomerKey(); // 用于区分用户，所对应唯一的标识，清理本地数据后失效
        this.pageKey = utils.getPageKey(); // 用于区分页面，所对应唯一的标识，每个新页面对应一个值
        this.deviceName = DEVICE_INFO.deviceName;
        this.os =
          DEVICE_INFO.os +
          (DEVICE_INFO.osVersion ? " " + DEVICE_INFO.osVersion : "");
        this.browserName = DEVICE_INFO.browserName;
        this.browserVersion = DEVICE_INFO.browserVersion;
        // TODO 位置信息, 待处理
        this.monitorIp = ""; // 用户的IP地址
        this.country = "china"; // 用户所在国家
        this.province = ""; // 用户所在省份
        this.city = ""; // 用户所在城市
        // 用户自定义信息， 由开发者主动传入， 便于对线上进行准确定位
        this.userId = USER_INFO.userId;
        this.firstUserParam = USER_INFO.firstUserParam;
        this.secondUserParam = USER_INFO.secondUserParam;
      }

      // JS错误日志，继承于日志基类MonitorBaseInfo
      function JavaScriptErrorInfo(uploadType, errorMsg, errorStack) {
        setCommonProperty.apply(this);
        this.uploadType = uploadType;
        this.errorMessage = encodeURIComponent(errorMsg);
        this.errorStack = errorStack;
        this.browserInfo = BROWSER_INFO;
      }
      JavaScriptErrorInfo.prototype = new MonitorBaseInfo();
      ```

    - 错误监控代码

      1. 重写 window.onerror，判断e.target.localName是否有值，有的话就是资源错误，没就是代码错误，通过event.target拿到

      2. 重写 console.error，如果 App 首次向浏览器注入的 Js 代码报错了，window.onerror 是无法监控到的，所以只能重写 console.error 的方式来进行捕获,待 window.onerror 成功后，此方法便不再需要用了

      3. 重写 window.onunhandledrejection 方法。 当用到 Promise 又忘记写 reject 的捕获方法的时候，系统会抛出一个 Unhandled Promise rejection. 没有堆栈，没有其他信息，特别是在写 fetch 请求的时候很容易发生。

      ```js
      //页面JS错误监控
      function recordJavaScriptError() {
        // 重写console.error, 可以捕获更全面的报错信息
        var oldError = console.error;
        console.error = function () {
          // arguments的长度为2时，才是error上报的时机
          // if (arguments.length < 2) return;
          var errorMsg = arguments[0] && arguments[0].message;
          var url = WEB_LOCATION;
          var lineNumber = 0;
          var columnNumber = 0;
          var errorObj = arguments[0] && arguments[0].stack;
          if (!errorObj) errorObj = arguments[0];
          // 如果onerror重写成功，就无需在这里进行上报了
          !jsMonitorStarted &&
            siftAndMakeUpMessage(
              errorMsg,
              url,
              lineNumber,
              columnNumber,
              errorObj
            );
          return oldError.apply(console, arguments);
        };
        // 重写 onerror 进行jsError的监听
        window.onerror = function (
          errorMsg,
          url,
          lineNumber,
          columnNumber,
          errorObj
        ) {
          jsMonitorStarted = true;
          var errorStack = errorObj ? errorObj.stack : null;
          siftAndMakeUpMessage(
            errorMsg,
            url,
            lineNumber,
            columnNumber,
            errorStack
          );
        };

        function siftAndMakeUpMessage(
          origin_errorMsg,
          origin_url,
          origin_lineNumber,
          origin_columnNumber,
          origin_errorObj
        ) {
          var errorMsg = origin_errorMsg ? origin_errorMsg : "";
          var errorObj = origin_errorObj ? origin_errorObj : "";
          var errorType = "";
          if (errorMsg) {
            var errorStackStr = JSON.stringify(errorObj);
            errorType = errorStackStr.split(": ")[0].replace('"', "");
          }
          var javaScriptErrorInfo = new JavaScriptErrorInfo(
            JS_ERROR,
            errorType + ": " + errorMsg,
            errorObj
          );
          javaScriptErrorInfo.handleLogInfo(JS_ERROR, javaScriptErrorInfo);
        }
      }
      ```

      4. JS 错误发生率 = JS 错误个数(一次访问页面中，所有的 js 错误都算一次)/PV (PC，IOS，Android 平台同理)

      ```js
      /**
      * 添加一个定时器，进行数据的上传
      * 2秒钟进行一次URL是否变化的检测
      * 10秒钟进行一次数据的检查并上传
      */
      var timeCount = 0;
      setInterval(function () {
        checkUrlChange();
        // 循环5后次进行一次上传
        if (timeCount >= 25) {
          // 如果是本地的localhost, 就忽略，不进行上传

          var logInfo =
            (localStorage[ELE_BEHAVIOR] || "") +
            (localStorage[JS_ERROR] || "") +
            (localStorage[HTTP_LOG] || "") +
            (localStorage[SCREEN_SHOT] || "") +
            (localStorage[CUSTOMER_PV] || "") +
            (localStorage[LOAD_PAGE] || "") +
            (localStorage[RESOURCE_LOAD] || "");

          if (logInfo) {
            localStorage[ELE_BEHAVIOR] = "";
            localStorage[JS_ERROR] = "";
            localStorage[HTTP_LOG] = "";
            localStorage[SCREEN_SHOT] = "";
            localStorage[CUSTOMER_PV] = "";
            localStorage[LOAD_PAGE] = "";
            localStorage[RESOURCE_LOAD] = "";
            utils.ajax(
              "POST",
              HTTP_UPLOAD_LOG_INFO,
              { logInfo: logInfo },
              function (res) {},
              function () {}
            );
          }
          timeCount = 0;
        }
        timeCount++;
      }, 200);
      ```

      5. 监控ajax和fetch的error回调

      6. vue报错函数回调：Vue.config.errorHandler和Vue.config.warnHandler，react有componentDidCatch钩子函数来回调错误信息

      7. Navigator.sendBeacon异步传输传输数据，在 unload 或者 beforeunload 事件处理器中发起一个同步 XMLHttpRequest 来发送数据，迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚

    - 定位与分析

      1. 某种错误发生的次数——发生次数跟影响用户是成正比的，如果发生次数跟影响用户数量都很高，那么这是一个比较严重的 bug, 需要立即解决。反之，如果次数很多，影响用户数量很少。说明这种错误只发生在少量设备中，优先级相对较低，可以择时对该类机型设备进行兼容处理。当然，ip 地址访问次数也能说明这个问题。

      2. 页面发生了哪些错误——这个有利于我们缩小问题的范围，方便我们排查

      3. 错误堆栈——是定位错误最重要的因素。正常情况下，代码都是被压缩的，利用 jsMap 反向找到代码的具体位置

      4. 设备信息——当错误发生是，分析出用户当时使用设备的浏览器信息，系统版本，设备机型等等，能够帮我们快速的定位到需要兼容的设备

      5. 用户足迹——代价太高，因为需要记录下用户在页面上的所有行为，需要上传非常多的数据

      6. 实时监控与报警

### npm版本号的区别

1.  参考链接：

    [npm 依赖包版本号~和^的区别](https://www.jianshu.com/p/4544a1e63a5c)

2.  详解

    ~会匹配最近的小版本依赖包，比如~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0

    ^会匹配最新的大版本依赖包，比如^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0

### 摄像头抓拍与RTC音视频会议

1.  参考链接：

    [js 调用摄像头拍照上传图片](https://www.cnblogs.com/51ma/p/11611487.html)

    [getUserMedia API 及 HTML5 调用摄像头和麦克风](https://www.cnblogs.com/cangqinglang/p/10210826.html)

    [MediaDevices.getUserMedia` undefined 的问题](https://www.cnblogs.com/Wayou/p/using_MediaDevices_getUserMedia_wihtout_https.html)

    [基于webrtc的音视频聊天，视频会议的实现](https://blog.csdn.net/xqtt29/article/details/109530221)

2.  详解

通过 MediaDevices.getUserMedia() 获取用户多媒体权限时，需要注意其只工作于以下三种环境：

* localhost 域
* 开启了 HTTPS 的域
* 使用 file:/// 协议打开的本地文件

```txt
其他情况下，比如在一个 HTTP 站点上，navigator.mediaDevices 的值为 undefined。

如果想要 HTTP 环境下也能使用和调试 MediaDevices.getUserMedia()，可通过开启 Chrome 的相应参数。

通过相应参数启动 Chrome
传递相应参数来启动 Chrome，以 http://example.com 为例，

--unsafely-treat-insecure-origin-as-secure="http://example.com"
开启相应 flag
通过传递相应参数来启动 Chrome Insecure origins treated as secure flag 并填入相应白名单。

打开 chrome://flags/#unsafely-treat-insecure-origin-as-secure
将该 flag 切换成 enable 状态
输入框中填写需要开启的域名，譬如 http://example.com"，多个以逗号分隔。
重启后生效。
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>摄像头拍照</title>
  </head>
  <body>
    <video id="video" width="480" height="320" controls></video>
    <div>
      <button id="open">开启摄像头</button>
      <button id="close">关闭摄像头</button>
      <button id="capture">拍照</button>
    </div>
    <canvas id="canvas" width="480" height="320"></canvas>
    <img id="img" width="480" height="320" />
    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let context = canvas.getContext("2d");

      //访问用户媒体设备的兼容方法
      function getUserMedia(constraints, success, error) {
        if (navigator.mediaDevices.getUserMedia) {
          //最新的标准API
          navigator.mediaDevices
            .getUserMedia(constraints)
            .then(success)
            .catch(error);
        } else if (navigator.webkitGetUserMedia) {
          //webkit核心浏览器
          navigator.webkitGetUserMedia(constraints, success, error);
        } else if (navigator.mozGetUserMedia) {
          //firfox浏览器
          navigator.mozGetUserMedia(constraints, success, error);
        } else if (navigator.getUserMedia) {
          //旧版API
          navigator.getUserMedia(constraints, success, error);
        }
      }

      // 打开摄像头成功回调
      function success(stream) {
        //兼容webkit核心浏览器
        let CompatibleURL = window.URL || window.webkitURL;
        //将视频流设置为video元素的源
        console.log(stream);

        //video.src = CompatibleURL.createObjectURL(stream);
        video.srcObject = stream;
        video.play();
      }

      // 打开摄像头失败回调
      function error(error) {
        console.log(`访问用户媒体设备失败${error.name}, ${error.message}`);
      }

      // 关闭摄像头
      function closeMedia() {
        let stream = video.srcObject;
        let tracks = stream.getTracks();

        tracks.forEach(function (track) {
          track.stop();
        });

        video.srcObject = null;
      }

      // 开启摄像头
      function openMedia() {
        if (
          navigator.mediaDevices.getUserMedia ||
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia
        ) {
          //调用用户媒体设备, 访问摄像头
          getUserMedia({ video: { width: 480, height: 320 } }, success, error);
        } else {
          alert("不支持访问用户媒体");
        }
      }

      document.getElementById("open").addEventListener("click", function () {
        openMedia();
      });

      document.getElementById("close").addEventListener("click", function () {
        closeMedia();
      });

      document.getElementById("capture").addEventListener("click", function () {
        context.drawImage(video, 0, 0, 480, 320);
        let src = canvas.toDataURL("image/png");
        document.getElementById("img").src = src; //上传src部分(base64)即可
        // $.ajax({
        //   url:"...",
        //   type:"post",
        //   data:{"imgData":src},
        //   success:function(data){
        //     console.log(data);
        //   },
        //   error:function(){
        //     console.log("服务端异常！");
        //   }
        // });
      });
    </script>
  </body>
</html>
```

采集本地摄像头和麦的媒体数据
```js
navigator.mediaDevices.getUserMedia({video: true, audio: true}).then((stream) => {
  //这里的stream就是我们想要的视频流和音频流的集合了
  //如果要在本地预览视频和音频，则只需要在html中添加一个video标签，将stream流赋给video标签即可，代码如下：
  let localVideo = document.getElementById('video标签的id');
  localVideo.srcObject = stream;
  localVideo.muted = true;
  localVideo.play();
})
```

RTCPeerConnection
```js

let rtcPeerConnection = new RTCPeerConnection({
  "iceServers":[{
      "url": "stun:stun.l.google.com:19302"
      },{
      "url": "turn:服务器IP", 
      "credential":"密码",
      "username":"账号"
  }]
});
//监听stun返回的NAT穿透信息：ICECandidate
rtcPeerConnection.onicecandidate = (event) => {
  //如果获取到了我的NAT穿透消息，则立马通过websocket将event.candidate传送到对方。一旦双方通过candidate成功建立连接，就会通过下面这个监听进行音视频流的传输。
  wx.send(event.candidate)
}
//监听传输轨道的传输数据
rtcPeerConnection.ontrack = (event) => {
  //通过event.streams就能获取到对方传送过来的音视频流，将他再添加到另一个video标签上，就是可以看到对方的画面啦
  let remoteVideo = document.getElementById("对方video标签的id");
  remoteVideo.srcObject = event.streams[0];
  remoteVideo.play();
}
//这里的localVideo是知识点解析的第1步获取到的本地音视频video标签，将他的流加入到传输轨道，连接一旦建立就立马触发ontrack事件，将本地的音视频流传到对方。
for (const track of localVideo.stream.getTracks()) {
  rtcPeerConnection.addTrack(track, this.videos[0].stream);
}
```

向对方发起offer
```js
rtcPeerConnection.createOffer({iceRestart: true, offerToReceiveAudio: true, offerToReceiveVideo: true}).then(
  (sessionDescription) => {
    rtcPeerConnection.setLocalDescription(sessionDescription)
    //这里还需要将sessionDescription通过websocket发送给对方，对方才能收到视频邀请
    wx.send(sessionDescription)
  }
)
```

如果对方收到了offer，那么就设置对方sessionDescription，并回传一个应答answer
```js
//这里的sessionDescription是通过offer传过来的
rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(sessionDescription));
rtcPeerConnection.createAnswer({iceRestart: true, offerToReceiveAudio: true, offerToReceiveVideo: true}).then(
  (sessionDescription) => {
    rtcPeerConnection.setLocalDescription(sessionDescription)
    //这里将sessionDescription通过websocket回传给邀请方
    wx.send(sessionDescription)
  }
)
```

发送方收到了answer应答后也同样设置对方sessionDescription
```js
rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(sessionDescription));
```

当STUN服务器获取到icecandidate后并通过websocket传过来了，我们就需要将对方candidate设置一下，对应第一步的onicecandidate监听事件
```js
rtcPeerConnection.addIceCandidate(candidate)
```

### js加解密哈希编码

1.  参考链接：

    [js中常见的数据加密与解密的方法](https://www.jianshu.com/p/95d8eeb8301f)

    [js中使用btoa和atob进行Base64的编码和解码](https://blog.csdn.net/yihanzhi/article/details/88356232)

    [JS实现Base64编码、解码，即window.atob，window.btoa功能](https://www.cnblogs.com/goloving/p/11374083.html)

2.  详解

  ```html
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
  <script src="https://cdn.bootcss.com/jsencrypt/3.0.0-beta.1/jsencrypt.js"></script>
  <script src="https://cdn.bootcss.com/crypto-js/3.1.9-1/crypto-js.js"></script>
  <script type="text/javascript">
      //md5
      var hash = md5("111111"); // "96e79218965eb72c92a549dd5a330112"
      console.log(hash);

      //RSA
      //公钥
      var PUBLIC_KEY = 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCADB+zg4Ou3fv6rY8159gw4fkJbuMPeM41ttw20leKjSKQWOgBixHJjXbkRvoMmUQkWq67xWzpMgKB7t8LIJx+n0dLP+6YDqbfFEJJ2i1Va4U1yJyGht0bEW0tpadKX3i5JwUwQIBPiC7VSWhtVyAKtzTYeun/fqpxTDAbulrj4QIDAQAB';
      //私钥
      var PRIVATE_KEY = 'MIICWwIBAAKBgQCADB+zg4Ou3fv6rY8159gw4fkJbuMPeM41ttw20leKjSKQWOgBixHJjXbkRvoMmUQkWq67xWzpMgKB7t8LIJx+n0dLP+6YDqbfFEJJ2i1Va4U1yJyGht0bEW0tpadKX3i5JwUwQIBPiC7VSWhtVyAKtzTYeun/fqpxTDAbulrj4QIDAQABAoGACj/Y2m0orBAfvHvfrpBtc9LlX2sX/g6M7wFr6hrMdWOBBJiL5Z0PTO39D3Ow +IjcyqN+62UiUnOK04IJKiJaSa1HNWagW2aAOblca1lYyYD6wlUotMV3bgk9lly0dD0lUTd8XWOmo1NdTEFW7y1OB4pYgMcT+iv4o0cr4sAtWisCQQCD6EmjEpMI5dcfZcrSXbT+WQGvdVCjAhivVMbNYeZq37ARt+9mTnaoA6Ss/QGQ5qvO9jMhx8x9/e8EfA+AX2rzAkEA+II3IXRXY3xbjDnK84kunlWpImH6XofN2V/TGEH1/Iqa909PHhuL4mhSt0iC70/y1g5kbmXyXE5s5gEsPqmC2wJAAU9uY9NMaJs33tT5Bcvuf1RNAvwsV+Iucpdp/iJJ0qf0LMjh9Oc0oIiguyMsP886x6yEZ4J/koTSOf4tfT31ZwJAMs28I5S7QNVtic9O1FbZNvlgKG1LWAP/a08RwsXJWiWj5KdMD2WmRVT6hAnI6s+3X1d15LPmxkQqMyNOPkk9PQJAJyPGWOjrCjzwojE0lN4NtS9brx6JbPy/sFkHX5LN8Xv45+XOKp14JgRcABTfWfvnnoWoWKha2cyJFlf8AdCIuQ==';
      //使用公钥加密
      var encrypt = new JSEncrypt();
        //encrypt.setPrivateKey('-----BEGIN RSA PRIVATE KEY-----'+PRIVATE_KEY+'-----END RSA PRIVATE KEY-----');
      encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');
      var encrypted = encrypt.encrypt('ceshi01');
      console.log('加密后数据:%o', encrypted);
      //使用私钥解密
      var decrypt = new JSEncrypt();
      //decrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');
      decrypt.setPrivateKey('-----BEGIN RSA PRIVATE KEY-----'+PRIVATE_KEY+'-----END RSA PRIVATE KEY-----');
      var uncrypted = decrypt.decrypt(encrypted);
      console.log('解密后数据:%o', uncrypted);

      //AES
      var aseKey = "12345678"     //秘钥必须为：8/16/32位
      var message = "我是一个密码";
      //加密 DES/AES切换只需要修改 CryptoJS.AES <=> CryptoJS.DES
      var encrypt = CryptoJS.AES.encrypt(message, CryptoJS.enc.Utf8.parse(aseKey), {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
      }).toString();
      console.log(encrypt); // 0Gh9NGnwOpgmB525QS0JhVJlsn5Ev9cHbABgypzhGnM
      //解密
      var decrypt = CryptoJS.AES.decrypt(encrypt, CryptoJS.enc.Utf8.parse(aseKey), {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
      }).toString(CryptoJS.enc.Utf8);
      console.log(decrypt); // 我是一个密码 

      //base64
      window.btoa('<script src="test.js"></script>'); 
      window.atob("PHNjcmlwdCBzcmM9InRlc3QuanMiPjwvc2NyaXB0Pg=="); 
      //不能使用window的情况
      var Base64 = {
        _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        _utf8_encode: function(string) {
          string = string.replace(/\r\n/g,"\n");
          let utftext = "";
          for (let n = 0; n < string.length; n++) {
            let c = string.charCodeAt(n);
            if (c < 128) {
              utftext += String.fromCharCode(c);
            } else if((c > 127) && (c < 2048)) {
              utftext += String.fromCharCode((c >> 6) | 192);
              utftext += String.fromCharCode((c & 63) | 128);
            } else {
              utftext += String.fromCharCode((c >> 12) | 224);
              utftext += String.fromCharCode(((c >> 6) & 63) | 128);
              utftext += String.fromCharCode((c & 63) | 128);
            }

          }
          return utftext;
        },
        _utf8_decode: function(utftext) {
          let string = "";
          let i = 0;
          let c = 0;
          let c1 = 0;
          let c2 = 0;
          let c3 = 0;
          while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            } else if((c > 191) && (c < 224)) {
              c2 = utftext.charCodeAt(i+1);
              string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
              i += 2;
            } else {
              c2 = utftext.charCodeAt(i+1);
              c3 = utftext.charCodeAt(i+2);
              string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
              i += 3;
            }
          }
          return string;
        },
        encode: function(input) {
          let output = "";
          let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
          let i = 0;
          input = this._utf8_encode(input);
          while (i < input.length) {
              chr1 = input.charCodeAt(i++);
              chr2 = input.charCodeAt(i++);
              chr3 = input.charCodeAt(i++);
              enc1 = chr1 >> 2;
              enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
              enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
              enc4 = chr3 & 63;
              if (isNaN(chr2)) {
                  enc3 = enc4 = 64;
              } else if (isNaN(chr3)) {
                  enc4 = 64;
              }
              output = output +
              this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
              this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
          }
          return output;
        },
        decode: function(input) {
          let output = "";
          let chr1, chr2, chr3;
          let enc1, enc2, enc3, enc4;
          let i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          while (i < input.length) {
              enc1 = this._keyStr.indexOf(input.charAt(i++));
              enc2 = this._keyStr.indexOf(input.charAt(i++));
              enc3 = this._keyStr.indexOf(input.charAt(i++));
              enc4 = this._keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 != 64) {
                  output = output + String.fromCharCode(chr2);
              }
              if (enc4 != 64) {
                  output = output + String.fromCharCode(chr3);
              }
          }
          output = this._utf8_decode(output);
          return output;
        }
      }
      // 定义字符串
      var string = 'Hello World!';
      // 加密
      var encodedString = Base64.encode(string);
      console.log(encodedString); // 输出: "SGVsbG8gV29ybGQh"
      // 解密
      var decodedString = Base64.decode(encodedString);
      console.log(decodedString); // 输出: "Hello World!"
  </script>
  ```

### 页面复制文字时自动加版权

1.  参考链接：

    [JS 实现页面复制文字时自动加版权](https://blog.csdn.net/lzuacm/article/details/88197591)

2.  详解：

    利用 chrome 查看网站触发某事件(如 copy)时的代码:

        F12-source-Event Listener Breakpoints-选择事件打勾-触发事件
    
        可以看到csdn使用copyright.js，百度即可，或搜索“js加版权”

    ```js
    $(document).on("copy", function (e) {
      var selected = window.getSelection();
      var selectedText = selected.toString().replace(/\n/g, "<br>");
      var copyFooter =
        "<br>---------------------<br>著作权归作者所有。<br>" +
        "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
        "作者：Bravo Yeung<br> 源地址：" +
        document.location.href +
        "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
      var copyHolder = $("<div>", {
        id: "temp",
        html: selectedText + copyFooter,
        style: { position: "absolute", left: "-99999px" },
      });
      //创建div，内容为选中的文字+附加的内容，位置设为不可见
      $("body").append(copyHolder);
      selected.selectAllChildren(copyHolder[0]); //把指定元素的所有子元素设为选中区域，并取消之前的选中区域
      window.setTimeout(function () {
        copyHolder.remove();
      }, 0);
    });
    ```

    ```js
    var ua = navigator.userAgent.toLowerCase();
    if (window.ActiveXObject) {
      /* 兼容IE */
      document.body.oncopy = function () {
        event.returnValue = false;
        var selectedText = document.selection.createRange().text;
        var pageInfo =
          "<br>---------------------<br>著作权归作者所有。<br>" +
          "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
          "作者：Bravo Yeung<br> 源地址：" +
          document.location.href +
          "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
        clipboardData.setData(
          "Text",
          selectedText.replace(/\n/g, "<br>") + pageInfo
        );
      };
    } else {
      function addCopyRight() {
        var body_element = document.getElementsByTagName("body")[0];
        var selection = window.getSelection();
        var pageInfo =
          "<br>---------------------<br>著作权归作者所有。<br>" +
          "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
          "作者：Bravo Yeung<br> 源地址：" +
          document.location.href +
          "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
        var copyText = selection.toString().replace(/\n/g, "<br>") + pageInfo;
        var newDiv = document.createElement("div");
        newDiv.style.position = "absolute";
        newDiv.style.left = "-99999px";
        body_element.appendChild(newDiv);
        newDiv.innerHTML = copyText;
        selection.selectAllChildren(newDiv);
        window.setTimeout(function () {
          body_element.removeChild(newDiv);
        }, 0);
      }
      document.oncopy = addCopyRight;
    }
    ```

### 文件内容读取

1. 参考链接：

   - [使用 JS 读取本地文本文件](https://www.cnblogs.com/yaotome/p/9002172.html)
   - [JS 前端 new FileReader 获取文件后显示乱码](https://www.jianshu.com/p/a8e57e51520a)
   - [UTF8 GB2312 之间的区别和关系](http://www.divcss5.com/html/h53.shtml)

2. 详解

   需要在 input 手动选择文件，GB2312 编码支持简体中文字，UTF-8 支持简体中文字、繁体中文字、英文、日文、韩文等语言，如出现中文乱码，可切换编码。

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <title>Document</title>
       <script type="text/javascript">
         function upload(input) {
           //支持chrome IE10
           if (window.FileReader) {
             var file = input.files[0];
             filename = file.name.split(".")[0];
             var reader = new FileReader();
             reader.onload = function () {
               console.log(this.result, this);
             };
             reader.readAsText(file, "gb2312");
           }
           //支持IE 7 8 9 10
           else if (typeof window.ActiveXObject != "undefined") {
             var xmlDoc;
             xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
             xmlDoc.async = false;
             xmlDoc.load(input.value);
             console.log(xmlDoc.xml);
           }
           //支持FF
           else if (
             document.implementation &&
             document.implementation.createDocument
           ) {
             var xmlDoc;
             xmlDoc = document.implementation.createDocument("", "", null);
             xmlDoc.async = false;
             xmlDoc.load(input.value);
             console.log(xmlDoc.xml);
           } else {
             alert("error");
           }
         }
       </script>
     </head>
     <body>
       <input type="file" onchange="upload(this)" />
     </body>
   </html>
   ```

### 自动化测试

1. 参考链接：

  - [不想痛失薪资普调和年终奖？试试自动化测试！（基础篇）](https://juejin.im/post/5eeae4f7e51d4574195ed982)

  - [Jest](https://www.jianshu.com/p/c2fef6b2820f)

  - [Jest Docs](https://jestjs.io/docs/en/getting-started)

2. 详解

  - 测试类型

    - 单元测试（Unit Test）

      通常情况下，在公共函数/组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。

    - 集成测试（Integration Test）

      集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。

      集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。

    - UI 测试（UI Test）

      UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。

      端到端测试（E2E Test）则是将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。

  - 适合引入自动化测试的场景

    - 公共库类的开发维护
    - 中长期项目的迭代/重构
    - 引用了不可控的第三方依赖

  - 测试工具

    - 单元测试

      Mocha, Ava, Karma, Jest, Jasmine

    - 集成测试和 UI 测试

      ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils

  - 测试思想

    - TDD：Test-Driven Development（测试驱动开发）

      在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行

    - BDD：Behavior-Driven Development（行为驱动开发）

      使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试

  - Jest使用

    ```js
    // sum.ts
    const sum = (a: number, b: number): number => { 
      return a + b;
    };
    // sum.test.ts
    describe('Should sum function run correctly', () => { 
      test('input: 1, 2 expect: 3', () => {
      // toBe:判断是否严格相等（使用Object .is) 
      expect(sum(1, 2)).toBe(3); // toXXX:匹配器 
      // toEqual:判断值是否相等 
      expect(sum(1, 2)).toEqual(3);
      // toBeDefined:判断是否被定义 
      expect(sum(1, 2)).toBeDefined();
      // toBeUndefined:判断是否未被定义
      expect(sum(1, 2)).not.toBeUndefined(); // not.toXXX:取反
      // toBeTruthy:判断是否为真值（true、非零数字、非空字符串、对象/数组等) 
      expect(sum(1, 2)).toBeTruthy();
      // toBeFalsy:判断是否为假值（false、0、空字符串、undefined/null 等) 
      expect(sum(1, 2)).not.toBeFalsy();
      // toBeG reate「Than:判断数值是否大于期望值 
      expect(sum(1, 2)).toBeGreaterThan(2);
      // toBeLessThan:判断数值是否小于期望值 
      expect(sum(1, 2)).toBeLessThan(4);
      // toBeGreaterThanO「Equal:判断数值是否大于等于期望值 
      expect(sum(1, 2)).toBeGreaterThan0rEqual(3);
      // toBeLessThanOrEqual:判断数值是否小于等于期望值 
      expect(sum(1, 2)).toBeLessThan0rEqual(3);
      expect(n).toBeNull(); //判断是否为null
      expect(value).toBeCloseTo(0.3); // 浮点数判断相等
      expect('Christoph').toMatch(/stop/); //正则表达式判断
      expect(['one','two']).toContain('one'); //包含判断ss
      });
    });
    ```

    ```js
    // showHello.ts
    const showHello: string = 'Hello,aaa';
    // showHello.test.ts
    describe('Should showHello defined correctly', () => { 
      it('expect to match "Hello"', () => { 
        expect(showHello).toMatch(/hello/i);
      });
      it('expect to match "aaa"', () => { 
        expect(showHello).toMatch('aaa');
      });
    });
    ```

    ```js
    // array.ts
    const array: [number] = [1, 2, 3, 4];
    // array.test.ts
    describe('Should array defined correctly',  () => {
      it('expect to contain 1', () => { 
        expect(array).toContain(l);
      });
      it('expect to contain 1', () => { 
        expect(new Set(array)).toContain(l); 
      });
    });
    ```

    ```js
    // compileAndroidCode.ts 
    const compileAndroidCode = Error => { 
      throw new Error('you are using the wrong JDK');
    };
    // compileAndroidCode.test.ts
    test('compiling android goes as expected', () => { 
      expect(compileAndroidCode).toThrow(); 
      expect(compileAndroidCode).toThrow(Error);
      expect(compileAndroidCode).toThrow('you are using the wrong JDK'); 
      expect(compileAndroidCode).toThrow(/JDK/);
    });
    ```

    ```js
    // 回调
    it('done', (done) => { 
      fetch('/example')
      .then((res) => {
        expect(res).toEqual({ code: '200', data: {}, msg: 'success' }); 
        done();
      })
      .catch((err) => { 
        done(err);
      });
    });
    ```

    ```js
    function sayHello(name) { 
      return `Hello ${name}`;
    }
    function say(callback) { 
      callback('aaa');
    }
    it('Test sayHello function run correctly', () => { 
      const mockFunc = jest.fn(sayHello);
      say(mockFunc);
      // toHaveBeenCalled:判断Mock函数是否被调用 
      expect(mockFunc).toHaveBeenCalled();
      // toHaveBeenCalledWith:判断Mock函数被调用时的参数 
      expect (mockFunc) .toHaveBeenCalledWith('aaa');
      say(mockFunc);
      // toHaveBeenCalledTimes:判断Mock函数被调用的次数 
      expect(mockFunc).toHaveBeenCalledTimes(2);
      // toHaveReturned:判断Mock函数是否有返回值 
      expect(mockFunc).toHaveReturned();
      // toHaveReturnedWith:判断Mock函数被调用时的返回值 
      expect (mockFunc) .toHaveReturnedWith('Hello'); 
    });
    ```

    ```js
    it('promise resolve' , () => {
      return fetch('/example').then((res) => { 
        expect(res).toEqual({ code: '200', data: {}, msg: 'success' });
      });
    });
    it('promise reject', () => { 
      expect.assertions(1);//保证1条断言被调用 
      return fetch('/example').catch((error) => { 
        expect(error).toMatch('error');
      });
    });
    it('async/await resolve', async () => { 
      const res = await fetch('/example'); 
      expect(res).toEqual({ code: '200', data: {}, msg: 'success' });
    });
    it('async/await reject', async () => { 
      expect.assertions(1);//保证1条断言被调用 
      try {
        await fetch('/example');
      } catch (err) { 
        expect(err).toMatch('error');
      }
    });
    ```

    ```js
    describe('outer', () => {
      console.log('describe outer-a');
      describe('describe inner 1', () => { 
        console.log('describe inner 1'); 
        test('test'  , () => {
          console.log('test for describe inner 1'); 
          expect(true).toEqual(true);
        });
      });
      console.log('describe outer-b');
      test('test 1', () => {
        console.log('test for describe outer'); 
        expect(true).toEqual(true);
      });
      describe('describe inner 2', () => { 
        console.log('describe inner 2'); 
        test('test for describe inner 2', () => { 
          console.log('test for describe inner 2'); 
          expect(false).toEqual(false);
        });
      });
      console.log('describe outer-c');
    });
    // describe outer-a 
    // describe inner 1 
    // describe outer-b 
    // describe inner 2 
    // describe outer-c 
    // test for describe inner 1 
    // test for describe outer 
    // test for describe inner 2
    ```

    ```js
    //推荐
    it('best method', () => {
      return expect(fetch('./example')).resolves.toEqual({ 
        code: '200', 
        data: {}, 
        msg: 'success'
      });
    });
    it('best method', () => {
      return expect(fetch('./example')).rejects.toMatch('error');
    });
    it('best method', async () => { 
      await expect(fetch('./example')).resolves.toEqual({ 
        code: '200', 
        data: {}, 
        msg: 'success' 
      });
    });
    it('best method', async () => { 
      await expect(fetch('./example')).rejects.toMatch('error');
    });
    ```

    ```js
    // 生 命 周 期 钩 子
    beforeAll(() => console.log('1 - beforeAll')); 
    afterAll(() => console.log('1 - afterAll')); 
    beforeEach(() => console.log('1 - beforeEach')); 
    afterEach(() => console.log('1 - afterEach')); 
    test('', () => console.log('1 - test')); 
    describe('Scoped / Nested block', () =>  {
      beforeAll(() => console.log('2 - beforeAll')); 
      afterEach(() => console.log('2 - afterAll')); 
      beforeEach(() => console.log('2 - beforeEach')); 
      afterEach(() => console.log('2 - afterEach')); 
      test('', () => console.log('2 - test'));
    });
    // 1 - beforeAll 
    // 1 - beforeEach 
    // 1 - test 
    // 1 - afterEach 
    // 2 - beforeAll 
    // 1 - beforeEach 
    // 2 - beforeEach 
    // 2 - test 
    // 2 - afterEach 
    // 1 - afterEach 
    // 2 - afterAll 
    // 1 - afterAll
    ```

### jenkins自动部署

1. 参考链接：

  - [让Jenkins自动布署你的Vue项目](https://mp.weixin.qq.com/s/oiznlZ_4L_0Am2SNOonLDw)
  - [windows上Jenkins安装及其配置](https://www.cnblogs.com/fuxuepan/articles/9525623.html)
  - [jenkins_windows(七)：SVN自动触发项目构建的配置](https://blog.csdn.net/kongsuhongbaby/article/details/100170537)
  - [jenkins自动化部署安装部署（Windows-SVN版）](https://blog.csdn.net/dwn1209/article/details/73189080)
  - [Jenkins](https://www.jenkins.io/)

2. 详解

  1. 安装

    通过msi/exe/yum安装java/git/nginx/jenkins

  2. 配置jenkins

    安装后，默认localhost:8080打开登录页，根据提示找到并输入密码

    安装推荐插件，设置用户名、密码等

    安装插件：Rebuilder、SafeRestart、nodeJs，在“系统管理”-“全局配置”-“NodeJs别名”指定版本

  3. github配置

    jenkins创建一个新任务，关联 GitHub项目地址，选择构建环境并编写shell 命令(参考文章1)

    构建完成后，在“工作空间”多出打包后的dist目录

    到这里已经实现了本地代码提交到github，然后在jenkins上点击构建，可以拉取代码并且打包，下一步实现打包后的dist目录放到目标服务器上。

    系统管理-> 系统设置->Publish over SSH里设置服务器信息，填写完后点击test，出现Success说明配置成功

    在刚才的testJenkins工程中配置构建后操作，选择send build artificial over SSH，在构建中添加压缩dist目录命令

    填完后执行构建。成功后登录我们目标服务器发现test目录下有了要运行的文件，访问域名发现项目可以访问

    接下来实现开发本地push代码到github上后，触发Webhook，jenkins自动执行构建。jenkins安装Generic Webhook Trigger 插件，github添加触发器

    在刚才的testJenkins工程中点击构建触发器中选择Generic Webhook Trigger，填写token

    选择github项目中的Settings->Webhooks>add webhook，配置方式按(参考文章1)，选择在push代码时触发webhook，成功后会在下方出现一个绿色的小勾勾

  4. svn配置

    jenkins中生成用户授权的Token：“系统管理”-“管理用户”-“设置按钮”-“添加新token”-“生成”-保存token
    
    在jenkins项目配置中生成项目授权Token，勾选远程触发，勾选：轮询SCM，日程表为空，表示被post-commit钩子触发执行

    SVN服务端配置webhook：新建触发脚本vbs(参考文章3),svn管理器-选择要触发的仓库-右键Properties-“Hooks”-“Post-commit hook”-输入脚本(参考文章3)-“确定”

### 隐藏滚动条与伪元素控制

1. 参考链接：

  - [JS控制伪元素的方法汇总](https://www.jb51.net/article/81984.htm)
  - [CSS实现隐藏滚动条但是可以滚动](https://blog.csdn.net/qq_36538012/article/details/89200121)

2. 详解

    * CSS实现隐藏滚动条但是可以滚动

      ```css
      body::-webkit-scrollbar {
        display: none;
      }
      ```

    * JS实现隐藏滚动条但是可以滚动(不可撤销)

      ```js
      document.styleSheets[0].insertRule('body::-webkit-scrollbar{display:none}',0)
      //或
      document.styleSheets[0].addRule('body::-webkit-scrollbar','display:none')
      ```

    * JS实现隐藏滚动条但是可以滚动(可撤销)

      ```js
      var style = document.createElement("style");
      document.head.appendChild(style);
      style.sheet.addRule('body::-webkit-scrollbar','display:none');
      //或
      style.sheet.insertRule('body::-webkit-scrollbar{display:none}', 0);

      document.head.removeChild(style);
      ```

### 浏览器识别

1. 参考链接：

  - [js获取谷歌浏览器版本](https://www.cnblogs.com/bldf/p/7054295.html)
  - [区别原生chrome 和以chrome为内核的360浏览器](https://www.cnblogs.com/yiliweichinasoft/p/3794681.html)
  - [五大主流浏览器及四大内核](https://www.jianshu.com/p/f4bf35898719)
  - [如何快速判断IE浏览器的版本？](https://www.jianshu.com/p/64a72962ae75)
  - [浏览器份额及其历史以及内核变迁总结](https://blog.csdn.net/lengye7/article/details/106181547)
  - [总结各大主流浏览器内核](https://blog.csdn.net/shijichang151/article/details/81197174)
  - [Can I use](https://caniuse.com/usage-table)
  - [JS判断IE浏览器版本](https://www.cnblogs.com/huzhuhua/p/10941779.html)
  - [【总结】浏览器 User-Agent 大全](https://blog.csdn.net/u012195214/article/details/78889602)
  - [userAgent大全](https://github.com/fynas/ua)
  - [JS获取常见手机品牌](https://www.jianshu.com/p/fcf9119045c1)
  - [js-获取用户移动端网络类型](https://www.cnblogs.com/liuqingxia/p/10319862.html)
  - [JS使用userAgent判断操作系统和浏览器类型](https://blog.csdn.net/ssrrxx111/article/details/47609471?utm_source=blogxgwz7)
  - [jquery.browser.js](https://cdn.bootcdn.net/ajax/libs/jquery-browser/0.1.0/jquery.browser.js)

2. 详解

  * 写在前面：样例见根目录/userAgent大全

  * userAgent包含的信息

    * 浏览器标识
    * 操作系统标识:Windows/Mac/Linux/SunOS/FreeBSD
    * 加密等级标识
      * N: 表示无安全加密
      * I: 表示弱安全加密
      * U: 表示强安全加密
    * 浏览器语言
    * 渲染引擎:Gecko、WebKit、KHTML、Presto、Trident、Tasman
    * 版本信息
    * 可能有手机品牌
    * 可能有网络状态
    * 可能有语言环境

  * 浏览器userAgent

    更多见根目录/userAgent大全/userAgentData.js
    ```txt
    Chrome：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36

    包含chrome字样，以及有自身浏览器标识，版本号为Chrome/**
    Opera：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 OPR/64.0.3417.54
    Edge：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393
    QQ浏览器："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3869.400"
    猎豹："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER"
    搜狗："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"
    2345："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3947.100 Safari/537.36 2345Explorer/10.9.0.20506"
    世界之窗：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36 TheWorld 7
    遨游："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 Maxthon/5.3.8.2000"
    百度："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 BIDUBrowser/8.7 Safari/537.36"
    UC："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4098.3 Safari/537.36"

    包含chrome字样，没有自身浏览器标识，版本号为Chrome/**
    360："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"

    有Safari，没Chrome，版本号为Version/*
    Safari："Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"

    特征为Trident，版本号为MSIE *
    IE："Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)"

    特征为Gecko和Firefox，版本号为rv:*
    火狐："Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0"
    ```

    ```js
    let browser_match = /(edge)[\/]([\w.]+)/.exec(ua) ||
        /(opr)[\/]([\w.]+)/.exec(ua) ||
        /(qqbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(lbbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(metasr)[ ]([\w.]+)/.exec(ua) ||
        /(2345explorer)[\/]([\w.]+)/.exec(ua) ||
        /(theworld)[ ]([\w.]+)/.exec(ua) ||
        /(maxthon)[\/]([\w.]+)/.exec(ua) ||
        /(bidubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ucbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(micromessenger)[\/]([\w.]+)/.exec(ua) ||
        /(firefox)[\/]([\w.]+)/.exec(ua) ||
        /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(iemobile)[\/]([\w.]+)/.exec(ua) ||
        /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [];

    //browser: browser_match[5] || browser_match[3] || browser_match[1] || "unknown"
    ```

  * 浏览器内核

    ```txt
    IE：Trident内核，又称IE内核
    Edge：IE内核---->Edge内核----->Blink内核
    Firefox：Gecko内核
    Safari：webkit内核
    Opera：Presto内核---->Webkit内核----->Blink内核
    Chrome：Webkit内核---->Blink内核
    Sansung Internet：Webkit内核---->Blink内核 （完全紧跟Chromium）
    UC浏览器：U3内核（实际基于Webkit）
    360浏览器、猎豹浏览器内核：IE+Chrome双内核
    搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）
    百度浏览器、世界之窗内核：IE+Chrome（极速模式）
    2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核
    ```

  * 判断360浏览器

    ```js
    function isChrome360() {
        if( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 ) {
            var desc = navigator.mimeTypes['application/x-shockwave-flash'].description.toLowerCase();
            if( desc.indexOf('adobe') > -1 ) {
                return true;
            }
        }
        return false;
    }
    ```

  * 获取浏览器版本

    谷歌浏览器版本
    ```js
    function getChromeVersion() {
        var arr = navigator.userAgent.split(' ');
        var chromeVersion = '';
        for(var i=0;i < arr.length;i++){
            if(/chrome/i.test(arr[i]))
            chromeVersion = arr[i]
        }
        if(chromeVersion){
            return Number(chromeVersion.split('/')[1].split('.')[0]);
        } else {
            return false;
        }
    }
    ```

    ```js
    let browser_match = /(edge)[\/]([\w.]+)/.exec(ua) ||
        /(opr)[\/]([\w.]+)/.exec(ua) ||
        /(qqbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(lbbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(metasr)[ ]([\w.]+)/.exec(ua) ||
        /(2345explorer)[\/]([\w.]+)/.exec(ua) ||
        /(theworld)[ ]([\w.]+)/.exec(ua) ||
        /(maxthon)[\/]([\w.]+)/.exec(ua) ||
        /(bidubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ucbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(micromessenger)[\/]([\w.]+)/.exec(ua) ||
        /(firefox)[\/]([\w.]+)/.exec(ua) ||
        /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(iemobile)[\/]([\w.]+)/.exec(ua) ||
        /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [];

    //browser_match[4] || browser_match[2] || "0"
    ```

  * 各IE版本支持情况

    ```js
    var ie = (function () {
        if (document.all && !window.XMLHttpRequest) return 6;
        if (document.all && !document.querySelector) return 7;
        if (document.all && !document.addEventListener) return 8;
        if (document.all && !window.atob) return 9;
        if (document.all && document.addEventListener && window.atob) return 10;
        return 11;
    })();
    alert(ie)
    ```

  * 获取操作系统

    ```js
    let os_match = /(windows nt)[ ]([\w.]+)/.exec(ua) ||
        /(windows me)/.exec(ua) ||
        /(windows 98)/.exec(ua) ||
        /(android )([\w.]+)/.exec(ua) ||
        /(linux ppc64)/.exec(ua) ||
        /(linux ppc)/.exec(ua) ||
        /(linux i686)/.exec(ua) ||
        /(linux x86_64)/.exec(ua) ||
        /(ipad).*os ([\w.]+ )/.exec(ua) ||
        /(ipod).*os ([\w.]+ )/.exec(ua) ||
        /(iphone).*os ([\w.]+ )/.exec(ua) ||
        /(ppc mac os x )([\w.]+)/.exec(ua) ||
        /(intel mac os x )([\w.]+)/.exec(ua) ||
        /(freebsd)/.exec(ua) ||
        /(sunos i86pc)/.exec(ua) ||
        /(sunos sun4u)/.exec(ua) ||
        /(windows phone)(\sos)?([\s\w.]+)/.exec(ua) ||
        /(kindle)/.exec(ua) ||
        /(silk)/.exec(ua) ||
        /(cros)/.exec(ua) ||
        /(playbook)/.exec(ua) ||
        /(bb)/.exec(ua) ||
        /(blackberry)/.exec(ua) ||
        [];
    ```

  * 获取网络状态

    ```js
    let net_match = /(nettype)[\/]([\w.]+)/.exec(ua) || [];
    ```

  * 获取语言环境

    ```js
    let language_match = /(language)[\/]([\w.]+)/.exec(ua) ||
        /(zh-cn)/.exec(ua) ||
        /(zh-tw)/.exec(ua) ||
        /(zh-hk)/.exec(ua) ||
        /(en-us)/.exec(ua) ||
        /(\w\w-\w\w)/.exec(ua) ||
        [];
    ```

  * 获取手机型号

    ```js
    let model_match = /(build)[\/]([\w.]+)/.exec(ua) ||
        /(ipad)/.exec(ua) ||
        /(ipod)/.exec(ua) ||
        /(iphone)/.exec(ua) ||
        /(huawei)/.exec(ua) ||
        /(vivo)/.exec(ua) ||
        /(oppo)/.exec(ua) ||
        /(samsung)/.exec(ua) ||
        /(sony)/.exec(ua) ||
        /(nokia)/.exec(ua) ||
        /(htc)/.exec(ua) ||
        /(zte)/.exec(ua) ||
        /(lenovo)/.exec(ua) ||
        [];
    //model: model_match[2] || model_match[0] || "unknown"
    ``` 

### HTML5特性

1. 参考链接：

  - [10个好用的 HTML5 特性](https://juejin.im/post/6881779044505878542#heading-17)

2. 详解

  - details

    向用户提供按需查看详细信息的效果
    ```html
    <details>
      <summary>Click Here to get the user details</summary>
      <table>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>Location</th>
          <th>Job</th>
        </tr>
        <tr>
          <td>1</td>
          <td>Adam</td>
          <td>Huston</td>
          <td>UI/UX</td>
        </tr>
      </table>
    </details>
    ```

  - contenteditable属性

    在元素上设置以使内容可编辑的属性,适用于DIV，P，UL等元素。
    ```html
    <h2> Shoppping List(Content Editable) </h2>
    <ul class="content-editable" contenteditable="true">
        <li> 1. Milk </li>
        <li> 2. Bread </li>
        <li> 3. Honey </li>
    </ul>
    ```

  - mark

    高亮
    ```html
    <p> Did you know, you can <mark>"Highlight something interesting"</mark> just with an HTML tag? </p>
    ```

  - map area

    定义一个图像映射(一个可点击的链接区域)。可点击的区域可以是这些形状中的任何一个，矩形，圆形或多边形区域。如果不指定任何形状，则会考虑整个图像。
    ```html
    <div>
        <img src="circus.jpg" width="500" height="500" alt="Circus" usemap="#circusmap">

        <map name="circusmap">
            <area shape="rect" coords="67,114,207,254" href="elephant.htm">
            <area shape="rect" coords="222,141,318, 256" href="lion.htm">
            <area shape="rect" coords="343,111,455, 267" href="horse.htm">
            <area shape="rect" coords="35,328,143,500" href="clown.htm">
            <area shape="circle" coords="426,409,100" href="clown.htm">
        </map>
    </div>
    ```

  - data-* 属性

    用于存储页面或应用程序专用的自定义数据。 可以在 JavaScript 代码中使用存储的数据来创建更多的用户体验。

    属性名不能包含任何大写字母，并且必须在前缀“data-”之后至少有一个字符

    属性值可以是任何字符串

    ```html
    <h2> Know data attribute </h2>
    <div 
        class="data-attribute" 
        id="data-attr" 
        data-custom-attr="You are just Awesome!"> 
    I have a hidden secret!
    </div>
    ```

  - output 

    表示计算或用户操作的结果
    ```html
    <form oninput="x.value=parseInt(a.value) * parseInt(b.value)">
      <input type="number" id="a" value="0">
              * <input type="number" id="b" value="0">
                    = <output name="x" for="a b"></output>
    </form>
    ```

  - datalist

    包含了一组option元素，这些元素表示其它表单控件可选值,dataList的表现很像是一个select下拉列表，但它只是提示作用，并不限制用户在input输入框里输入什么
    ```html
    <form action="" method="get">
        <label for="fruit">Choose your fruit from the list:</label>
        <input list="fruits" name="fruit" id="fruit">
            <datalist id="fruits">
              <option value="Apple">
              <option value="Orange">
              <option value="Banana">
              <option value="Mango">
              <option value="Avacado">
            </datalist>
        <input type="submit">
    </form>  
    ```

  - input range

    给定一个滑块类型的范围选择器
    ```html
    <form method="post">
        <input 
            type="range" 
            name="range" 
            min="0" 
            max="100" 
            step="1" 
            value=""
            onchange="changeValue(event)"/>
    </form>
    <div class="range">
          <output id="output" name="result">  </output>
    </div>
    ```

  - meter

    用来显示已知范围的标量值或者分数值。
    ```html
    <label for="home">/home/atapas</label>
    <meter id="home" value="4" min="0" max="10">2 out of 10</meter><br>

    <label for="root">/root</label>
    <meter id="root" value="0.6">60%</meter><br>
    ```

  - progress

    进度条
    ```html
    <label for="file">Downloading progress:</label>
    <progress id="file" value="32" max="100"> 32% </progress>
    ```

  - input color

    颜色选择器
    ```html
    <input type="color" onchange="showColor(event)">
    <p id="colorMe">Color Me!</p>
    ```

### 微信扫码登录实现

1. 参考链接：

  - [某跳动面试官：说说微信扫码登录背后的实现原理？](https://juejin.im/post/6881597417637511181)

2. 详解

  1. 打开网页请求二维码
  2. 服务器生成uuid唯一标记和过期时间，存入redis数据库，uuid为key
  3. 服务器调用微信生成二维码接口，需要微信OAuth2.0协议参数(AppID 和 AppSecrect)
  4. 微信校验后返回二维码
  5. 手机已经登录过微信app，存在用户token，app服务器从中可以解密出userId
  6. 手机扫码发送登录请求(二维码信息+token)，app服务器验证app token，通过后app服务器调用网页服务器后端回调接口，传入临时票据code，同时app服务器向app确认信息
  7. app显示登录确认框
  8. 确认后再次发送请求(二维码信息+token+ack)，app服务器得到uuid和userId，redis中保存uuid-userId
  9. 接第6点，网页服务器拿到code，加上AppID和AppSecret请求微信开发平台换取access_token，则可请求获得用户账号数据
  10. 根据微信账号数据，找到注册时的用户的网站数据

### Dom转图片

1. 参考链接：

  - [Dom转图片](https://juejin.im/post/6881947480439652366)
  - [html2canvas github](https://github.com/niklasvh/html2canvas)
  - [html2canvas](http://html2canvas.hertzen.com/configuration/)
  - [dom-to-image github](https://github.com/tsayen/dom-to-image)

2. 详解

  1. html2canvas

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #poster{
                width: 700px; 
                height: 500px;
                background-color: green;
            }
        </style>
        <script type="text/javascript" src="http://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
        <script type="text/javascript">
            function takeScreenshot() {
                const node = document.getElementById('poster')
                html2canvas(node, {
                    useCORS: true,
                    height: node.offsetHeight,
                    width: node.offsetWidth,
                    scrollY: 0,
                    scrollX: 0
                }).then(async (canvas) => {
                    let oImg = new Image();
                    oImg.src = canvas.toDataURL();  // 导出图片
                    document.body.appendChild(oImg);  // 将生成的图片添加到body
                })
            }
        </script>
    </head>
    <body>
        <div id="poster">
            <input type="button" value="截图" onclick="takeScreenshot()">
        </div>
    </body>
    </html>
    ```

    注意事项：

    1. 生成的图片模糊

      导出的图片局部有些图片没有原图那么清晰，因为使用背景图片的原因。解决方法是直接使用标签

    2. 生成出来的图片有白色边框

      在配置项中设置backgroundColor: null

    3. 生成图片不显示

      图片素材出现跨域，在方法上调用时增加两个配置:allowTaint: true,useCORS: true 

      还有一个方法就是，把跨域的图片转为base64。

    4. PNG图片不透明

      用到透明的PNG图片作为背景图，最后生成的图片却并不透明，因为html2canvas生成的canvas背景颜色默认为白色。

      添加一个配置项就好:backgroundColor: 'transparent'

    5. 生成的图片加载闪动效果

      先让生成的图片隐藏，添加图片加载状态，等图片生成好以后再展示。

  2. dom-to-image

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #poster{
                width: 700px; 
                height: 500px;
                background-color: green;
            }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
        <script type="text/javascript">
            function filter (node) {
              return (node.tagName !== 'i');
            }
            function takeScreenshot() {
                const node = document.getElementById('poster')
                domtoimage.toPng(node)
                .then((dataUrl) => {
                    var img = new Image();
                    img.src = dataUrl;
                    document.body.appendChild(img);
                })
                .catch((error) => {
                    console.error('oops, something went wrong!', error);
                });
                //将节点转化为jpg格式的图片
                // domtoimage.toJpeg(node, { quality: 0.95 })
                // .then((dataUrl) => {
                //     var img = new Image();
                //     img.src = dataUrl;
                //     document.body.appendChild(img);
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //将节点转化为svg格式的图片，生成的图片的格式都是base64格式
                // domtoimage.toSvg(node, { filter: filter })
                // .then((dataUrl) => {
                //     var img = new Image();
                //     img.src = dataUrl;
                //     document.body.appendChild(img);
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //将节点转化为二进制格式，这个可以直接将图片下载
                // domtoimage.toBlob(node)
                // .then((blob) => {
                //   window.saveAs(blob, 'poster.png');
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //获取原始像素值，以Uint8Array 数组的形式返回，每4个数组元素表示一个像素点，即rgba值。这个方法也是挺实用的，可以用于WebGL中编写着色器颜色。
                // domtoimage.toPixelData(node)
                // .then((pixels) => {
                //   for (var y = 0; y < node.scrollHeight; ++y) {
                //     for (var x = 0; x < node.scrollWidth; ++x) {
                //       pixelAtXYOffset = (4 * y * node.scrollHeight) + (4 * x);
                //       /* pixelAtXY is a Uint8Array[4] containing RGBA values of the pixel at (x, y) in the range 0..255 */
                //       pixelAtXY = pixels.slice(pixelAtXYOffset, pixelAtXYOffset + 4);
                //     }
                //   }
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
            }
        </script>
    </head>
    <body>
        <div id="poster">
            <input type="button" value="截图" onclick="takeScreenshot()">
        </div>
    </body>
    </html>
    ```

    注意事项：

    1. 用于生成图片的dom元素不能display:none或opacity:0。可以用z-index放到其它元素下面；或者用绝对定位，将其放到某个div容器的可视区之外，然后容器设置overflow:hidden
    2. 用于生成图片的dom元素的父元素们不能display:none
    3. 综合1、2，即用于生成图片的dom元素要本身是可见的，且能计算到尺寸值，但不需要出现在视野中
    4. 页面不能出现隐藏iframe的样式，例如iframe{display:none}
    5. 生成后的图，会自动追加到用于生成的dom元素后面，类名是dom2img-result，如果不想把图片的样子展示给用户，可将其样式设置为opacity:0

### nodejs版本管理

1. 参考链接：

  - [安装nvm之后node不可用，“node”不是内部或外部命令，也不是可运行的程序或批处理文件（ng）](https://www.cnblogs.com/cencenyue/p/10430618.html)
  - [windows npm -g 全局安装的命令找不到](https://blog.csdn.net/jizhuanfan0742/article/details/80910187)

2. 详解

  nvm能够随意切换nodejs版本

  * 下载安装nvm(nvm-setup.zip)：https://github.com/coreybutler/nvm-windows/releases
  * 设置好环境变量，如：D:\nvm,D:\nvm\nodejs，如已安装过nodejs，会提示涵盖此版本
  * nvm v 查看到nvm版本号表示安装成功
  * nvm on 开启nvm
  * nvm use [version] 出现* [version] 表示目前使用版本
  * node -v 查看到node版本号表示成功

  * 命令大全

    * nvm arch [32|64]： 显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。
    * nvm install [version] [arch]：该可以是node.js版本或最新稳定版本latest。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为all以安装32和64位版本。在命令后面添加–insecure，可以绕过远端下载服务器的SSL验证。
    * nvm list [available]：列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为nvm ls [available]。
    * nvm on： 启用node.js版本管理。
    * nvm off： 禁用node.js版本管理(不卸载任何东西)
    * nvm proxy [url]： 设置用于下载的代理。留[url]空白，以查看当前的代理。设置[url]为none删除代理。
    * nvm node_mirror [url]：设置node镜像，默认为https://nodejs.org/dist/.。可以设置为淘宝的镜像https://npm.taobao.org/mirrors/node/
    * nvm npm_mirror [url]：设置npm镜像，默认为https://github.com/npm/npm/archive/。可以设置为淘宝的镜像https://npm.taobao.org/mirrors/npm/
    * nvm uninstall version： 卸载指定版本的nodejs。
    * nvm use [version] [arch]： 切换到使用指定的nodejs版本。可以指定32/64位[arch]。
    * nvm use <arch>：将继续使用所选版本，但根据提供的值切换到32/64位模式
    * nvm root [path]： 设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。
    * nvm version： 显示当前运行的nvm版本，可以简写为nvm v 

  注意：如果原本已经安装过nodejs，此时nodejs文件夹会移入nvm中，导致全局安装依赖后，无法找到命令，并且安装路径为原nodejs路径，因此需要设置npm安装全局依赖路径，并把环境变量设为此路径，才能使命令生效。见参考链接2。

### js监听url变化

1. 参考链接：

  - [如何监听URL的变化？](https://blog.csdn.net/liubangbo/article/details/103272393)

2. 详解

  * 监听hashchange:#改变触发

    ```js
    window.onhashchange=function(event){
      console.log(event);
    }
    //或者
    window.addEventListener('hashchange',function(event){
      console.log(event);
    })
    ```

  * 监听popstate:前进后退触发

    ```js
    window.addEventListener('popstate', function(event) {
        console.log(event);
    })
    ```

  * 自定义事件replaceState和pushState行为的监听:单页面应用url改变能生效

    ```js
    let historyEvent = function(type) {
        let origin = history[type];
        return function() {
            let result = origin.apply(this, arguments);
            let event = new Event(type);
            event.arguments = arguments;
            window.dispatchEvent(event);
            return result;
        };
    };
    history.pushState = historyEvent('pushState');
    history.replaceState = historyEvent('replaceState');

    window.addEventListener('replaceState', function(e) {
      console.log('THEY DID IT AGAIN! replaceState 111111');
    });
    window.addEventListener('pushState', function(e) {
      console.log('THEY DID IT AGAIN! pushState 2222222');
    });
    ```

### html5相关

1. 参考链接：

  - [基础面试题+答案、分类学习整理（良心制作）持续更新](https://juejin.cn/post/6914831351271292936)
  - [html5手机网站需要加的那些meta/link标签，html5 meta全解](https://blog.csdn.net/kongjiea/article/details/17092413)

2. 详解

  1. 对 Html5 的离线储存资源管理和加载

    * 使⽤

      1. ⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性；
      2. 在 cache.manifest ⽂件的编写离线存储的资源
      3. 在离线状态时，操作 window.applicationCache 进⾏需求实现

    * 概念

      在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如 果是第⼀次访问 app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏ 离线存储。

      如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。

  2. 严格模式与混杂模式

    !DOCTYPE声明位于⽂档中的最前⾯，处于 html 标签之前。告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档

    严格模式的排版和 JS 运作模式是 以该浏览器⽀持的最⾼标准运⾏

    在混杂模式中，⻚⾯以宽松的向后兼容的⽅式显示。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

  3. HTML全局属性

    * class :为元素设置类标识
    * data-* : 为元素增加⾃定义属性
    * draggable : 设置元素是否可拖拽
    * id : 元素 id ，⽂档内唯⼀
    * lang : 元素内容的的语⾔
    * style : ⾏内 css 样式
    * title : 元素相关的建议信息

  4. viewport的content属性作用

    ```html
    <meta name="viewport" content="" />
    width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；
    height – viewport 的高度 （范围从 223 到 10,000 ）
    user-scalable [yes | no]是否允许缩放
    initial-scale [数值] 初始化比例（范围从 > 0 到 10）
    minimum-scale [数值] 允许缩放的最小比例
    maximum-scale [数值] 允许缩放的最大比例
    target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性）
         -- dpi_value 一般是70-400//没英寸像素点的个数
         -- device-dpi设备默认像素密度
         -- high-dpi 高像素密度
         -- medium-dpi 中等像素密度
         -- low-dpi 低像素密度
    ```

    怎样处理 移动端 1px 被 渲染成 2px 问题?

    * 局部处理

      mate 标签中的 viewport 属性 ， initial-scale 设置为 1

      rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；

    * 全局处理

      mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5

      rem 按照设计稿标准⾛即可

  5. meta 相关

    ```html
    <!DOCTYPE html> <!--H5标准声明，使⽤ HTML5 doctype，不区分⼤⼩写-->
    <head lang=”en”> <!--标准的 lang 属性写法-->
    <meta charset=’utf-8′> <!--声明⽂档使⽤的字符编码-->
    <!-- 让IE浏览器用最高级内核渲染页面 还有用 Chrome 框架的页面用webkit 内核-->
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> <!--优先使用指定浏览器使用特定的文档模式-->
    <meta name=”description” content=”不超过150个字符”/> <!--⻚⾯描述-->
    <meta name=”keywords” content=””/> <!-- ⻚⾯关键词-->
    <meta name=”author” content=”name, email@gmail.com”/> <!--⽹⻚作者-->
    <meta name=”robots” content=”index,follow”/> <!--搜索引擎抓取-->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin-->
    <meta name=”apple-mobile-web-app-capable” content=”yes”/> <!--添加到主屏后的标 是否启⽤ WebApp 全屏模式，删除苹果默认的⼯具栏和菜单栏-->
    <meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
    <meta name=”renderer” content=”webkit”> <!-- 启⽤360浏览器的极速模式(webkit)-->
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge”> <!--避免IE使⽤兼容模式-->
    <meta http-equiv=”Cache-Control” content=”no-siteapp” /> <!--不让百度转码-->
    <meta name=”HandheldFriendly” content=”true”> <!--针对⼿持设备优化，主要是针对一些老的不识别viewport的浏览器-->
    <meta name=”MobileOptimized” content=”320″> <!--微软的⽼式浏览器-->
    <meta name=”screen-orientation” content=”portrait”> <!--uc强制竖屏-->
    <meta name=”x5-orientation” content=”portrait”> <!--QQ强制竖屏-->
    <meta name=”full-screen” content=”yes”> <!--UC强制全屏-->
    <meta name=”x5-fullscreen” content=”true”> <!--QQ强制全屏-->
    <meta name=”browsermode” content=”application”> <!--UC应⽤模式-->
    <meta name=”x5-page-mode” content=”app”> <!-- QQ应⽤模式-->
    <meta name=”msapplication-tap-highlight” content=”no”> <!--windows phone 设置⻚⾯不缓存-->
    <meta http-equiv=”pragma” content=”no-cache”>
    <meta http-equiv=”cache-control” content=”no-cache”>
    <meta http-equiv=”expires” content=”0″>
    ```

### css解决height:auto动画问题

1. 参考链接：

  - [CSS 奇技淫巧：动态高度过渡动画](https://juejin.cn/post/6917061427958120461)

2. 详解

  height:auto配transition不能产生动画效果，解决方法：

  1. max-height

    ```html
    <style type="text/css">
      div{
        position: relative;
      }
      p{
        width: 100px;
        position: absolute;
        top: 20px;
        left: 0px;
        max-height: 0;
        transition: max-height 0.3s linear;
        overflow: hidden;
      }
      div:hover p{
        max-height: 100px;
      }
    </style>
    <div>
      <h3>hover</h3>
      <p>testtesttesttesttesttesttesttesttesttest</p>
    </div>
    ```

  2. translateY

    ```html
    <style type="text/css">
        div{
          position: relative;
          background-color: #fff;
        }
        h3{
          background-color: #fff;
          margin: 0;
          position: relative;
          z-index: 1;
        }
        p{
          width: 100px;
          position: absolute;
          top: 20px;
          left: 0px;
          transition: all 0.3s linear;
          transform: translateY(-200%);
          height: 0;
          overflow: hidden;
        }
        div:hover p{
          transform: translateY(0);
          height: auto;
        }
      </style>
      <div>
      <h3>hover</h3>
      <p>testtesttesttesttesttesttesttesttesttest</p>
    </div>
    ```

### 在线预览文件

1. 参考链接：

  - [前端实现在线预览pdf、word、xls、ppt等文件](https://juejin.cn/post/6844903561017425927)

2. 详解

  * 免费纯前端方式实现在线预览word、excel、ppt最优选择微软在线预览（不可编辑）

    1. 微软的在线预览功能(必须是公共网络可访问的office文件)

      https://view.officeapps.live.com/op/view.aspx?src=http://www.xdocin.com/demo/demo.docx

    2. google的文档在线预览(需翻墙)

      https://docs.google.com/viewer?url=http://www.xdocin.com/demo/demo.docx

  * 利用后端将文件转为图片，前端以图片形式预览（可行方案）

  * 购买在线预览服务
  
    * [百度DOC文档服务](https://cloud.baidu.com/product/doc.html?track=cp:nsem%7Cpf:pc%7Cpp:doc%7Cpu:long%7Cci:%7Ckw:118945)
    
    * [永中](http://dcs.yozosoft.com/help.html)
    
    * [I DOC VIEW](https://www.idocv.com/docs.html)

    * [XDOC](http://www.xdocin.com/web.html#func)

  * 其它

    * [kkfileview](https://file.keking.cn/)

### 移动端开发指南

1. 参考链接：

  - [中高级前端必须注意的40条移动端H5坑位指南 | 网易三年实践](https://juejin.cn/post/6921886428158754829)

2. 详解

  * 调用系统功能

    ```html
    <a href="tel:10086">拨打电话给10086</a>
    <a href="sms:10086">发送短信给10086</a>
    <a href="mailto:a@aa.com">发送邮件给a@aa.com</a>
    <input type="file" accept="image/*"><!-- 选择指定类型文件 -->
    <input type="file" multiple><!-- 多选文件 -->
    ```

  * 忽略自动识别

    有些移动端浏览器会自动将数字字母符号识别为电话/邮箱并将其渲染成上述调用系统功能里的a

    ```html
    <!-- 忽略自动识别电话 -->
    <meta name="format-detection" content="telephone=no">
    <!-- 忽略自动识别电话和邮箱 -->
    <meta name="format-detection" content="telephone=no, email=no">
    ```

  * 弹出数字键盘

    ```html
    <!-- 纯数字带#和* -->
    <input type="tel">

    <!-- 纯数字 -->
    <input pattern="\d*">
    ```

  * 唤醒原生应用

    通过location.href与原生应用建立通讯渠道，这种页面与客户端的通讯方式称为URL Scheme，其基本格式为scheme://[path][?query]

    * scheme：应用标识，表示应用在系统里的唯一标识
    * path：应用行为，表示应用某个页面或功能
    * query：应用参数，表示应用页面或应用功能所需的条件参数

    URL Scheme一般由前端与客户端共同协商。唤醒原生应用的前提是必须在移动设备里安装了该应用，有些移动端浏览器即使安装了该应用也无法唤醒原生应用，因为它认为URL Scheme是一种潜在的危险行为而禁用它，像Safari和微信浏览器。还好微信浏览器可开启白名单让URL Scheme有效。

    若在页面引用第三方原生应用的URL Schema，可通过抓包第三方原生应用获取其URL。

    ```html
    <!-- 打开微信 -->
    <a href="weixin://">打开微信</a>

    <!-- 打开支付宝 -->
    <a href="alipays://">打开支付宝</a>

    <!-- 打开支付宝的扫一扫 -->
    <a href="alipays://platformapi/startapp?saId=10000007">打开支付宝的扫一扫</a>

    <!-- 打开支付宝的蚂蚁森林 -->
    <a href="alipays://platformapi/startapp?appId=60000002">打开支付宝的蚂蚁森林</a>
    ```

  * 禁止页面缩放

    具体见[html5相关](#html5相关),或css常见问题-flexible与高清屏

    ```html
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1">
    ```

  * 禁止页面缓存

    解析见网络相关问题-强制缓存和协商缓存

    ```html
    <meta http-equiv="Cache-Control" content="no-cache">
    ```

  * 禁止字母大写

    有时在输入框里输入文本会默认开启首字母大写纠正，就是输入首字母小写会被自动纠正成大写，直接声明autocapitalize=off关闭首字母大写功能和autocorrect=off关闭纠正功能。

    ```html
    <input autocapitalize="off" autocorrect="off">
    ```

  * 浏览器配置

    具体见[html5相关](#html5相关)
  
    针对Safari配置

    ```html
    <!-- 设置Safari全屏，在iOS7+无效 -->
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- 改变Safari状态栏样式，可选default/black/black-translucent，需在上述全屏模式下才有效 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black">

    <!-- 添加页面启动占位图 -->
    <link rel="apple-touch-startup-image" href="pig.jpg" media="(device-width: 375px)">

    <!-- 保存网站到桌面时添加图标 -->
    <link rel="apple-touch-icon" sizes="76x76" href="pig.jpg">

    <!-- 保存网站到桌面时添加图标且清除默认光泽 -->
    <link rel="apple-touch-icon-precomposed" href="pig.jpg">
    ```

    针对其他浏览器配置

    ```html
    <!-- 强制QQ浏览器竖屏 -->
    <meta name="x5-orientation" content="portrait">

    <!-- 强制QQ浏览器全屏 -->
    <meta name="x5-fullscreen" content="true">

    <!-- 开启QQ浏览器应用模式 -->
    <meta name="x5-page-mode" content="app">

    <!-- 强制UC浏览器竖屏 -->
    <meta name="screen-orientation" content="portrait">

    <!-- 强制UC浏览器全屏 -->
    <meta name="full-screen" content="yes">

    <!-- 开启UC浏览器应用模式 -->
    <meta name="browsermode" content="application">

    <!-- 开启360浏览器极速模式 -->
    <meta name="renderer" content="webkit">
    ```

  * 让:active有效，让:hover无效

    有些元素的:active可能会无效，而元素的:hover在点击后会一直处于点击状态，需点击其他位置才能解除点击状态。给body注册一个空的touchstart事件可将两种状态反转。

    ```html
    <body ontouchstart></body>
    ```

  * 优化弹性滚动

    在苹果系统上非body元素的滚动操作可能会存在卡顿，但安卓系统不会出现该情况。通过声明overflow-scrolling:touch调用系统原生滚动事件优化弹性滚动，增加页面滚动的流畅度。

    ```css
    body {
        -webkit-overflow-scrolling: touch;
    }
    .elem {
        overflow: auto;
    }
    ```

  * 禁止滚动传播

    移动端浏览器有一个奇怪行为:当页面包含多个滚动区域时，滚完一个区域后若还存在滚动动量则会将这些剩余动量传播到下一个滚动区域，造成该区域也滚动起来。这种行为称为滚动传播。若不想产生这种奇怪行为可直接禁止。

    ```css
    .elem {
        overscroll-behavior: contain;
    }
    ```

  * 禁止屏幕抖动

    对于一些突然出现滚动条的页面，可能会产生左右抖动的不良影响。在一个滚动容器里，打开弹窗就隐藏滚动条，关闭弹窗就显示滚动条，来回操作会让屏幕抖动起来。提前声明滚动容器的padding-right为滚动条宽度，就能有效消除这个不良影响。

    每个移动端浏览器的滚动条宽度都有可能不一致，甚至不一定占位置，通过以下方式能间接计算出滚动条的宽度。100vw为视窗宽度，100%为滚动容器内容宽度，相减就是滚动条宽度，妥妥的动态计算。

    ```css
    body {
        padding-right: calc(100vw - 100%);
    }
    ```

  * 禁止长按操作

    有时不想用户长按元素呼出菜单进行点链接、打电话、发邮件、保存图片或扫描二维码等操作，声明touch-callout:none禁止用户长按操作。

    有时不想用户复制粘贴盗文案，声明user-select:none禁止用户长按操作和选择复制。

    但声明user-select:none会让input和textarea无法输入文本，可对其声明user-select:auto排除在外。

    ```css
    * {
        /* pointer-events: none; */ /* 微信浏览器还需附加该属性才有效 */
        user-select: none; /* 禁止长按选择文字 */
        -webkit-touch-callout: none;
    }
    input,textarea {
        user-select: auto;
    }
    ```

  * 禁止字体调整

    旋转屏幕可能会改变字体大小，声明text-size-adjust:100%让字体大小保持不变。

    ```css
    * {
        text-size-adjust: 100%;
    }
    ```

  * 禁止高亮显示

    触摸元素会出现半透明灰色遮罩

    ```css
    * {
        -webkit-tap-highlight-color: transparent;
    }
    ```

  * 禁止动画闪屏

    在移动设备上添加动画，多数情况会出现闪屏，给动画元素的父元素构造一个3D环境就能让动画稳定运行了。

    ```css
    .elem {
        perspective: 1000;
        backface-visibility: hidden;
        transform-style: preserve-3d;
    }
    ```

  * 美化滚动条

    * ::-webkit-scrollbar：滚动条整体部分
    * ::-webkit-scrollbar-track：滚动条轨道部分
    * ::-webkit-scrollbar-thumb：滚动条滑块部分

    ```css
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
        background-color: transparent;
    }
    ::-webkit-scrollbar-track {
        background-color: transparent;
    }
    ::-webkit-scrollbar-thumb {
        border-radius: 3px;
        background-image: linear-gradient(135deg, #09f, #3c9);
    }
    ```

  * placeholder颜色

    ```css
    input::-webkit-input-placeholder {
        color: #66f;
    }
    ```

  * input文本偏上问题

    桌面端浏览器里声明line-height等于height就能解决，但移动端浏览器里还是未能解决，需将line-height声明为normal才行。

    ```css
    input {
        line-height: normal;
    }
    ```

  * 下拉选项右对齐

    ```css
    select option {
        direction: rtl;
    }
    ```

  * 修复点击无效

    在苹果系统上有些情况下非可点击元素监听click事件可能会无效，针对该情况只需对不触发click事件的元素声明cursor:pointer就能解决。

    ```css
    .elem {
        cursor: pointer;
    }
    ```

  * 文本换行

    若接口返回字段包含\n或br，千万别替换掉，可声明white-space:pre-line交由浏览器做断行处理。

    ```css
    * {
        white-space: pre-line;
    }
    ```

  * 描绘一像素边框

    详见css常见问题-flexible与高清屏

    ```css
    .elem {
        position: relative;
        width: 200px;
        height: 80px;
        &::after {
            position: absolute;
            left: 0;
            top: 0;
            border: 1px solid #f66;
            width: 200%;
            height: 200%;
            content: "";
            transform: scale(.5);
            transform-origin: left top;
        }
    }
    ```

  * 溢出文本省略号

    ```css
    .elem {
        width: 400px;
        line-height: 30px;
        font-size: 20px;
        &.sl-ellipsis {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        &.ml-ellipsis {
            display: -webkit-box;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
    }
    ```

  * 禁止点击穿透

    当用户执行第一次单击后会预留300ms检测用户是否继续执行单击，若是则执行缩放操作，若否则执行点击操作。

    在移动端浏览器上不使用click事件而使用touch事件是因为click事件有着明显的延迟，后续又出现fastclick。该解决方案监听用户是否做了双击操作，所以还是可直接使用click事件，而点击穿透就交给该fastclick自动判断。

    ```js
    import Fastclick from "fastclick";

    FastClick.attach(document.body);
    ```

  * 禁止滑动穿透

    移动端浏览器里出现弹窗时，若在屏幕上滑动能触发弹窗底下的内容跟着滚动。

    禁止body滚动又会引发其它问题：

      * 弹窗打开后内部内容无法滚动
      * 弹窗关闭后页面滚动位置丢失
      * Webview能上下滑动露出底色

    ```css
    body.static {
        position: fixed;
        left: 0;
        width: 100%;
    }
    ```
    ```js
    const body = document.body;
    const openBtn = document.getElementById("open-btn");
    const closeBtn = document.getElementById("close-btn");
    openBtn.addEventListener("click", e => {
        e.stopPropagation();
        const scrollTop = document.scrollingElement.scrollTop;
        body.classList.add("static");
        body.style.top = `-${scrollTop}px`;
    });
    closeBtn.addEventListener("click", e => {
        e.stopPropagation();
        body.classList.remove("static");
        body.style.top = "";
    });
    ```

  * 支持往返刷新

    点击移动端浏览器的前进按钮或后退按钮，有时不会自动执行旧页面的JS代码，这与往返缓存有关。

    往返缓存指浏览器为了在页面间执行前进后退操作时能拥有更流畅体验的一种策略，以下简称BFCache。

    该策略具体表现为：当用户前往新页面前将旧页面的DOM状态保存在BFCache里，当用户返回旧页面前将旧页面的DOM状态从BFCache里取出并加载。大部分移动端浏览器都会部署BFCache，可大大节省接口请求的时间和带宽。

    若在Vue SPA上使用keep-alive也不能让页面刷新，可将接口请求放到beforeRouteEnter()里。

    解决方案1
    ```js
    // 在新页面监听页面销毁事件
    window.addEventListener("onunload", () => {
        // 执行旧页面代码
    });
    ```

    解决方案2:pageshow事件在每次页面加载时都会触发，无论是首次加载还是再次加载都会触发，这就是它与load事件的区别。pageshow事件暴露的persisted可判断页面是否从BFCache里取出。
    ```js
    window.addEventListener("pageshow", e => e.persisted && location.reload());
    ```

  * 解析有效日期

    在苹果系统上解析YYYY-MM-DD HH:mm:ss这种日期格式会报错Invalid Date，但在安卓系统上解析这种日期格式完全无问题。可用YYYY/MM/DD HH:mm:ss这种日期格式

    ```js
    const date = "2019-03-31 21:30:00";
    new Date(date.replace(/\-/g, "-"));
    ```

  * 修复高度坍塌

    出现以下三个条件时,输入框失焦后页面未回弹:
    * 页面高度过小
    * 输入框在页面底部或视窗中下方
    * 输入框聚焦输入文本

    只要保持前后滚动条偏移量一致就不会出现上述问题。在输入框聚焦时获取页面当前滚动条偏移量，在输入框失焦时赋值页面之前获取的滚动条偏移量，这样就能间接还原页面滚动条偏移量解决页面高度坍塌。

    ```js
    const input = document.getElementById("input");
    let scrollTop = 0;
    input.addEventListener("focus", () => {
        scrollTop = document.scrollingElement.scrollTop;
    });
    input.addEventListener("blur", () => {
        document.scrollingElement.scrollTo(0, this.scrollTop);
    });
    ```

  * 修复输入监听

    在苹果系统上的输入框输入文本，keyup/keydown/keypress事件可能会无效。当输入框监听keyup事件时，逐个输入英文和数字会有效，但逐个输入中文不会有效，需按回车键才会有效。此时可用input事件代替输入框的keyup/keydown/keypress事件。

  * 简化回到顶部

    编写一个返回顶部函数需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，一行核心代码就能搞定。

    * scrollIntoView

      * behavior：动画过渡效果，默认auto无，可选smooth平滑
      * inline：水平方向对齐方式，默认nearest就近对齐，可选start顶部对齐、center中间对齐和end底部对齐
      * block：垂直方向对齐方式，默认start顶部对齐，可选center中间对齐、end底部对齐和nearest就近对齐

    ```js
    const gotopBtn = document.getElementById("gotop-btn");
    openBtn.addEventListener("click", () => document.body.scrollIntoView({ behavior: "smooth" }));
    ```

  * 简化懒加载

    编写一个懒性加载函数也同样需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，该函数无需监听容器的scroll事件，通过浏览器自身机制完成滚动监听。

    懒加载
    ```html
    <img data-src="pig.jpg">
    <!-- 很多<img> -->
    ```
    ```js
    const imgs = document.querySelectorAll("img.lazyload");
    const observer = new IntersectionObserver(nodes => {
        nodes.forEach(v => {
            if (v.isIntersecting) { // 判断是否进入可视区域
                v.target.src = v.target.dataset.src; // 赋值加载图片
                observer.unobserve(v.target); // 停止监听已加载的图片
            }
        });
    });
    imgs.forEach(v => observer.observe(v));
    ```

    下拉加载
    ```html
    <ul>
        <li></li>
        <!-- 很多<li> -->
    </ul>
    <!-- 也可将#bottom以<li>的形式插入到<ul>内部的最后位置 -->
    <div id="bottom"></div>
    ```
    ```js
    const bottom = document.getElementById("bottom");
    const observer = new IntersectionObserver(nodes => {
        const tgt = nodes[0]; // 反正只有一个
        if (item.isIntersecting) {
            console.log("已到底部，请求接口");
            // 执行接口请求代码
        }
    })
    bottom.observe(bottom);
    ```

  * 优化扫码识别

    通常移动端浏览器都会配备长按二维码图片识别链接的功能，但长按二维码可能无法识别或错误识别。

    二维码生成方式有以下三种:

      * 使用img渲染
      * 使用svg渲染
      * 使用canvas渲染

    大部分移动端浏览器只能识别img渲染的二维码，若使用SVG和Canvas的方式生成二维码，那就想方设法把二维码数据转换成Base64再赋值到img的src上。

    一个页面可能存在多个二维码，若长按二维码只能识别最后一个，那只能控制每个页面只存在一个二维码。

  * 自动播放媒体

    少部分浏览器autoplay即可

    一般浏览器需js控制
    ```js
    const audio = document.getElementById("audio");
    const video = document.getElementById("video");
    audio.play();
    video.play();
    ```

    微信浏览器需监听其应用SDK加载完成才能触发
    ```js
    document.addEventListener("WeixinJSBridgeReady", () => {
        // 执行上述媒体自动播放代码
    });
    ```

    苹果系统上明确规定用户交互操作开始后才能播放媒体，未得到用户响应会被Safari自动拦截，因此需监听用户首次触摸操作并触发媒体自动播放，而该监听仅此一次。
    ```js
    document.body.addEventListener("touchstart", () => {
        // 执行上述媒体自动播放代码
    }, { once: true });
    ```

### 如何找到当前页面出现次数最多的HTML标签

1. 参考链接：

  - [山月最近的面试总结](https://juejin.cn/post/6922229465468633095)

2. 详解

  * 列出所有标签

    1. document.querySelector('*')，标准规范实现
    2. $$('*')，devtools 实现
    3. document.all，非标准规范实现

  * 实现

    使用 document.querySelectorAll 实现

    ```js
    const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)

    function getFrequentTag () {
      const tags = [...document.querySelectorAll('*')].map(x => x.tagName).reduce((o, tag) => { 
        o[tag] = o[tag] ? o[tag] + 1 : 1;
        return o
      }, {})
      return maxBy(Object.entries(tags), tag => tag[1])
    }
    ```

    DOM 的体积过大会影响页面性能，假如你想在用户关闭页面时统计（计算并反馈给服务器）当前页面中元素节点的数量总和、元素节点的最大嵌套深度以及最大子元素个数，请用 JS 配合原生 DOM API 实现该需求（不用考虑陈旧浏览器以及在现代浏览器中的兼容性，可以使用任意浏览器的最新特性；不用考虑 shadow DOM）。比如在如下页面中运行后：
    ```html
    <html>
      <head></head>
      <body>
        <div>
          <span>f</span>
          <span>o</span>
          <span>o</span>
        </div>
      </body>
    </html>
    ```
    ```json
    {
      totalElementsCount: 7,
      maxDOMTreeDepth: 4,
      maxChildrenCount: 3
    }
    ```

    ```js
    window.onload = function() {
      let outer = document.querySelectorAll('*');
      let totalElementsCount = 0;
      let maxDOMTreeDepth = 0;
      let maxChildrenCount = 0;
      //console.log(outer)
      let elementQueue = [outer[0]];
      let htmlObject = {
        tagName: '',
        deep: 0,
        childrenCount: 0
      };
      let nodeInfo = [];
      let deepInfo = [];
      let childrenCountInfo = [];
      let currentDeep = 1;

      while(elementQueue.length != 0){
        for(let i = 0;i < elementQueue.length;i++){
          let info = JSON.parse(JSON.stringify(htmlObject));
          info.tagName = elementQueue[i].tagName;
          info.deep = currentDeep;
          info.childrenCount = elementQueue[i].childElementCount;
          nodeInfo.push(info);
          deepInfo.push(info.deep);
          childrenCountInfo.push(info.childrenCount);
        }
        //console.log(nodeInfo)
        let newQueue = [];
        for(let i = 0;i < elementQueue.length;i++){
          if(elementQueue[i].hasChildNodes()){
            //console.log(elementQueue[i].children)
            Array.prototype.push.apply(newQueue,elementQueue[i].children);
          }
        }
        //console.log(newQueue)
        elementQueue = newQueue;
        currentDeep++;
      }
      deepInfo = deepInfo.sort((a,b)=>(b-a));
      childrenCountInfo = childrenCountInfo.sort((a,b)=>(b-a));

      totalElementsCount = nodeInfo.length;
      maxDOMTreeDepth = deepInfo[0];
      maxChildrenCount = childrenCountInfo[0];
      console.log({
        totalElementsCount: totalElementsCount,
        maxDOMTreeDepth: maxDOMTreeDepth,
        maxChildrenCount: maxChildrenCount
      })
    }
    ```

### 导入ics日历日程

1. 参考链接：

  - [制作ics日历提醒文件](https://www.jianshu.com/p/237c336f0b7f)

2. 详解

  ```txt
  Calendar文件模板
  SUMMARY：主题，修改称自己想要的即可
  日期：20191112替换成开始日期，20191113提传承结束日期
  UID：如果需要添加多个的话UID一直增加就可以了
  多个时间的就增加从BEGIN:VEVENT到END:VEVENT中间的就可以了
  VALARM可以加也可以不加
  ```

  ```ics
  BEGIN:VCALENDAR
  METHOD:PUBLISH
  VERSION:2.0
  X-WR-CALNAME:个人
  PRODID:-//Apple Inc.//Mac OS X 10.14.5//EN
  X-APPLE-CALENDAR-COLOR:#34AADC
  X-WR-TIMEZONE:Asia/Shanghai
  CALSCALE:GREGORIAN
  BEGIN:VEVENT
  CREATED:20191112T155023Z
  UID:0
  RRULE:FREQ=YEARLY;INTERVAL=1
  DTEND;VALUE=DATE:20191113
  TRANSP:TRANSPARENT
  X-APPLE-TRAVEL-ADVISORY-BEHAVIOR:AUTOMATIC
  SUMMARY:生日
  LAST-MODIFIED:20191112T160624Z
  DTSTAMP:20191112T155045Z
  DTSTART;VALUE=DATE:20191112
  SEQUENCE:0
  BEGIN:VALARM
  X-WR-ALARMUID:4A310C10-E78D-4B17-95F4-005E529D0E7D
  UID:1
  TRIGGER;VALUE=DATE-TIME:19760401T005545Z
  ACTION:NONE
  END:VALARM
  BEGIN:VALARM
  X-WR-ALARMUID:53D56D83-9C94-4F29-9436-93878ACE68A5
  UID:2
  TRIGGER:PT9H
  ATTACH;VALUE=URI:Chord
  ACTION:AUDIO
  END:VALARM
  END:VEVENT
  END:VCALENDAR
  ```

  ```ics
  BEGIN:VCALENDAR
  METHOD:PUBLISH
  VERSION:2.0
  X-WR-CALNAME:2021 消费者权益日发布会。
  PRODID:-//Apple Inc.//Mac OS X 10.14.5//EN
  X-APPLE-CALENDAR-COLOR:#34AADC
  X-WR-TIMEZONE:Asia/Shanghai
  CALSCALE:GREGORIAN
  BEGIN:VEVENT
  CREATED:20210314T155023Z
  UID:0
  DTEND;VALUE=DATE:20210315T110000
  TRANSP:TRANSPARENT
  X-APPLE-TRAVEL-ADVISORY-BEHAVIOR:AUTOMATIC
  LOCATION:微信视频号、抖音、斗鱼、京东、天猫各大平台同步直播
  DESCRIPTION: 观看2021 消费者权益日发布会。
  URL;VALUE=URI:https://xiaofeizhequanyi
  SUMMARY:2021 消费者权益日发布会
  LAST-MODIFIED:20210315T160624Z
  DTSTAMP:20210315T155045Z
  DTSTART;VALUE=DATE:20210315T100000
  SEQUENCE:0
  BEGIN:VALARM
  X-WR-ALARMUID:4A310C10-E78D-4B17-95F4-005E529D0E7D
  UID:1
  TRIGGER;VALUE=DATE-TIME:19760401T005545Z
  ACTION:NONE
  END:VALARM
  BEGIN:VALARM
  X-WR-ALARMUID:53D56D83-9C94-4F29-9436-93878ACE68A5
  UID:2
  TRIGGER:-PT10M
  ATTACH;VALUE=URI:Chord
  ACTION:AUDIO
  END:VALARM
  END:VEVENT
  END:VCALENDAR
  ```

  注意：
  
    * 时区没有Asia/Beijing，但有Asia/Shanghai
    * 安卓手机可能无法删除导入后的日程，因为导入后文件变为只读，可考虑删除导入日程的账号