# 前端实战案例

- [数组模拟dictionary与二重排序](#数组模拟dictionary与二重排序)
- [前端截图上传服务器实现](#前端截图上传服务器实现)
- [日历的实现](#日历的实现)
- [简单实现双向数据绑定mvvm](#简单实现双向数据绑定mvvm)
- [便捷的函数与方法](#便捷的函数与方法)
- [图片懒加载](#图片懒加载)
- [正则获取URL参数](#正则获取URL参数)
- [js操作cookie](#js操作cookie)
- [文件切片上传](#文件切片上传)
- [大文件切片并行下载](#大文件切片并行下载)
- [长列表优化](#长列表优化)
- [活动倒计时](#活动倒计时)
- [数据埋点与错误监控](#数据埋点与错误监控)
- [npm版本号的区别](npm版本号的区别)
- [摄像头抓拍与RTC音视频会议](#摄像头抓拍与RTC音视频会议)
- [js加解密哈希编码](#js加解密哈希编码)
- [页面复制文字时自动加版权](#页面复制文字时自动加版权)
- [文件内容读取](#文件内容读取)
- [自动化测试](#自动化测试)
- [jenkins自动部署](#jenkins自动部署)
- [GitHubActions自动部署](#GitHubActions自动部署)
- [隐藏滚动条与伪元素控制](#隐藏滚动条与伪元素控制)
- [浏览器识别](浏览器识别)
- [HTML5特性](HTML5特性)
- [微信扫码登录实现](#微信扫码登录实现)
- [Dom转图片](#Dom转图片)
- [nodejs版本管理](#nodejs版本管理)
- [js监听url变化](#js监听url变化)
- [html5相关](#html5相关)
- [css解决height:auto动画问题](#css解决height:auto动画问题)
- [在线预览文件](#在线预览文件)
- [移动端开发指南](#移动端开发指南)
- [如何找到当前页面出现次数最多的HTML标签](#如何找到当前页面出现次数最多的HTML标签)
- [导入ics日历日程](#导入ics日历日程)
- [流程可视化](#流程可视化)
- [基准URL与刷新重定向](#基准URL与刷新重定向)
- [阿里云直播](#阿里云直播)
- [生成指定范围不重复随机数最快捷方法](#生成指定范围不重复随机数最快捷方法)
- [Svelte](#Svelte)
- [全景图VR漫游](#全景图VR漫游)
- [前端代码规范](#前端代码规范)
- [前端提交规范](#前端提交规范)
- [页面崩溃通信](#页面崩溃通信)
- [报表可视化](#报表可视化)
- [WebGIS](#WebGIS)
- [脚手架搭建](#脚手架搭建)
- [禁用外链](#禁用外链)
- [禁用控制台](#禁用控制台)
- [pdf预览](#pdf预览)
- [web打印](#web打印)

---

### 数组模拟dictionary与二重排序

1. 参考链接：

   [js 字典排序](https://blog.csdn.net/juyuyh/article/details/89948380)
   [JS sort()排序及 JS sort()双重排序](https://blog.csdn.net/qq416761940/article/details/79632018)
   [前 K 个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/submissions/)

2. 详解：

   - 关于 sort

     - sort([function(a,b){return ±num}])

     - 不传 function 则按照字典序升序排序，传 function 则按数字大小排序，负数为升序排序，正数为降序排序

       - 注意：
       
          上面的字典序指按 unicode 编码序，若要按拼音序，需要 str.sort (function(a,b){return a.localeCompare(b)})

          如果需要对象属性按拼音排序，可先用Object.keys，把key排序好，再赋值到新对象

     - sort 按照字典序降序排序方法，通过比较 if(a>b)，返回正数还是负数，控制排序顺序

     - 多重排序也可通过 if 判断，返回正负数控制排序顺序，其中 if 里面的参数可以与原数组 array1 无关，如 array2[a]>array2[b]

   - 样例

     统计词频，按照词频降序排序，词频相同按照字典序升序排序

     ```js
     let words = [
       "plpaboutit",
       "jnoqzdute",
       "sfvkdqf",
       "mjc",
       "nkpllqzjzp",
       "foqqenbey",
       "ssnanizsav",
       "nkpllqzjzp",
       "sfvkdqf",
       "isnjmy",
       "pnqsz",
       "hhqpvvt",
       "fvvdtpnzx",
       "jkqonvenhx",
       "cyxwlef",
       "hhqpvvt",
       "fvvdtpnzx",
       "plpaboutit",
       "sfvkdqf",
       "mjc",
       "fvvdtpnzx",
       "bwumsj",
       "foqqenbey",
       "isnjmy",
       "nkpllqzjzp",
       "hhqpvvt",
       "foqqenbey",
       "fvvdtpnzx",
       "bwumsj",
       "hhqpvvt",
       "fvvdtpnzx",
       "jkqonvenhx",
       "jnoqzdute",
       "foqqenbey",
       "jnoqzdute",
       "foqqenbey",
       "hhqpvvt",
       "ssnanizsav",
       "mjc",
       "foqqenbey",
       "bwumsj",
       "ssnanizsav",
       "fvvdtpnzx",
       "nkpllqzjzp",
       "jkqonvenhx",
       "hhqpvvt",
       "mjc",
       "isnjmy",
       "bwumsj",
       "pnqsz",
       "hhqpvvt",
       "nkpllqzjzp",
       "jnoqzdute",
       "pnqsz",
       "nkpllqzjzp",
       "jnoqzdute",
       "foqqenbey",
       "nkpllqzjzp",
       "hhqpvvt",
       "fvvdtpnzx",
       "plpaboutit",
       "jnoqzdute",
       "sfvkdqf",
       "fvvdtpnzx",
       "jkqonvenhx",
       "jnoqzdute",
       "nkpllqzjzp",
       "jnoqzdute",
       "fvvdtpnzx",
       "jkqonvenhx",
       "hhqpvvt",
       "isnjmy",
       "jkqonvenhx",
       "ssnanizsav",
       "jnoqzdute",
       "jkqonvenhx",
       "fvvdtpnzx",
       "hhqpvvt",
       "bwumsj",
       "nkpllqzjzp",
       "bwumsj",
       "jkqonvenhx",
       "jnoqzdute",
       "pnqsz",
       "foqqenbey",
       "sfvkdqf",
       "sfvkdqf",
     ];
     let dictionary = new Array();
     for (let i = 0; i < words.length; i++) {
       if (!dictionary[words[i]]) {
         dictionary[words[i]] = 1;
       } else {
         dictionary[words[i]]++;
       }
     }
     let result = Object.keys(dictionary).sort((a, b) => {
       if (dictionary[a] == dictionary[b]) {
         if (a > b) {
           return 1;
         } else {
           return -1;
         }
       }
       return dictionary[b] - dictionary[a];
     });
     for (let value of result) {
       console.log(value, dictionary[value]);
     }
     ```


### 前端截图上传服务器实现

1. 参考链接：

   [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

2. 详解：

   - canvas 思路:(html2canvas)

   ```txt
   将dom转换成canvas图片。

   递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

   通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

   遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

   将画好的canvas填充进页面
   ```

   优缺点:复杂度高，稳定性强。

   - svg 思路:(rasterizeHTML.js)

   ```txt
   svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
   通过一系列的hack技巧替我们绕过了许多限制:
   1.将<img/>的url 转为 dataURI
   2.将background-color从style中取出，修改url后重新插入样式表
   3.将link的的样式通过ajax down下来然后注入<style></sytle>
   ```

   优缺点:简单，只能对已经存在的静态资源进行处理，而对 js 动态生成并不能实时处理。

   - 上传

   ```js
   var fd = new FormData();
   fd.append("img", imgBlob);
   $.ajax({
     type: "POST",
     url: "http://tmpfile.coding.io/img",
     dataType: "json",
     data: fd,
     crossDomain: true,
     processData: false,
     contentType: false,
     success: function (data) {
       if (data && data.path) {
         console.log("http://tmpfile.coding.io/tmp" + data.path);
       }
     },
   });
   ```

### 日历的实现

1. 参考链接：

   [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

2. 详解：

   - new Date()

     用法：

     - new Date();
     - new Date(value);
     - new Date(dateString);
     - new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);

     new Date(this.selectedYear,this.selectedMonth,0)会获得当月最后一天的日期

   - set 方法

   凡是 set 方法，传入数超出合理范围，会自动转为毫秒处理，再使用 get 获取信息，因此日月的加减不需要处理进位和退位问题。

   - 6\*7 的日历显示

     - 新开长度为 42 的数组

     - 因为第一行一定会出现本月的数字，于是 getDay 计算本月 1 号时星期几，确定 1 号位于数组的位置

     - 从 1 号开始填充本月进数组

     - 通过日期加减，把数组剩余位置填满

     - 设置 ul 宽度，使 li 每 7 格换一次行

   ```js
   // 根据给定日期算出星期
   getDay(date){
       return new Date(date).getDay();
   }

   // 获取某月的天数
   getMonthNumber(){
       let d = new Date(this.selectedYear,this.selectedMonth,0);
       let num = d.getDate();
       return num;
   }

   // 获取某一天的昨天和明天
   // date 代表指定的日期，格式：2018-09-27
   // day 传-1表始前一天，传1表始后一天
   getNextDate(date,day) {
       var dd = new Date(date);
       dd.setDate(dd.getDate() + day);
       var y = dd.getFullYear();
       var m = dd.getMonth() + 1 < 10 ? "0" + (dd.getMonth() + 1) : dd.getMonth() + 1;
       var d = dd.getDate() < 10 ? "0" + dd.getDate() : dd.getDate();
       return y + "-" + m + "-" + d;
   }

   // 获取日历中某一天的昨天和明天的数字
   getNextDayNumber(date,day){
       var dd = new Date(date);
       dd.setDate(dd.getDate() + day);
       var d = dd.getDate();
       return d;
   }
   ```



### 简单实现双向数据绑定mvvm

1. 参考链接：

   [一年半经验，百度，有赞，阿里前端面试总结](https://zhuanlan.zhihu.com/p/83803079)

2. 详解：

   ```js
   <input id="input" />;
   const data = {};
   const input = document.getElementById("input");
   Object.defineProperty(data, "text", {
     set(value) {
       input.value = value;
       this.value = value;
     },
   });
   input.onchange = function (e) {
     data.text = e.target.value;
   };
   ```


### 便捷的函数与方法

1. 参考链接：

   - [前端常见 20 道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

   - [Javascript 实现嵌套数组扁平化](https://www.cnblogs.com/codejoker/p/10370262.html)

   - [前端面试大厂手写源码系列（上）](https://juejin.im/post/5e77888ff265da57187c7278#heading-16)

   - [十道大厂面试题(含答案)总结](https://mp.weixin.qq.com/s/o553cr1FHLz40PpxbO8oOw)

   - [js 对象的扁平化与反扁平化](https://www.cnblogs.com/mengff/p/7097011.html)

   - [11 个 JavaScript 小技巧](https://mp.weixin.qq.com/s/qBuTTXzt7ZNFttXwu5ryMw)

   - [js 去除数组中的空值,假值](https://blog.csdn.net/zzwwjjdj1/article/details/78642552)

   - [js 用 Set 实现并集（Union）、交集（Intersect）和差集（Difference）](https://blog.csdn.net/mhbsoft/article/details/81487826)

   - [JS 的对象数组去重处理(二十)](https://blog.csdn.net/yjltx1234csdn/article/details/93766707)

   - [JavaScript 工具函数大全（持续更新）](https://github.com/Wscats/CV/issues/27)

   - [【适合收藏】为了多点时间陪女朋友，我向BAT大佬跪求了这15条JS技巧](https://juejin.im/post/5f15444df265da22c9671b03)

   - [js实现trim方法](https://www.cnblogs.com/wayowe/p/7779555.html)

   - [实现一个数组（包含对象等类型元素）去重函数](https://mp.weixin.qq.com/s/UAnAMDMt2dAsYMFXYn5G9Q)

2. 详解

   - 嵌套数组扁平化

     es6 flat(扁平层数)

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]];
     testArr.flat(Infinity);
     ```

     toString

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]]
     [...testArr.toString().split(',')]
     ```

     join/split/map

     ```js
     var testArr = [10, 2, [3, 4, [5, [55]]]];
     testArr.toString().split(",").map(Number);
     testArr.join().split(",").map(Number);
     ```

     包含非数字类型

     ```js
     const flattern = (arr) => {
       const result = [];
       arr.forEach((item) => {
         if (Array.isArray(item)) {
           result.push(...flattern(item));
         } else {
           result.push(item);
         }
       });
       return result;
     };
     ```

   - 嵌套对象的扁平化和反扁平化

     扁平化输入

     ```js
     var obj = {
       a: {
         b: {
           c: {
             d: 1,
           },
         },
       },
       aa: 2,
       c: [1, 2],
     };
     ```

     输出

     ```js
     { 'a.b.c.d': 1, 'aa': 2, 'c[0]': 1, 'c[1]': 2 }
     ```

     扁平化 1

     ```js
     let str = "";
     let o = {};
     function objFlatten(obj) {
       Object.keys(obj).map((item) => {
         if (Object.prototype.toString.call(obj[item]) === "[object Object]") {
           //如果是对象，记录"item1.item2.",不断递归
           str += item + ".";
           objFlatten(obj[item]);
         } else if (
           Object.prototype.toString.call(obj[item]) === "[object Array]"
         ) {
           //如果是数组，向对象循环添加属性，o.c[0]，o.c[1]
           obj[item].forEach((ele, index) => (o[item + `[${index}]`] = ele));
         } else {
           //如果是基础类型,加入最后的item变为"item1.item2.item3",向o添加str记录的属性并赋值，清空str
           str += item;
           o[str] = obj[item];
           str = "";
         }
       });
     }
     ```

     扁平化 2

     ```js
     Object.flatten = function (obj) {
       var result = {};

       function recurse(src, prop) {
         var toString = Object.prototype.toString;
         if (toString.call(src) == "[object Object]") {
           var isEmpty = true;
           for (var p in src) {
             isEmpty = false;
             recurse(src[p], prop ? prop + "." + p : p);
           }
           if (isEmpty && prop) {
             result[prop] = {};
           }
         } else if (toString.call(src) == "[object Array]") {
           var len = src.length;
           if (len > 0) {
             src.forEach(function (item, index) {
               recurse(item, prop ? prop + ".[" + index + "]" : index);
             });
           } else {
             result[prop] = [];
           }
         } else {
           result[prop] = src;
         }
       }
       recurse(obj, "");

       return result;
     };
     ```

     反扁平化 1

     ```js
     Object.unflatten = function (data) {
       if (Object(data) !== data || Array.isArray(data)) return data;
       var regex = /\.?([^.\[\]]+)|\[(\d+)\]/g,
         resultholder = {};
       for (var p in data) {
         var cur = resultholder,
           prop = "",
           m;
         while ((m = regex.exec(p))) {
           cur = cur[prop] || (cur[prop] = m[2] ? [] : {});
           prop = m[2] || m[1];
         }
         cur[prop] = data[p];
       }
       return resultholder[""] || resultholder;
     };
     ```

     反扁平化 2

     ```js
     Object.unflatten2 = function (data) {
       if (Object(data) !== data || Array.isArray(data)) return data;
       var result = {},
         cur,
         prop,
         idx,
         last,
         temp;
       for (var p in data) {
         (cur = result), (prop = ""), (last = 0);
         do {
           idx = p.indexOf(".", last);
           temp = p.substring(last, idx !== -1 ? idx : undefined);
           cur = cur[prop] || (cur[prop] = !isNaN(parseInt(temp)) ? [] : {});
           prop = temp;
           last = idx + 1;
         } while (idx >= 0);
         cur[prop] = data[p];
       }
       return result[""];
     };
     ```

   - 数组去重

     set

     ```js
     var testArr = [1,2,2,3,4,4]
     [... new Set(testArr)]
     ```

     处理对象

     ```js
     let arr1 = [
       { id: 1, name: "汤小梦" },
       { id: 2, name: "石小明" },
       { id: 3, name: "前端开发" },
       { id: 1, name: "web前端" },
     ];
     const unique = (arr, key) => {
       return [...new Map(arr.map((item) => [item[key], item])).values()];
     };
     console.log(unique(arr1, "id"));
     ```

   - 合并数组

     es5

     ```js
     let arr5 = arr3.concat(arr4);
     ```

     es6

     ```js
     let arr6 = [...arr3, ...arr4];
     ```

   - 是否为数组

     instanceof

     ```js
     console.log(arr instanceof Array);
     ```

     constructor

     ```js
     console.log(arr.constructor === Array);
     ```

     是否数组的方法

     ```js
     console.log(!!arr.push && !!arr.concat);
     ```

     toString

     ```js
     console.log(Object.prototype.toString.call(arr) === "[object Array]");
     ```

     isArray

     ```js
     console.log(Array.isArray(arr));
     ```

   - 交换两个数

     ```js
     a = a + b;
     b = a - b;
     a = a - b;
     //或
     a = a ^ b;
     b = a ^ b;
     a = a ^ b;
     ```

   - 快速浮点数转整数

     ```js
     console.log(23.9 | 0); // Result: 23
     console.log(-23.9 | 0); // Result: -23
     ```

   - 删除最后一个数字

     ```js
     let str = "1553";
     Number(str.substring(0, str.length - 1));

     console.log((1553 / 10) | 0); // Result: 155
     console.log((1553 / 100) | 0); // Result: 15
     console.log((1553 / 1000) | 0); // Result: 1
     ```

   - 去除数组中的空值,假值

     ```js
     var u = [undefined, undefined, 1, "", "false", false, true, null, "null"];
     u.filter((d) => d);
     ```

   - Set 实现并集（Union）、交集（Intersect）和差集（Difference）

     ```js
     let a = new Set([1, 2, 3]);
     let b = new Set([4, 3, 2]);

     // 并集
     let union = new Set([...a, ...b]);
     // Set {1, 2, 3, 4}

     // 交集
     let intersect = new Set([...a].filter((x) => b.has(x))); //ES6
     var intersect = new Set(
       [...a].filter(function (x) {
         return b.has(x);
       })
     );
     // set {2, 3}

     // 差集
     let difference = new Set([...a].filter((x) => !b.has(x)));
     // Set {1}
     ```

   - 对象数组去重

     ```js
     let arr = [
       { a: 1, b: 2 },
       { b: 2, a: 1 },
       { a: 2, b: 2 },
       { a: "1", b: "2" },
     ];
     let sortObjectByKeys = (obj) => {
       let keys = Object.keys(obj).sort();
       let newObj = {};
       keys.forEach((value, index, array) => {
         newObj[value] = obj[value];
       });
       return newObj;
     };
     let uniqueObjectArray = (arr) => {
       let set = new Set();
       arr.forEach((value, index, array) => {
         let newValue = sortObjectByKeys(value);
         set.add(JSON.stringify(newValue));
       });
       let newArr = [...set];
       newArr.forEach((value, index, array) => {
         newArr[index] = JSON.parse(value);
       });
       return newArr;
     };
     console.log(uniqueObjectArray(arr));
     ```

   - 平滑滚动到页面顶部

     ```js
     function scrollToTop() {
       var c = document.documentElement.scrollTop || document.body.scrollTop;

       if (c > 0) {
         window.requestAnimationFrame(scrollToTop);
         window.scrollTo(0, c - c / 8);
       }
     }
     ```

   - 日期格式转换

     ```js
     Date.prototype.format = function (formatStr) {
       var str = formatStr;
       var Week = ["日", "一", "二", "三", "四", "五", "六"];
       str = str.replace(/yyyy|YYYY/, this.getFullYear());
       str = str.replace(
         /yy|YY/,
         this.getYear() % 100 > 9
           ? (this.getYear() % 100).toString()
           : "0" + (this.getYear() % 100)
       );
       str = str.replace(
         /MM/,
         this.getMonth() + 1 > 9
           ? (this.getMonth() + 1).toString()
           : "0" + (this.getMonth() + 1)
       );
       str = str.replace(/M/g, this.getMonth() + 1);
       str = str.replace(/w|W/g, Week[this.getDay()]);
       str = str.replace(
         /dd|DD/,
         this.getDate() > 9 ? this.getDate().toString() : "0" + this.getDate()
       );
       str = str.replace(/d|D/g, this.getDate());
       str = str.replace(
         /hh|HH/,
         this.getHours() > 9
           ? this.getHours().toString()
           : "0" + this.getHours()
       );
       str = str.replace(/h|H/g, this.getHours());
       str = str.replace(
         /mm/,
         this.getMinutes() > 9
           ? this.getMinutes().toString()
           : "0" + this.getMinutes()
       );
       str = str.replace(/m/g, this.getMinutes());
       str = str.replace(
         /ss|SS/,
         this.getSeconds() > 9
           ? this.getSeconds().toString()
           : "0" + this.getSeconds()
       );
       str = str.replace(/s|S/g, this.getSeconds());
       return str;
     };

     // 或
     Date.prototype.format = function (format) {
       var o = {
         "M+": this.getMonth() + 1, //month
         "d+": this.getDate(), //day
         "h+": this.getHours(), //hour
         "m+": this.getMinutes(), //minute
         "s+": this.getSeconds(), //second
         "q+": Math.floor((this.getMonth() + 3) / 3), //quarter
         S: this.getMilliseconds(), //millisecond
       };
       if (/(y+)/.test(format))
         format = format.replace(
           RegExp.$1,
           (this.getFullYear() + "").substr(4 - RegExp.$1.length)
         );
       for (var k in o) {
         if (new RegExp("(" + k + ")").test(format))
           format = format.replace(
             RegExp.$1,
             RegExp.$1.length == 1
               ? o[k]
               : ("00" + o[k]).substr(("" + o[k]).length)
           );
       }
       return format;
     };

     alert(new Date().format("yyyy-MM-dd hh:mm:ss"));
     ```

   - 返回日期数列里与目标数列最近的日期下标

      ```js
      const getNearestDateIndex = (targetDate, dates) => {
          if (!targetDate || !dates) {
              throw new Error('Argument(s) is illegal !')
          }
          if (!dates.length) {
              return -1
          }
          const distances = dates.map(date => Math.abs(date - targetDate))
          return distances.indexOf(Math.min(...distances))
      }

      // e.g.
      const targetDate = new Date(2019, 7, 20)
      const dates = [
        new Date(2018, 0, 1),
        new Date(2019, 0, 1),
        new Date(2020, 0, 1),
      ]
      getNearestDateIndex(targetDate, dates) // 2
      ```

   - 返回日期数列里最小的日期

      ```js
      const getMinDate = dates => {
          if (!dates) {
              throw new Error('Argument(s) is illegal !')
          }
          if (!dates.length) {
              return dates
        }
          return new Date(Math.min.apply(null, dates)).toISOString()
      }

      // e.g.
      const dates = [
        new Date(2018, 3, 10),
        new Date(2019, 3, 10),
        new Date(2020, 3, 10),
      ]
      getMinDate(dates) // 2018-04-09T16:00:00.000Z
      ```

   - 打乱数组

      ```js
      const arrayShuffle = array => {
          if (!Array.isArray(array)) {
              throw new Error('Argument must be an array')
        }
          let end = array.length
          if (!end) {
              return array
          }
          while (end) {
              let start = Math.floor(Math.random() * end--);
              [array[start], array[end]] = [array[end], array[start]]
          }
          return array
      }

      // e.g.
      arrayShuffle([1, 2, 3])
      ```

   - 判断是否支持webp图片格式

      ```js
      const canUseWebp = () => (document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0)

      // e.g.
      canUseWebp() // 新版的chrome里为true，火狐里为false
      ```

   - 连字符与驼峰互转

      ```js
      const toCamelCase = (str = '', separator = '-') => {
          if (typeof str !== 'string') {
              throw new Error('Argument must be a string')
          }
          if (str === '') {
              return str
          }
          const newExp = new RegExp('\\-\(\\w\)', 'g')
          return str.replace(newExp, (matched, $1) => {
              return $1.toUpperCase()
          })
      }

      // e.g.
      toCamelCase('hello-world') // helloWorld

      const fromCamelCase = (str = '', separator = '-') => {
          if (typeof str !== 'string') {
              throw new Error('Argument must be a string')
          }
          if (str === '') {
              return str
          }
          return str.replace(/([A-Z])/g, `${separator}$1`).toLowerCase()
      }

      // e.g.
      fromCamelCase('helloWorld') // hello-world
      ```

   - 等级判断

      ```js
      const getLevel = (value = 0, ratio = 50, levels = '一二三四五') => {
          if (typeof value !== 'number') {
              throw new Error('Argument must be a number')
          }
          const levelHash = '一二三四五'.split('')
        const max = levelHash[levelHash.length - 1]
        return levelHash[Math.floor(value / ratio)] || max
      }

      // e.g.
      getLevel(0) // 一
      getLevel(40) // 一
      getLevel(77) // 二
      ```

   - 判断dom是否相等

      ```js
      const isEqualNode = (dom1, dom2) => dom1.isEqualNode(dom2)
      ```

   - 文件尺寸格式化

      ```js
      const formatSize = size => {
          if (typeof +size !== 'number') {
              throw new Error('Argument(s) is illegal !')
        }
          const unitsHash = 'B,KB,MB,GB'.split(',')
          let index = 0
          while (size > 1024 && index < unitsHash.length) {
              size /= 1024
              index++
          }
          return Math.round(size * 100) / 100 + unitsHash[index]
      }
      formatSize('10240') // 10KB
      formatSize('10240000') // 9.77MB
      ```

   - trim与其它去空格方法

      ```js
      String.prototype.trim = function(){
          return this.replace(/^(\s*)|(\s*)$/g, '');
      }
      '  a aaa bbb  b  c cc  ccc   '.replace(/(\S)\s+(\b)/g,'$1$2'); // "  aaaabbbbcccccc   "
      ```

   - 复杂类型数组去重

      1. 如传入的数组元素为 [123, "meili", "123", "mogu", 123] ，则输出： [123, "meili", "123", "mogu"]
      2. 如传入的数组元素为 [123, [1, 2, 3], [1, "2", 3], [1, 2, 3], "meili"] ，则输出： [123, [1, 2, 3], [1, "2", 3], "meili"]
      3. 如传入的数组元素为 [123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili"] ，则输出： [123, {a: 1}, {a: {b: 1}}, {a: "1"}, "meili"]
      4. 如传入的数组元素为 [{a:1, b:2}, {b:2, a:1}] ，则输出： [{a: 1, b: 2}]

      * 解决思路：

      一个数组（包含对象等类型元素）去重函数，需要在基础类型判断相等条件下满足以下条件：

      如果元素是数组类型，则需要数组中的每一项相等
      如果元素是对象类型，则需要对象中的每个键值对相等
      去重本身就是遍历数组，然后比较数组中的每一项是否相等而已，所以关键步骤有两步：比较、去重

      * 比较：

      首先判断类型是否一致，类型不一致则返回认为两个数组元素是不同的，否则继续
      如果是数组类型，则递归比较数组中的每个元素是否相等
      如果是对象类型，则递归比较对象中的每个键值对是否相等
      否则，直接 === 比较
      
      * 去重：

      采用 reduce 去重，初始 accumulator 为 []
      采用 findIndex 找到 accumulator 是否包含相同元素，如果不包含则加入，否则不加入
      返回最终的 accumulator ，则为去重后的数组

      ```js
      // 获取类型
      const getType = (function() {
          const class2type = { '[object Boolean]': 'boolean', '[object Number]': 'number', '[object String]': 'string', '[object Function]': 'function', '[object Array]': 'array', '[object Date]': 'date', '[object RegExp]': 'regexp', '[object Object]': 'object', '[object Error]': 'error', '[object Symbol]': 'symbol' }

          return function getType(obj) {
              if (obj == null) {
                  return obj + ''
              }
              // javascript高级程序设计中提供了一种方法,可以通用的来判断原始数据类型和引用数据类型
              const str = Object.prototype.toString.call(obj)
              return typeof obj === 'object' || typeof obj === 'function' ? class2type[str] || 'object' : typeof obj
          };
      })();

      /**
      * 判断两个元素是否相等
      * @param {any} o1 比较元素
      * @param {any} o2 其他元素
      * @returns {Boolean} 是否相等
      */
      const isEqual = (o1, o2) => {
          const t1 = getType(o1)
          const t2 = getType(o2)

          // 比较类型是否一致
          if (t1 !== t2) return false
          
          // 类型一致
          if (t1 === 'array') {
              // 首先判断数组包含元素个数是否相等
              if (o1.length !== o2.length) return false 
              // 比较两个数组中的每个元素
              return o1.every((item, i) => {
                  // return item === target
                  return isEqual(item, o2[i])
              })
          }

          if (t2 === 'object') {
              // object类型比较类似数组
              const keysArr = Object.keys(o1)
              if (keysArr.length !== Object.keys(o2).length) return false
              // 比较每一个元素
              return keysArr.every(k => {
                  return isEqual(o1[k], o2[k])
              })
          }

          return o1 === o2
      }

      // 数组去重
      const removeDuplicates = (arr) => {
          return arr.reduce((accumulator, current) => {
              const hasIndex = accumulator.findIndex(item => isEqual(current, item))
              if (hasIndex === -1) {
                  accumulator.push(current)
              }
              return accumulator
          }, [])
      }

      // 测试
      removeDuplicates([123, {a: 1}, {a: {b: 1}}, {a: "1"}, {a: {b: 1}}, "meili", {a:1, b:2}, {b:2, a:1}])
      // [123, {a: 1}, a: {b: 1}, {a: "1"}, "meili", {a: 1, b: 2}]
      ```

### 图片懒加载

1. 参考链接

   [js 实现图片懒加载原理](https://blog.csdn.net/w1418899532/article/details/90515969)

   [图片懒加载原理及实现](https://www.jianshu.com/p/8e2a73638153)

2. 详解

   - 描述

     一个网页包含大量图片，并发加载会影响渲染速度和占用带宽，如果改为可视区域加载，则能优化性能。

   - 原理

     图片是否加载取决于 img 标签的 src，先不给 src 赋值，等到进入可视区域再赋值，这时候才请求图片

   - 思路

     1. loading 图片
     2. 判断可视区域：$img.offset().top <= $(window).height()+\$(window).scrollTop() 元素距离顶部的距离<=可视区域高度+窗口滚动距离
     3. 替换图片

   - 实现

     ```html
     <div class="imgList">
       <img class="lazy" src="img/loading.gif" data-src="img/pic1" alt="pic" />
       <img class="lazy" src="img/loading.gif" data-src="img/pic2" alt="pic" />
       <img class="lazy" src="img/loading.gif" data-src="img/pic3" alt="pic" />
     </div>
     <script>
       $(() => {
         let lazyload = () => {
           for (let i = 0; i < $(".lazy").length; i++) {
             if (
               $(".lazy").eq(i).offset().top <=
               $(window).height() + $(window).scrollTop()
             ) {
               $(".lazy").eq(i).attr("src", $(".lazy").eq(i).data("src"));
             }
           }
         };
         lazyload();
         $(window).on("scroll", function () {
           lazyload();
         });
       });
     </script>
     ```

### 正则获取URL参数

1. 参考链接

   [正则获取 URL 参数](https://www.cnblogs.com/elexiang/p/4732364.html)

2. 详解

   - 获取指定 URL 参数

   ```js
   function getUrlParams(name) {
     //(^|&)从头开始或匹配字符&,([^&]*)匹配不是&的任何内容,(&|$)遇到下一个&或者结束
     //在正则表达式中，增加一个()代表着匹配数组中增加一个值, 因此代码中的正则匹配后数组中应包含4个值(完整匹配+3个括号)
     var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
     var r = window.location.search.substr(1).match(reg);
     if (r != null) return unescape(r[2]); //获取([^&]*)的结果
     return null;
   }

   window.location = "http://www.baidu.com?name=elephant&age=25&sex=male";
   var name = getUrlParams("name"); //elephant
   var age = getUrlParams("age"); //25
   var sex = getUrlParams("sex"); //male
   ```

   - 获取所有的 URL 参数

   ```js
   function parse_url(_url) {
     //定义函数
     var pattern = /(\w+)=(\w+)/gi; //定义正则表达式
     var parames = {}; //定义数组
     url.replace(pattern, function (a, b, c) {
       //替换函数(完整匹配+2个括号)
       parames[b] = c;
     });
     return parames; //返回这个数组.
   }

   var url = "http://www.baidu.com?name=elephant&age=25&sex=male";
   var params = parse_url(url); // ["name=elephant", "age=25", "sex=male"]
   ```

### js操作cookie

1. 参考链接：

   - [十道大厂面试题(含答案)总结](https://mp.weixin.qq.com/s/o553cr1FHLz40PpxbO8oOw)
   - [JS 中 cookie 的设置，读取，删除，更新覆盖等](https://blog.csdn.net/baidu_31683691/article/details/52516413)
   - [运用 JS 设置 cookie、读取 cookie、删除 cookie](https://www.cnblogs.com/limeiky/p/6927305.html)

2. 详解：

   - 获取

   ```js
   function getCookie(name) {
     var arr,
       reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
     if ((arr = document.cookie.match(reg))) return unescape(arr[2]);
     else return null;
   }
   ```

   - 设置/添加

   ```js
   function setCookie(name, value) {
     var Days = 30;
     var exp = new Date();
     exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);
     document.cookie =
       name + "=" + escape(value) + ";expires=" + exp.toGMTString();
   }
   ```

   - 更新

   ```js
   function updateCookie(name, value) {
     var exp = new Date();
     exp.setTime(exp.getTime() - 1);
     var currentValue = getCookie(name);
     if (currentValue != null) {
       document.cookie =
         name + "=" + escape(value) + ";expires=" + exp.toGMTString();
     }
   }
   ```

   - 删除

   ```js
   function delCookie(name) {
     var exp = new Date();
     exp.setTime(exp.getTime() - 1);
     var cval = getCookie(name);
     if (cval != null)
       document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString();
   }
   ```


### 文件切片上传

1. 参考链接

   [前端 h5 文件切片上传,后台 php 接收切片并合并](https://www.ucloud.cn/yun/29610.html)

2. 详解

   没法实现错误重传，中途断网则中断，因为：

   1. 重传则快速递归 ajax 卡死浏览器，没法实现休眠 3 秒(js 单线程原因)来使 ajax 间隔开，因为 settimeout 没法同步执行，await 也没用
   2. 如果改为保存状态，把后面的执行完，再回头执行，也无法避免快速递归卡死的情况
   3. 无法通过服务器响应来阻塞程序，因为断网服务器不会有响应

   解决的办法：上传文件前，通过文件名(文件名相同，文件不同，则自行负责)向服务器询问是否有此文件的片段，有则返回序号，从序号开始继续分片上传。

   上传内容：

   1. 文件名
   2. 分片名
   3. 文件二进制流
   4. 分片序号
   5. 分片大小
   6. (总文件大小)
   7. (分片总数)

   ```html
   <input id="in" type="file" />
   <script>
     $(function () {
       let pieceSize = 10;
       var totalSize = 0;

       $("#in").on("change", function () {
         handleFiles(this.files);
       });

       async function handleFiles(fileList) {
         var i = 0;
         while (i < fileList.length) {
           console.log("=================================================");
           console.log(
             "开始处理第" +
               i +
               "个文件, 文件是" +
               fileList[i]["name"] +
               "大小是:" +
               fileList[i]["size"]
           );
           var targetFile = fileList[i];
           totalSize += targetFile.size;
           await uploadFile(targetFile, i);
           i++;
           if (i == fileList.length) return;
         }
       }

       async function uploadFile(targetFile, index) {
         //console.log(targetFile);
         var tmp = targetFile.name.split(".");
         //var filename = "file-" + guid() + '.' + tmp[tmp.length - 1];
         var fileSize = targetFile.size;
         var total = Math.ceil(fileSize / pieceSize);

         await handle();

         async function handle() {
           var i = 0;
           var start = (end = 0);
           while (i < total) {
             end = start + pieceSize;

             if (end >= fileSize) {
               end = fileSize;
             }

             console.log(
               "文件的index:" + index + "| 处理文件切片 i:" + i,
               "start:" + start,
               "end:" + end
             );
             var frag = targetFile.slice(start, end);

             var filename = "file-" + i + "." + tmp[tmp.length - 1];

             await send(filename, frag, i, total, function () {
               console.log(
                 "文件的index:" + index + "| 切片上传完成 回调 res111",
                 i
               );
             });

             start = end;
             i++;
           }
         }
       }

       //send
       async function send(filename, frag, index, total, cb) {
         var formData = new FormData();
         var fragname = "frag-" + index;

         formData.append("filename", filename);
         formData.append("fragname", fragname);
         formData.append("file", frag);
         formData.append("fragindex", index);
         formData.append("total", total);

         await $.ajax({
           url: "/cms/test1",
           type: "POST",
           cache: false,
           data: formData,
           processData: false,
           contentType: false,
         })
           .done(function (res) {
             //console.log('res:' + index);
             cb && cb();
           })
           .fail(function (res) {});
       }
     });
   </script>
   ```

### 大文件切片并行下载

1. 参考链接

  [JavaScript 中如何实现大文件并行下载？](https://juejin.cn/post/6954868879034155022)

  [HTTP之HEAD请求](https://blog.csdn.net/u014738683/article/details/64442444/)

2. 详解

  * http范围请求range

    如果在响应中存在 Accept-Ranges 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。

    在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。
    
    如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码。
    
    假如所请求的范围不合法，那么服务器会返回  416 Range Not Satisfiable 状态码，表示客户端错误。
    
    服务器允许忽略  Range  首部，从而返回整个文件，状态码用 200 。

    range请求头
    ```txt
    Range: bytes=0-50, 100-150, 150-200
    Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, ...
    range-end如果不存在，表示此范围一直延伸到文档结束。
    ```

  * head请求

    HEAD方法与GET类似，但是HEAD并不返回消息体。

    这种方法可以用来获取请求中隐含的元信息，而无需传输实体本身。

    这个方法经常用来:
    
    1. 测试超链接的有效性，可用性和最近修改。
    2. 检查网页是否被串改。
    3. 获取下载文件大小。
    4. 获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等。

  * 样例

    ```html
    <!DOCTYPE html>
    <html lang="zh-cn">

    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>多线程下载示例</title>
      <script>
        function concatenate(arrays) {
          if (!arrays.length) return null;
          let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);
          let result = new Uint8Array(totalLength);
          let length = 0;
          for (let array of arrays) {
            result.set(array, length);
            length += array.length;
          }
          return result;
        }

        function getContentLength(url) {
          return new Promise((resolve, reject) => {
            let xhr = new XMLHttpRequest();
            xhr.open("HEAD", url);// 发送 HEAD 请求
            xhr.send();
            xhr.onload = function () {
              resolve(
                // xhr.getResponseHeader("Accept-Ranges") === "bytes" &&
                ~~xhr.getResponseHeader("Content-Length") // 获取当前 url 对应文件的内容长度
              );
            };
            xhr.onerror = reject;
          });
        }

        function getBinaryContent(url, start, end, i) {
          return new Promise((resolve, reject) => {
            try {
              let xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.setRequestHeader("range", `bytes=${start}-${end}`); // 请求头上设置范围请求信息
              xhr.responseType = "arraybuffer"; // 设置返回的类型为arraybuffer
              xhr.onload = function () {
                resolve({
                  index: i, // 文件块的索引
                  buffer: xhr.response, // 范围请求对应的数据
                });
              };
              xhr.send();
            } catch (err) {
              reject(new Error(err));
            }
          });
        }

        function saveAs({ name, buffers, mime = "application/octet-stream" }) {
          const blob = new Blob([buffers], { type: mime });
          const blobUrl = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.download = name || Math.random();
          a.href = blobUrl;
          a.click();
          URL.revokeObjectURL(blob);
        }

        // poolLimit（数字类型）：表示限制的并发数；
        // array（数组类型）：表示任务数组；
        // iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。
        async function asyncPool(poolLimit, array, iteratorFn) {
          const ret = []; // 存储所有的异步任务
          const executing = []; // 存储正在执行的异步任务
          for (const item of array) {
            // 调用iteratorFn函数创建异步任务
            const p = Promise.resolve().then(() => iteratorFn(item, array));
            ret.push(p); // 保存新的异步任务
            console.log(`ret:${ret},executing:${executing}`);
            // 当poolLimit值小于或等于总任务个数时，进行并发控制
            if (poolLimit <= array.length) {
              // 当任务完成后，从正在执行的任务数组中移除已完成的任务
              const e = p.then(() => executing.splice(executing.indexOf(e), 1));
              executing.push(e); // 保存正在执行的异步任务
              console.log(`e:${e}`);
              if (executing.length >= poolLimit) {
                await Promise.race(executing); // 等待较快的任务执行完成
              }
            }
          }
          return Promise.all(ret);
        }

        // url（字符串类型）：预下载资源的地址；
        // chunkSize（数字类型）：分块的大小，单位为字节；
        // poolLimit（数字类型）：表示限制的并发数。
        async function download({ url, chunkSize, poolLimit = 1 }) {
          const contentLength = await getContentLength(url);
          const chunks = typeof chunkSize === "number" ? Math.ceil(contentLength / chunkSize) : 1;
          console.log(`contentLength:${contentLength},chunkSize:${chunkSize},chunks:${chunks}`);
          const results = await asyncPool(
            poolLimit,
            [...new Array(chunks).keys()],
            (i) => {
              let start = i * chunkSize;
              let end = i + 1 == chunks ? contentLength - 1 : (i + 1) * chunkSize - 1;
              console.log(`start:${start},end:${end}`);
              return getBinaryContent(url, start, end, i);
            }
          );
          console.log(`results${results}`)
          const sortedBuffers = results.map((item) => new Uint8Array(item.buffer));
          console.log(`sortedBuffers${sortedBuffers}`)
          return concatenate(sortedBuffers);
        }
      </script>
    </head>

    <body>
      <p>文件地址：<input type="text" id="fileUrl" value="" /></p>
      <div>
        <h3>多线程下载</h3>
        <button onclick="multiThreadedDownload()">多线程下载</button>
      </div>
      <script>
        function multiThreadedDownload() {
          const url = document.querySelector("#fileUrl").value;
          if (!url || !/https?/.test(url)) return;
          console.log("多线程下载开始: " + +new Date());
          download({
            url,
            chunkSize: 2 * 1024 * 1024,
            poolLimit: 6,
          }).then((buffers) => {
            console.log("多线程下载结束: " + +new Date());
            saveAs({ buffers, name: "我的压缩包", mime: "application/zip" });
          });
        }
      </script>
    </body>

    </html>
    ```

### 长列表优化

1. 参考链接：

   [简洁、巧妙、高效的长列表，无限下拉方案](https://mp.weixin.qq.com/s/FVxt3ORsN6dq09t8rzHdRw)

   [vue-virtual-scroll-list 源代码](http://www.github.com/tangbc/vue-virtual-scroll-list)

   [Intersection Observer](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)

2. 详解

   - 两个要素

     1. intersection observer

        - 作用

          IntersectionObserver 接口 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根

          异步查询元素相对于其他元素或视窗的位置，消除了昂贵的 DOM 查询和样式读取成本。兼容性较差，需要 polyfill。

        - 场景

          1. 页面滚动时的懒加载实现。
          2. 无限下拉（本文的实现）。
          3. 监测某些广告元素的曝光情况来做相关数据统计。
          4. 监测用户的滚动行为是否到达了目标位置来实现一些交互逻辑（比如视频元素滚动到隐藏位置时暂停播放）。

     2. padding

   - 长列表优化思路

     - 监听一个固定长度列表的首尾元素是否进入视窗;
     - 更新当前页面内渲染的第一个元素对应的序号;
     - 根据上述序号，获取目标数据元素，列表内容重新渲染成对应内容;
     - 容器 padding 调整，模拟滚动实现。

     核心：利用父元素的 padding 去填充随着无限下拉而本该有的、越来越多的 DOM 元素，仅仅保留视窗区域上下一定数量的 DOM 元素来进行数据渲染。

   - 实现

     1. 监听一个固定长度列表的首尾元素是否进入视窗

        ```js
        // 观察者创建
        this.observer = new IntersectionObserver(callback, options);

        // 观察列表第一个以及最后一个元素
        this.observer.observe(this.firstItem);
        this.observer.observe(this.lastItem);

        //当他们其中一个重新进入视窗时，callback 函数就会触发
        const callback = (entries) => {
          entries.forEach((entry) => {
            if (entry.target.id === firstItemId) {
              // 当第一个元素进入视窗
            } else if (entry.target.id === lastItemId) {
              // 当最后一个元素进入视窗
            }
          });
        };
        ```

     2. 更新当前页面渲染的第一个元素对应的序号 (firstIndex)

        - 用一个数组来维护需要渲染到页面中的数据。数组的长度会随着不断请求新的数据而不断变大，而渲染的始终是其中一定数量的元素,比如 20 个

        - 最开始渲染的是数组中序号为 0 - 19 的元素，即此时对应的 firstIndex 为 0

        - 当序号为 19 的元素（即上一步的 lastItem ）进入视窗时，我们就会往后渲染 10 个元素，即渲染序号为 10 - 29 的元素，那么此时的 firstIndex 为 10

        - 下一次就是，当序号为 29 的元素进入视窗时，继续往后渲染 10 个元素，即渲染序号为 20 - 39 的元素，那么此时的 firstIndex 为 20，以此类推

        ```js
        // 我们对原先的 firstIndex 做了缓存
        const { currentIndex } = this.domDataCache;

        // 以全部容器内所有元素的一半作为每一次渲染的增量
        const increment = Math.floor(this.listSize / 2);

        let firstIndex;

        //更新 firstIndex，是为了根据页面的滚动情况，知道接下来哪些数据应该被获取、渲染
        if (isScrollDown) {
          // 向下滚动时序号增加
          firstIndex = currentIndex + increment;
        } else {
          // 向上滚动时序号减少
          firstIndex = currentIndex - increment;
        }
        ```

     3. 根据上述序号，获取对应数据元素，列表重新渲染成新的内容

        ```js
        //根据 firstIndex 查询数据，然后将目标数据渲染到页面上
        const renderFunction = (firstIndex) => {
          // offset = firstIndex, limit = 10 => getData
          // getData Done =>  new dataItems => render DOM
        };
        ```

     4. padding 调整，模拟滚动实现

        这 10 个新的数据元素，我们用原来已有的 DOM 元素去渲染，替换掉已经离开视窗、不可见的数据元素;而本该由更多 DOM 元素进一步撑开容器高度的部分，我们用 padding 填充来模拟实现。

        向下滚动

        ```js
        // padding的增量 = 每一个item的高度 x 新的数据项的数目
        const remPaddingsVal = itemHeight * Math.floor(this.listSize / 2);

        if (isScrollDown) {
          // paddingTop新增，填充顶部位置
          newCurrentPaddingTop = currentPaddingTop + remPaddingsVal;

          if (currentPaddingBottom === 0) {
            newCurrentPaddingBottom = 0;
          } else {
            // 如果原来有paddingBottom则减去，会有滚动到底部的元素进行替代
            newCurrentPaddingBottom = currentPaddingBottom - remPaddingsVal;
          }
        }
        ```

        向上滚动

        ```js
        // padding的增量 = 每一个item的高度 x 新的数据项的数目
        const remPaddingsVal = itemHeight * Math.floor(this.listSize / 2);

        if (!isScrollDown) {
          // paddingBottom新增，填充底部位置
          newCurrentPaddingBottom = currentPaddingBottom + remPaddingsVal;

          if (currentPaddingTop === 0) {
            newCurrentPaddingTop = 0;
          } else {
            // 如果原来有paddingTop则减去，会有滚动到顶部的元素进行替代
            newCurrentPaddingTop = currentPaddingTop - remPaddingsVal;
          }
        }
        ```

        最后是 padding 设置更新以及相关缓存数据更新

        ```js
        // 容器padding重新设置
        this.updateContainerPadding({
          newCurrentPaddingBottom,
          newCurrentPaddingTop,
        });

        // DOM元素相关数据缓存更新
        this.updateDomDataCache({
          currentPaddingTop: newCurrentPaddingTop,
          currentPaddingBottom: newCurrentPaddingBottom,
        });
        ```

     - 优势

       把同步触发的滚动事件变为异步，无需做防抖

     - 缺陷

       1. padding 计算依赖列表项固定高度
       2. 数据请求过程需要 loading 效果
       3. 需要兼容用户难以预测的滚动行为

   - 其它库

     - iScroll

       scroll 事件监听，translate 上下移，视窗外元素插入队尾，循环队列，无限下拉

### 活动倒计时

1.  参考链接：

    [js 计算两个时间时间差（天时分秒）](https://www.jianshu.com/p/e5bb679f92c7)

    [js 计算两个时间差 年月日时分秒](https://blog.csdn.net/qq_36279445/article/details/103493495)

2.  详解

    1.  方法概述

        计算时间 getTime()的时间戳差值，换算为年月日时分秒，setInterval 调用一次逻辑

    2.  实现

        ```js
        var future = "2017-04-04";

        var calculationTime = function (future) {
          var s1 = new Date(future.replace(/-/g, "/")),
            s2 = new Date(),
            runTime = parseInt((s1.getTime() - s2.getTime()) / 1000);
          var year = Math.floor(runTime / 86400 / 365);
          runTime = runTime % (86400 * 365);
          var month = Math.floor(runTime / 86400 / 30);
          runTime = runTime % (86400 * 30);
          var day = Math.floor(runTime / 86400);
          runTime = runTime % 86400;
          var hour = Math.floor(runTime / 3600);
          runTime = runTime % 3600;
          var minute = Math.floor(runTime / 60);
          runTime = runTime % 60;
          var second = runTime;
          return [year, month, day, hour, minute, second];
        };
        setInterval(function () {
          var result = calculationTime(future);
          //更新视图
        }, 1000);
        ```

### 数据埋点与错误监控

1. 参考链接：

   [关于数据埋点](https://www.jianshu.com/p/9303296f59e5)

   [第五期 | 前端监控怎么玩？](https://juejin.im/post/5ea3eb326fb9a03c485791f9)

   [如何清楚易懂的解释“UV 和 PV＂的定义？](https://www.zhihu.com/question/20448467)

   [有关 cookie 实现统计 pv,uv 的一些用法](https://blog.csdn.net/lfcss/article/details/45247577)

   [原生 js 操作 cookie](https://www.cnblogs.com/tutuj/p/10991283.html)

   [js 记录用户在网站的浏览记录和停留时间](https://blog.csdn.net/canglingyue/article/details/52409265)

   [前端性能优化指南 6--Web 性能标准](https://juejin.im/post/5eb745b35188256d7a3cae01#heading-1)

   [搭建前端监控系统（二）JS 错误监控篇](https://www.cnblogs.com/warm-stranger/p/9417084.html)

   [window onerror 各浏览器下表现总结](https://segmentfault.com/a/1190000011041164)

   [JS 错误监控总结](https://segmentfault.com/a/1190000014672384)

   [Sentry 的使用](https://www.jianshu.com/p/280ed215c0d2)

   [一文读懂产品曝光埋点](http://www.woshipm.com/pd/3226195.html)

   [埋点与动态创建<img>、<script>](https://segmentfault.com/a/1190000020002603?utm_source=tag-newest)

   [前端监控平台系列：JS SDK（已开源）](https://juejin.im/post/6862559324632252430#heading-26)

   [webfunny_monitor](https://github.com/a597873885/webfunny_monitor)

   [前端监控方案](https://github.com/xpsilvester/Notes/blob/master/Project/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88.md)

   [手把手带你入门前端工程化——超详细教程](https://juejin.im/post/6892003555818143752#heading-57)

   [vue声明式埋点实践](https://blog.csdn.net/weixin_34283445/article/details/91428551)

   [如何从零打造 web 性能监控系统？](https://mp.weixin.qq.com/s/YFoI1w1bS1lguv04hamumw)

   [基于typescript开发前端错误及性能监控SDK](https://juejin.cn/post/6958690901380038687)

2. 详解

   ![错误监控](./errorMonitor.jpg)

   ![错误采集](./errorCapture.jpg)

   [前端监控方案](https://github.com/xpsilvester/Notes/blob/master/Project/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88.md)

   - 国内常用的监控平台

      - sentry ：从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵
      - fundebug：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐
      - webfunny：也是含有监控错误的功能，可以支持千万级别日PV量，额外的亮点是可以远程调试、性能分析，也可以docker私有化部署（免费），业务代码加密过，[webfunny_monitor](https://github.com/a597873885/webfunny_monitor)

   - 合成监控工具

      * 优缺点

        * 无侵入性。
        * 简单快捷。缺点：
        * 不是真实的用户访问情况，只是模拟的。
        * 没法考虑到登录的情况，对于需要登录的页面就无法监控到。

      * chrome插件

        lighthouse

      * node

        * lighthouse
        
          npm install -g lighthouse

          lighthouse https://www.cnblogs.com/

      * 站点

        webpagetest：https://www.webpagetest.org/

        Pingdom：https://tools.pingdom.com/

     - 真实用户监控平台

        * 优缺点

          * 是真实用户访问情况。
          * 可以观察历史性能趋势。
          * 有一些额外的功能：报表推送、监控告警等等。缺点：
          * 有侵入性，会一定程度上响应 web 性能。

        * oneapm：https://www.oneapm.com/bi/feature.html
        * Datadog：https://www.datadoghq.com/rum/
        * FrontJs：https://www.frontjs.com/

   - 自研监控平台需要做三个部分：

      - APP监控SDK：收集错误信息并上报
      - server端：接收错误信息，处理数据并做持久化，而后根据告警规则通知对应的开发人员
      - 可视化平台：从数据存储引擎拿出相关错误信息进行渲染，用于快速定位问题

   - 单页面埋点方案

      - 命令式埋点：在用户产生行为的地方使用js方法进行数据上报，优点是埋点方式比较简单，缺点是与业务耦合度较高
      - 声明式埋点：在具体DOM元素上进行数据绑定，只需组件开发人员在sdk上制定埋点方案，业务开发人员设置数据即可，优点是埋点代码与具体的交互和业务逻辑解耦
      - 可视化埋点：通过可视化工具配置埋点，需要另外配套一个平台控制埋点的埋入，优点是自动生成埋点代码嵌入到页面中，减轻业务开发人员的埋点负担，目前做得好得例如Mixpanel
      - 无埋点：前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是完全无需业务参与，完全与业务解耦，目前比较流行的例如GrowingIO

   - 数据埋点

     - 数据埋点的方式

       1. 注入自己研发的代码和搭建后台统计
       2. 第三方统计工具，如百度统计、友盟、神策、数极客、Talkingdata、GrowingIO、Fundebug、FrontJS、Sentry 等

     - 关键指标

       1. 访问次数（Visits）与访问人数（Vistors）
       2. 停留时长

          - 采集数据：最小时长，最大时长，平均时长，中位数
          - 采集事件：鼠标、滚动、键盘、自定义事件

       3. 跳出率(用户只访问了一个页面所占的会话比例,分为应用的跳出率、着陆页的跳出率)
       4. 退出率(某个页面有多少用户离开了应用,退出率高不一定是坏事,流程的最终节点的退出率就应该是高的)
       5. 转化率(某种产出,如订单,除以独立访客或是访问量,或某条路径的转化率)
       6. 参与度(访问深度，访问频次，播放次数等)
       7. 用户地域分布(ip)
       8. 页面来源分布：内链、外链、搜索引擎(referer)
       9. 广告位点击率：点击次数/曝光次数

     - 注意

       埋点贵精不贵多

     - 曝光埋点

       点击率的计算：CTR=点击数/曝光数

       场景：活动入口有一张 banner，要统计用户是否有看此 banner，即曝光数

       条件：用户需要滑动到推荐区域，至少露出一个卡片的高度，至少需要在推荐区域停留时长不少于 15s，一定时间内重复滑动不重复上报

   - 组件监控

     - 关键指标

       1. 引用量，引用次数高对此组件的优先级也高
       2. 曝光点击率： 引导转化率 = 引导成交量/点击量/曝光量
       3. 数据接口： 加载时间、组件异常、白屏率
       4. 配置复杂度：比如输入转选择类型，预设默认值，减少用户配置时间
       5. 代码质量：编译过程中，ESlint 上报不合规

     - 监控场景

       1. 用户监控： 埋点-> 采集 -> 计算 -> 分析
       2. 错误监控：错误收集-> 错误上报 -> 数据清洗 -> 数据持久化 -> 平台可视化、监控

   - 埋点样例

     1. UV（Unique visitor）

        - 定义

          访问您网站的一台电脑客户端为一个访客。00:00-24:00 内相同的客户端只被计算一次。

        - 统计方法

          1. 计入页面查找 cookie 预设字段是否存在
          2. 不存在则设置 cookie 预设字段，设置此信息 expire 为 24 小时，带 jwt 发送请求，包含用户 id、当天首次进入时间等信息

     2. PV（Page View）

        - 定义

          页面浏览量，或点击量;用户每 1 次对网站中的每个网页访问均被记录 1 次。用户对同一页面的多次访问，访问量累计。

        - 统计方法

          进入页面即发请求，可包含进入时间、用户 id 等信息

     3. IP（Internet Protocol）

        - 定义

          1 天内独立 IP 访问数至多计算 1 次

        - 统计方法

          同 UV

     4. VV（Visit View）

        - 定义

          统一访客访问网站的次数，从打开网站，到点击各标签，到完全关闭，计数加一

        - 统计方法

          总体上类似 UV，使用 cookie 统计，不同之处是打开页面 onload 时 cookie 信息中的页面数+1，关闭页面 beforeunload，cookie 信息中的页面数-1，页面数为 0 时发送请求，清除这段 cookie

     5. 用户停留时间

        - 统计方法

          1. window 的 focus 和 blur 能找出用户是否在浏览当前页面
          2. setInterval 统计时间，window 的 blur 可停止计时，window 的 focus 可读取信息，合并并继续计时
          3. localstorage 因存储量比 cookie 大，可用来记录信息，信息为 json，通过 stringify 和 parse 保存和提取，信息包括当前 url(location.href)、停留时间、来源 url(document.referer)、进入时间、离开时间等
          4. onload(包括刷新)可记录进入时间，读取上次保存的信息(如有)，可继续计时等操作
          5. beforeunload 可记录离开时间，发送请求，清除信息

     6. 动态创建 img 或 script

        - 使用原因

          - 埋点一般不用关心请求的结果
          - 可以实现跨域请求
          - 无需使用 ajax 就能达到发请求的目的
          - 都是原生实现，兼容性好

        - 动态创建 img

          ```js
          function sendByImg(src) {
            var img = document.createElement("img");
            img.src = src;
          }
          ```

          ```js
          function sendByImage(src) {
            var img = new Image();
            img.src = src;
          }
          ```

        - 动态创建 script

          ```js
          function sendByScript(src) {
            var script = document.createElement("script");
            script.src = src;
            (
              document.getElementsByTagName("head")[0] ||
              document.getElementsByTagName("body")[0]
            ).appendChild(script);
          }
          ```

        - 区别

          1. 触发请求，script 必须插入到 DOM，而 img 均不需要
          2. script 可以借助类似 jsonp 实现原理处理请求结果，img 不能

        - 推荐使用

          首选 script 方式：拓展性和兼容性好，能处理回调，不怕禁用图片模式

     7. ajax拦截

        ```ts
        XMLHttpRequest.prototype.open = function (method: string, url: string) {
          const reqStartRes: IAjaxReqStartRes = {
          };

          myEmitter.customEmit(TrackerEvents.reqStart, reqStartRes);
          return open.call(this, method, url, true);
        };

        XMLHttpRequest.prototype.send = function (...rest: any[]) {
          const body = rest[0];
          const requestData: string = body;
          const startTime = Date.now();

          this.addEventListener("readystatechange", function () {
            if (this.readyState === 4) {
              if (this.status >= 200 && this.status < 300) {
                const reqEndRes: IReqEndRes = {};

                myEmitter.customEmit(TrackerEvents.reqEnd, reqEndRes);
              } else {
                const reqErrorObj: IHttpReqErrorRes = {};
                
                myEmitter.customEmit(TrackerEvents.reqError, reqErrorObj);
              }
            }
          });
          return send.call(this, body);
        };
        ```

     8. fetch拦截

        ```ts
        Object.defineProperty(window, "fetch", {
          configurable: true,
          enumerable: true,
          get() {
            return (url: string, options: any = {}) => {
              const reqStartRes: IFetchReqStartRes = {};
              myEmitter.customEmit(TrackerEvents.reqStart, reqStartRes);

              return originFetch(url, options)
                .then((res) => {
                  const status = res.status;
                  const reqEndRes: IReqEndRes = {};

                  const reqErrorRes: IHttpReqErrorRes = {};

                  if (status >= 200 && status < 300) {
                    myEmitter.customEmit(TrackerEvents.reqEnd, reqEndRes);
                  } else {
                    if (this._url !== self._options.reportUrl) {
                      myEmitter.customEmit(TrackerEvents.reqError, reqErrorRes);
                    }
                  }

                  return Promise.resolve(res);
                })
                .catch((e: Error) => {
                  const reqErrorRes: IHttpReqErrorRes = {};
                  myEmitter.customEmit(TrackerEvents.reqError, reqErrorRes);
                });
            };
          }
        });
        ```

   - 错误监控

    - 情况

      1. js 编译时异常（开发阶段就能排）
      2. js 运行时异常
      3. 加载静态资源异常（路径写错、资源服务器异常、CDN 异常、跨域）
      4. 接口请求异常

    - 流程

      监控错误 -> 搜集错误 -> 存储错误 -> 分析错误 -> 错误报警-> 定位错误 -> 解决错误

    - 必要的数据

      应用 JS 报错的走势(chart 图表)、JS 错误发生率、JS 错误在 PC 端发生的概率、JS 错误在 IOS 端发生的概率、JS 错误在 Android 端发生的概率，以及 JS 错误的归类

    - 辅助信息

      JS 错误类型、 JS 错误信息、JS 错误堆栈、JS 错误发生的位置以及相关位置的代码;JS 错误发生的几率、浏览器的类型，版本号，设备机型等等辅助信息

    - 数据代码封装

      ```js
      // 设置日志对象类的通用属性
      function setCommonProperty() {
        this.happenTime = new Date().getTime(); // 日志发生时间
        this.webMonitorId = WEB_MONITOR_ID; // 用于区分应用的唯一标识（一个项目对应一个）
        this.simpleUrl = window.location.href.split("?")[0].replace("#", ""); // 页面的url
        this.customerKey = utils.getCustomerKey(); // 用于区分用户，所对应唯一的标识，清理本地数据后失效
        this.pageKey = utils.getPageKey(); // 用于区分页面，所对应唯一的标识，每个新页面对应一个值
        this.deviceName = DEVICE_INFO.deviceName;
        this.os =
          DEVICE_INFO.os +
          (DEVICE_INFO.osVersion ? " " + DEVICE_INFO.osVersion : "");
        this.browserName = DEVICE_INFO.browserName;
        this.browserVersion = DEVICE_INFO.browserVersion;
        // TODO 位置信息, 待处理
        this.monitorIp = ""; // 用户的IP地址
        this.country = "china"; // 用户所在国家
        this.province = ""; // 用户所在省份
        this.city = ""; // 用户所在城市
        // 用户自定义信息， 由开发者主动传入， 便于对线上进行准确定位
        this.userId = USER_INFO.userId;
        this.firstUserParam = USER_INFO.firstUserParam;
        this.secondUserParam = USER_INFO.secondUserParam;
      }

      // JS错误日志，继承于日志基类MonitorBaseInfo
      function JavaScriptErrorInfo(uploadType, errorMsg, errorStack) {
        setCommonProperty.apply(this);
        this.uploadType = uploadType;
        this.errorMessage = encodeURIComponent(errorMsg);
        this.errorStack = errorStack;
        this.browserInfo = BROWSER_INFO;
      }
      JavaScriptErrorInfo.prototype = new MonitorBaseInfo();
      ```

    - 错误监控代码

      1. 重写 window.onerror，判断e.target.localName是否有值，有的话就是资源错误，没就是代码错误，通过event.target拿到

      2. 重写 console.error，如果 App 首次向浏览器注入的 Js 代码报错了，window.onerror 是无法监控到的，所以只能重写 console.error 的方式来进行捕获,待 window.onerror 成功后，此方法便不再需要用了

      3. 重写 window.onunhandledrejection 方法。 当用到 Promise 又忘记写 reject 的捕获方法的时候，系统会抛出一个 Unhandled Promise rejection. 没有堆栈，没有其他信息，特别是在写 fetch 请求的时候很容易发生。

      ```js
      //页面JS错误监控
      function recordJavaScriptError() {
        // 重写console.error, 可以捕获更全面的报错信息
        var oldError = console.error;
        console.error = function () {
          // arguments的长度为2时，才是error上报的时机
          // if (arguments.length < 2) return;
          var errorMsg = arguments[0] && arguments[0].message;
          var url = WEB_LOCATION;
          var lineNumber = 0;
          var columnNumber = 0;
          var errorObj = arguments[0] && arguments[0].stack;
          if (!errorObj) errorObj = arguments[0];
          // 如果onerror重写成功，就无需在这里进行上报了
          !jsMonitorStarted &&
            siftAndMakeUpMessage(
              errorMsg,
              url,
              lineNumber,
              columnNumber,
              errorObj
            );
          return oldError.apply(console, arguments);
        };
        // 重写 onerror 进行jsError的监听
        window.onerror = function (
          errorMsg,
          url,
          lineNumber,
          columnNumber,
          errorObj
        ) {
          jsMonitorStarted = true;
          var errorStack = errorObj ? errorObj.stack : null;
          siftAndMakeUpMessage(
            errorMsg,
            url,
            lineNumber,
            columnNumber,
            errorStack
          );
        };

        function siftAndMakeUpMessage(
          origin_errorMsg,
          origin_url,
          origin_lineNumber,
          origin_columnNumber,
          origin_errorObj
        ) {
          var errorMsg = origin_errorMsg ? origin_errorMsg : "";
          var errorObj = origin_errorObj ? origin_errorObj : "";
          var errorType = "";
          if (errorMsg) {
            var errorStackStr = JSON.stringify(errorObj);
            errorType = errorStackStr.split(": ")[0].replace('"', "");
          }
          var javaScriptErrorInfo = new JavaScriptErrorInfo(
            JS_ERROR,
            errorType + ": " + errorMsg,
            errorObj
          );
          javaScriptErrorInfo.handleLogInfo(JS_ERROR, javaScriptErrorInfo);
        }
      }
      ```

      4. JS 错误发生率 = JS 错误个数(一次访问页面中，所有的 js 错误都算一次)/PV (PC，IOS，Android 平台同理)

      ```js
      /**
      * 添加一个定时器，进行数据的上传
      * 2秒钟进行一次URL是否变化的检测
      * 10秒钟进行一次数据的检查并上传
      */
      var timeCount = 0;
      setInterval(function () {
        checkUrlChange();
        // 循环5后次进行一次上传
        if (timeCount >= 25) {
          // 如果是本地的localhost, 就忽略，不进行上传

          var logInfo =
            (localStorage[ELE_BEHAVIOR] || "") +
            (localStorage[JS_ERROR] || "") +
            (localStorage[HTTP_LOG] || "") +
            (localStorage[SCREEN_SHOT] || "") +
            (localStorage[CUSTOMER_PV] || "") +
            (localStorage[LOAD_PAGE] || "") +
            (localStorage[RESOURCE_LOAD] || "");

          if (logInfo) {
            localStorage[ELE_BEHAVIOR] = "";
            localStorage[JS_ERROR] = "";
            localStorage[HTTP_LOG] = "";
            localStorage[SCREEN_SHOT] = "";
            localStorage[CUSTOMER_PV] = "";
            localStorage[LOAD_PAGE] = "";
            localStorage[RESOURCE_LOAD] = "";
            utils.ajax(
              "POST",
              HTTP_UPLOAD_LOG_INFO,
              { logInfo: logInfo },
              function (res) {},
              function () {}
            );
          }
          timeCount = 0;
        }
        timeCount++;
      }, 200);
      ```

      5. 监控ajax和fetch的error回调

      6. vue报错函数回调：Vue.config.errorHandler和Vue.config.warnHandler，react有componentDidCatch钩子函数来回调错误信息

      7. Navigator.sendBeacon异步传输传输数据，在 unload 或者 beforeunload 事件处理器中发起一个同步 XMLHttpRequest 来发送数据，迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚

    - 定位与分析

      1. 某种错误发生的次数——发生次数跟影响用户是成正比的，如果发生次数跟影响用户数量都很高，那么这是一个比较严重的 bug, 需要立即解决。反之，如果次数很多，影响用户数量很少。说明这种错误只发生在少量设备中，优先级相对较低，可以择时对该类机型设备进行兼容处理。当然，ip 地址访问次数也能说明这个问题。

      2. 页面发生了哪些错误——这个有利于我们缩小问题的范围，方便我们排查

      3. 错误堆栈——是定位错误最重要的因素。正常情况下，代码都是被压缩的，利用 jsMap 反向找到代码的具体位置

      4. 设备信息——当错误发生是，分析出用户当时使用设备的浏览器信息，系统版本，设备机型等等，能够帮我们快速的定位到需要兼容的设备

      5. 用户足迹——代价太高，因为需要记录下用户在页面上的所有行为，需要上传非常多的数据

      6. 实时监控与报警

### npm版本号的区别

1.  参考链接：

    [npm 依赖包版本号~和^的区别](https://www.jianshu.com/p/4544a1e63a5c)

2.  详解

    ~会匹配最近的小版本依赖包，比如~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0

    ^会匹配最新的大版本依赖包，比如^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0

### 摄像头抓拍与RTC音视频会议

1.  参考链接：

    [js 调用摄像头拍照上传图片](https://www.cnblogs.com/51ma/p/11611487.html)

    [getUserMedia API 及 HTML5 调用摄像头和麦克风](https://www.cnblogs.com/cangqinglang/p/10210826.html)

    [MediaDevices.getUserMedia` undefined 的问题](https://www.cnblogs.com/Wayou/p/using_MediaDevices_getUserMedia_wihtout_https.html)

    [基于webrtc的音视频聊天，视频会议的实现](https://blog.csdn.net/xqtt29/article/details/109530221)

2.  详解

通过 MediaDevices.getUserMedia() 获取用户多媒体权限时，需要注意其只工作于以下三种环境：

* localhost 域
* 开启了 HTTPS 的域
* 使用 file:/// 协议打开的本地文件

```txt
其他情况下，比如在一个 HTTP 站点上，navigator.mediaDevices 的值为 undefined。

如果想要 HTTP 环境下也能使用和调试 MediaDevices.getUserMedia()，可通过开启 Chrome 的相应参数。

通过相应参数启动 Chrome
传递相应参数来启动 Chrome，以 http://example.com 为例，

--unsafely-treat-insecure-origin-as-secure="http://example.com"
开启相应 flag
通过传递相应参数来启动 Chrome Insecure origins treated as secure flag 并填入相应白名单。

打开 chrome://flags/#unsafely-treat-insecure-origin-as-secure
将该 flag 切换成 enable 状态
输入框中填写需要开启的域名，譬如 http://example.com"，多个以逗号分隔。
重启后生效。
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>摄像头拍照</title>
  </head>
  <body>
    <video id="video" width="480" height="320" controls></video>
    <div>
      <button id="open">开启摄像头</button>
      <button id="close">关闭摄像头</button>
      <button id="capture">拍照</button>
    </div>
    <canvas id="canvas" width="480" height="320"></canvas>
    <img id="img" width="480" height="320" />
    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let context = canvas.getContext("2d");

      //访问用户媒体设备的兼容方法
      function getUserMedia(constraints, success, error) {
        if (navigator.mediaDevices.getUserMedia) {
          //最新的标准API
          navigator.mediaDevices
            .getUserMedia(constraints)
            .then(success)
            .catch(error);
        } else if (navigator.webkitGetUserMedia) {
          //webkit核心浏览器
          navigator.webkitGetUserMedia(constraints, success, error);
        } else if (navigator.mozGetUserMedia) {
          //firfox浏览器
          navigator.mozGetUserMedia(constraints, success, error);
        } else if (navigator.getUserMedia) {
          //旧版API
          navigator.getUserMedia(constraints, success, error);
        }
      }

      // 打开摄像头成功回调
      function success(stream) {
        //兼容webkit核心浏览器
        let CompatibleURL = window.URL || window.webkitURL;
        //将视频流设置为video元素的源
        console.log(stream);

        //video.src = CompatibleURL.createObjectURL(stream);
        video.srcObject = stream;
        video.play();
      }

      // 打开摄像头失败回调
      function error(error) {
        console.log(`访问用户媒体设备失败${error.name}, ${error.message}`);
      }

      // 关闭摄像头
      function closeMedia() {
        let stream = video.srcObject;
        let tracks = stream.getTracks();

        tracks.forEach(function (track) {
          track.stop();
        });

        video.srcObject = null;
      }

      // 开启摄像头
      function openMedia() {
        if (
          navigator.mediaDevices.getUserMedia ||
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia
        ) {
          //调用用户媒体设备, 访问摄像头
          getUserMedia({ video: { width: 480, height: 320 } }, success, error);
        } else {
          alert("不支持访问用户媒体");
        }
      }

      document.getElementById("open").addEventListener("click", function () {
        openMedia();
      });

      document.getElementById("close").addEventListener("click", function () {
        closeMedia();
      });

      document.getElementById("capture").addEventListener("click", function () {
        context.drawImage(video, 0, 0, 480, 320);
        let src = canvas.toDataURL("image/png");
        document.getElementById("img").src = src; //上传src部分(base64)即可
        // $.ajax({
        //   url:"...",
        //   type:"post",
        //   data:{"imgData":src},
        //   success:function(data){
        //     console.log(data);
        //   },
        //   error:function(){
        //     console.log("服务端异常！");
        //   }
        // });
      });
    </script>
  </body>
</html>
```

采集本地摄像头和麦的媒体数据
```js
navigator.mediaDevices.getUserMedia({video: true, audio: true}).then((stream) => {
  //这里的stream就是我们想要的视频流和音频流的集合了
  //如果要在本地预览视频和音频，则只需要在html中添加一个video标签，将stream流赋给video标签即可，代码如下：
  let localVideo = document.getElementById('video标签的id');
  localVideo.srcObject = stream;
  localVideo.muted = true;
  localVideo.play();
})
```

RTCPeerConnection
```js

let rtcPeerConnection = new RTCPeerConnection({
  "iceServers":[{
      "url": "stun:stun.l.google.com:19302"
      },{
      "url": "turn:服务器IP", 
      "credential":"密码",
      "username":"账号"
  }]
});
//监听stun返回的NAT穿透信息：ICECandidate
rtcPeerConnection.onicecandidate = (event) => {
  //如果获取到了我的NAT穿透消息，则立马通过websocket将event.candidate传送到对方。一旦双方通过candidate成功建立连接，就会通过下面这个监听进行音视频流的传输。
  wx.send(event.candidate)
}
//监听传输轨道的传输数据
rtcPeerConnection.ontrack = (event) => {
  //通过event.streams就能获取到对方传送过来的音视频流，将他再添加到另一个video标签上，就是可以看到对方的画面啦
  let remoteVideo = document.getElementById("对方video标签的id");
  remoteVideo.srcObject = event.streams[0];
  remoteVideo.play();
}
//这里的localVideo是知识点解析的第1步获取到的本地音视频video标签，将他的流加入到传输轨道，连接一旦建立就立马触发ontrack事件，将本地的音视频流传到对方。
for (const track of localVideo.stream.getTracks()) {
  rtcPeerConnection.addTrack(track, this.videos[0].stream);
}
```

向对方发起offer
```js
rtcPeerConnection.createOffer({iceRestart: true, offerToReceiveAudio: true, offerToReceiveVideo: true}).then(
  (sessionDescription) => {
    rtcPeerConnection.setLocalDescription(sessionDescription)
    //这里还需要将sessionDescription通过websocket发送给对方，对方才能收到视频邀请
    wx.send(sessionDescription)
  }
)
```

如果对方收到了offer，那么就设置对方sessionDescription，并回传一个应答answer
```js
//这里的sessionDescription是通过offer传过来的
rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(sessionDescription));
rtcPeerConnection.createAnswer({iceRestart: true, offerToReceiveAudio: true, offerToReceiveVideo: true}).then(
  (sessionDescription) => {
    rtcPeerConnection.setLocalDescription(sessionDescription)
    //这里将sessionDescription通过websocket回传给邀请方
    wx.send(sessionDescription)
  }
)
```

发送方收到了answer应答后也同样设置对方sessionDescription
```js
rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(sessionDescription));
```

当STUN服务器获取到icecandidate后并通过websocket传过来了，我们就需要将对方candidate设置一下，对应第一步的onicecandidate监听事件
```js
rtcPeerConnection.addIceCandidate(candidate)
```

### js加解密哈希编码

1.  参考链接：

    [js中常见的数据加密与解密的方法](https://www.jianshu.com/p/95d8eeb8301f)

    [js中使用btoa和atob进行Base64的编码和解码](https://blog.csdn.net/yihanzhi/article/details/88356232)

    [JS实现Base64编码、解码，即window.atob，window.btoa功能](https://www.cnblogs.com/goloving/p/11374083.html)

2.  详解

  ```html
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
  <script src="https://cdn.bootcss.com/jsencrypt/3.0.0-beta.1/jsencrypt.js"></script>
  <script src="https://cdn.bootcss.com/crypto-js/3.1.9-1/crypto-js.js"></script>
  <script type="text/javascript">
      //md5
      var hash = md5("111111"); // "96e79218965eb72c92a549dd5a330112"
      console.log(hash);

      //RSA
      //公钥
      var PUBLIC_KEY = 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCADB+zg4Ou3fv6rY8159gw4fkJbuMPeM41ttw20leKjSKQWOgBixHJjXbkRvoMmUQkWq67xWzpMgKB7t8LIJx+n0dLP+6YDqbfFEJJ2i1Va4U1yJyGht0bEW0tpadKX3i5JwUwQIBPiC7VSWhtVyAKtzTYeun/fqpxTDAbulrj4QIDAQAB';
      //私钥
      var PRIVATE_KEY = 'MIICWwIBAAKBgQCADB+zg4Ou3fv6rY8159gw4fkJbuMPeM41ttw20leKjSKQWOgBixHJjXbkRvoMmUQkWq67xWzpMgKB7t8LIJx+n0dLP+6YDqbfFEJJ2i1Va4U1yJyGht0bEW0tpadKX3i5JwUwQIBPiC7VSWhtVyAKtzTYeun/fqpxTDAbulrj4QIDAQABAoGACj/Y2m0orBAfvHvfrpBtc9LlX2sX/g6M7wFr6hrMdWOBBJiL5Z0PTO39D3Ow +IjcyqN+62UiUnOK04IJKiJaSa1HNWagW2aAOblca1lYyYD6wlUotMV3bgk9lly0dD0lUTd8XWOmo1NdTEFW7y1OB4pYgMcT+iv4o0cr4sAtWisCQQCD6EmjEpMI5dcfZcrSXbT+WQGvdVCjAhivVMbNYeZq37ARt+9mTnaoA6Ss/QGQ5qvO9jMhx8x9/e8EfA+AX2rzAkEA+II3IXRXY3xbjDnK84kunlWpImH6XofN2V/TGEH1/Iqa909PHhuL4mhSt0iC70/y1g5kbmXyXE5s5gEsPqmC2wJAAU9uY9NMaJs33tT5Bcvuf1RNAvwsV+Iucpdp/iJJ0qf0LMjh9Oc0oIiguyMsP886x6yEZ4J/koTSOf4tfT31ZwJAMs28I5S7QNVtic9O1FbZNvlgKG1LWAP/a08RwsXJWiWj5KdMD2WmRVT6hAnI6s+3X1d15LPmxkQqMyNOPkk9PQJAJyPGWOjrCjzwojE0lN4NtS9brx6JbPy/sFkHX5LN8Xv45+XOKp14JgRcABTfWfvnnoWoWKha2cyJFlf8AdCIuQ==';
      //使用公钥加密
      var encrypt = new JSEncrypt();
        //encrypt.setPrivateKey('-----BEGIN RSA PRIVATE KEY-----'+PRIVATE_KEY+'-----END RSA PRIVATE KEY-----');
      encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');
      var encrypted = encrypt.encrypt('ceshi01');
      console.log('加密后数据:%o', encrypted);
      //使用私钥解密
      var decrypt = new JSEncrypt();
      //decrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');
      decrypt.setPrivateKey('-----BEGIN RSA PRIVATE KEY-----'+PRIVATE_KEY+'-----END RSA PRIVATE KEY-----');
      var uncrypted = decrypt.decrypt(encrypted);
      console.log('解密后数据:%o', uncrypted);

      //AES
      var aseKey = "12345678"     //秘钥必须为：8/16/32位
      var message = "我是一个密码";
      //加密 DES/AES切换只需要修改 CryptoJS.AES <=> CryptoJS.DES
      var encrypt = CryptoJS.AES.encrypt(message, CryptoJS.enc.Utf8.parse(aseKey), {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
      }).toString();
      console.log(encrypt); // 0Gh9NGnwOpgmB525QS0JhVJlsn5Ev9cHbABgypzhGnM
      //解密
      var decrypt = CryptoJS.AES.decrypt(encrypt, CryptoJS.enc.Utf8.parse(aseKey), {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
      }).toString(CryptoJS.enc.Utf8);
      console.log(decrypt); // 我是一个密码 

      //base64
      window.btoa('<script src="test.js"></script>'); 
      window.atob("PHNjcmlwdCBzcmM9InRlc3QuanMiPjwvc2NyaXB0Pg=="); 
      //不能使用window的情况
      var Base64 = {
        _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        _utf8_encode: function(string) {
          string = string.replace(/\r\n/g,"\n");
          let utftext = "";
          for (let n = 0; n < string.length; n++) {
            let c = string.charCodeAt(n);
            if (c < 128) {
              utftext += String.fromCharCode(c);
            } else if((c > 127) && (c < 2048)) {
              utftext += String.fromCharCode((c >> 6) | 192);
              utftext += String.fromCharCode((c & 63) | 128);
            } else {
              utftext += String.fromCharCode((c >> 12) | 224);
              utftext += String.fromCharCode(((c >> 6) & 63) | 128);
              utftext += String.fromCharCode((c & 63) | 128);
            }

          }
          return utftext;
        },
        _utf8_decode: function(utftext) {
          let string = "";
          let i = 0;
          let c = 0;
          let c1 = 0;
          let c2 = 0;
          let c3 = 0;
          while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            } else if((c > 191) && (c < 224)) {
              c2 = utftext.charCodeAt(i+1);
              string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
              i += 2;
            } else {
              c2 = utftext.charCodeAt(i+1);
              c3 = utftext.charCodeAt(i+2);
              string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
              i += 3;
            }
          }
          return string;
        },
        encode: function(input) {
          let output = "";
          let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
          let i = 0;
          input = this._utf8_encode(input);
          while (i < input.length) {
              chr1 = input.charCodeAt(i++);
              chr2 = input.charCodeAt(i++);
              chr3 = input.charCodeAt(i++);
              enc1 = chr1 >> 2;
              enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
              enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
              enc4 = chr3 & 63;
              if (isNaN(chr2)) {
                  enc3 = enc4 = 64;
              } else if (isNaN(chr3)) {
                  enc4 = 64;
              }
              output = output +
              this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
              this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
          }
          return output;
        },
        decode: function(input) {
          let output = "";
          let chr1, chr2, chr3;
          let enc1, enc2, enc3, enc4;
          let i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          while (i < input.length) {
              enc1 = this._keyStr.indexOf(input.charAt(i++));
              enc2 = this._keyStr.indexOf(input.charAt(i++));
              enc3 = this._keyStr.indexOf(input.charAt(i++));
              enc4 = this._keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 != 64) {
                  output = output + String.fromCharCode(chr2);
              }
              if (enc4 != 64) {
                  output = output + String.fromCharCode(chr3);
              }
          }
          output = this._utf8_decode(output);
          return output;
        }
      }
      // 定义字符串
      var string = 'Hello World!';
      // 加密
      var encodedString = Base64.encode(string);
      console.log(encodedString); // 输出: "SGVsbG8gV29ybGQh"
      // 解密
      var decodedString = Base64.decode(encodedString);
      console.log(decodedString); // 输出: "Hello World!"
  </script>
  ```

### 页面复制文字时自动加版权

1.  参考链接：

    [JS 实现页面复制文字时自动加版权](https://blog.csdn.net/lzuacm/article/details/88197591)

2.  详解：

    利用 chrome 查看网站触发某事件(如 copy)时的代码:

        F12-source-Event Listener Breakpoints-选择事件打勾-触发事件
    
        可以看到csdn使用copyright.js，百度即可，或搜索“js加版权”

    ```js
    $(document).on("copy", function (e) {
      var selected = window.getSelection();
      var selectedText = selected.toString().replace(/\n/g, "<br>");
      var copyFooter =
        "<br>---------------------<br>著作权归作者所有。<br>" +
        "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
        "作者：Bravo Yeung<br> 源地址：" +
        document.location.href +
        "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
      var copyHolder = $("<div>", {
        id: "temp",
        html: selectedText + copyFooter,
        style: { position: "absolute", left: "-99999px" },
      });
      //创建div，内容为选中的文字+附加的内容，位置设为不可见
      $("body").append(copyHolder);
      selected.selectAllChildren(copyHolder[0]); //把指定元素的所有子元素设为选中区域，并取消之前的选中区域
      window.setTimeout(function () {
        copyHolder.remove();
      }, 0);
    });
    ```

    ```js
    var ua = navigator.userAgent.toLowerCase();
    if (window.ActiveXObject) {
      /* 兼容IE */
      document.body.oncopy = function () {
        event.returnValue = false;
        var selectedText = document.selection.createRange().text;
        var pageInfo =
          "<br>---------------------<br>著作权归作者所有。<br>" +
          "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
          "作者：Bravo Yeung<br> 源地址：" +
          document.location.href +
          "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
        clipboardData.setData(
          "Text",
          selectedText.replace(/\n/g, "<br>") + pageInfo
        );
      };
    } else {
      function addCopyRight() {
        var body_element = document.getElementsByTagName("body")[0];
        var selection = window.getSelection();
        var pageInfo =
          "<br>---------------------<br>著作权归作者所有。<br>" +
          "商业转载请联系作者获得授权，非商业转载请注明出处。<br>" +
          "作者：Bravo Yeung<br> 源地址：" +
          document.location.href +
          "<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！";
        var copyText = selection.toString().replace(/\n/g, "<br>") + pageInfo;
        var newDiv = document.createElement("div");
        newDiv.style.position = "absolute";
        newDiv.style.left = "-99999px";
        body_element.appendChild(newDiv);
        newDiv.innerHTML = copyText;
        selection.selectAllChildren(newDiv);
        window.setTimeout(function () {
          body_element.removeChild(newDiv);
        }, 0);
      }
      document.oncopy = addCopyRight;
    }
    ```

### 文件内容读取

1. 参考链接：

   - [使用 JS 读取本地文本文件](https://www.cnblogs.com/yaotome/p/9002172.html)
   - [JS 前端 new FileReader 获取文件后显示乱码](https://www.jianshu.com/p/a8e57e51520a)
   - [UTF8 GB2312 之间的区别和关系](http://www.divcss5.com/html/h53.shtml)

2. 详解

   需要在 input 手动选择文件，GB2312 编码支持简体中文字，UTF-8 支持简体中文字、繁体中文字、英文、日文、韩文等语言，如出现中文乱码，可切换编码。

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <title>Document</title>
       <script type="text/javascript">
         function upload(input) {
           //支持chrome IE10
           if (window.FileReader) {
             var file = input.files[0];
             filename = file.name.split(".")[0];
             var reader = new FileReader();
             reader.onload = function () {
               console.log(this.result, this);
             };
             reader.readAsText(file, "gb2312");
           }
           //支持IE 7 8 9 10
           else if (typeof window.ActiveXObject != "undefined") {
             var xmlDoc;
             xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
             xmlDoc.async = false;
             xmlDoc.load(input.value);
             console.log(xmlDoc.xml);
           }
           //支持FF
           else if (
             document.implementation &&
             document.implementation.createDocument
           ) {
             var xmlDoc;
             xmlDoc = document.implementation.createDocument("", "", null);
             xmlDoc.async = false;
             xmlDoc.load(input.value);
             console.log(xmlDoc.xml);
           } else {
             alert("error");
           }
         }
       </script>
     </head>
     <body>
       <input type="file" onchange="upload(this)" />
     </body>
   </html>
   ```

### 自动化测试

1. 参考链接：

  - [不想痛失薪资普调和年终奖？试试自动化测试！（基础篇）](https://juejin.im/post/5eeae4f7e51d4574195ed982)

  - [Jest](https://www.jianshu.com/p/c2fef6b2820f)

  - [Jest Docs](https://jestjs.io/docs/en/getting-started)

  - [从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境](https://juejin.cn/post/6951649464637636622)

2. 详解

  - 测试类型

    - 单元测试（Unit Test）

      通常情况下，在公共函数/组件中一定要有单元测试来保证代码能够正常工作。单元测试也应该是项目中数量最多、覆盖率最高的。

    - 集成测试（Integration Test）

      集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。

      集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期。

    - UI 测试（UI Test）

      UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。

      端到端测试（E2E Test）则是将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。

  - 适合引入自动化测试的场景

    - 公共库类的开发维护
    - 中长期项目的迭代/重构
    - 引用了不可控的第三方依赖

  - 测试工具

    - 单元测试

      Mocha, Ava, Karma, Jest, Jasmine

    - 集成测试和 UI 测试

      ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils

  - 测试思想

    - TDD：Test-Driven Development（测试驱动开发）

      在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行

    - BDD：Behavior-Driven Development（行为驱动开发）

      使用自然语言来描述系统功能和业务逻辑，从而根据这些描述步骤进行系统自动化的测试

  - Jest使用

    ```js
    // sum.ts
    const sum = (a: number, b: number): number => { 
      return a + b;
    };
    // sum.test.ts
    describe('Should sum function run correctly', () => { 
      test('input: 1, 2 expect: 3', () => {
      // toBe:判断是否严格相等（使用Object .is) 
      expect(sum(1, 2)).toBe(3); // toXXX:匹配器 
      // toEqual:判断值是否相等 
      expect(sum(1, 2)).toEqual(3);
      // toBeDefined:判断是否被定义 
      expect(sum(1, 2)).toBeDefined();
      // toBeUndefined:判断是否未被定义
      expect(sum(1, 2)).not.toBeUndefined(); // not.toXXX:取反
      // toBeTruthy:判断是否为真值（true、非零数字、非空字符串、对象/数组等) 
      expect(sum(1, 2)).toBeTruthy();
      // toBeFalsy:判断是否为假值（false、0、空字符串、undefined/null 等) 
      expect(sum(1, 2)).not.toBeFalsy();
      // toBeG reate「Than:判断数值是否大于期望值 
      expect(sum(1, 2)).toBeGreaterThan(2);
      // toBeLessThan:判断数值是否小于期望值 
      expect(sum(1, 2)).toBeLessThan(4);
      // toBeGreaterThanO「Equal:判断数值是否大于等于期望值 
      expect(sum(1, 2)).toBeGreaterThan0rEqual(3);
      // toBeLessThanOrEqual:判断数值是否小于等于期望值 
      expect(sum(1, 2)).toBeLessThan0rEqual(3);
      expect(n).toBeNull(); //判断是否为null
      expect(value).toBeCloseTo(0.3); // 浮点数判断相等
      expect('Christoph').toMatch(/stop/); //正则表达式判断
      expect(['one','two']).toContain('one'); //包含判断ss
      });
    });
    ```

    ```js
    // showHello.ts
    const showHello: string = 'Hello,aaa';
    // showHello.test.ts
    describe('Should showHello defined correctly', () => { 
      it('expect to match "Hello"', () => { 
        expect(showHello).toMatch(/hello/i);
      });
      it('expect to match "aaa"', () => { 
        expect(showHello).toMatch('aaa');
      });
    });
    ```

    ```js
    // array.ts
    const array: [number] = [1, 2, 3, 4];
    // array.test.ts
    describe('Should array defined correctly',  () => {
      it('expect to contain 1', () => { 
        expect(array).toContain(l);
      });
      it('expect to contain 1', () => { 
        expect(new Set(array)).toContain(l); 
      });
    });
    ```

    ```js
    // compileAndroidCode.ts 
    const compileAndroidCode = Error => { 
      throw new Error('you are using the wrong JDK');
    };
    // compileAndroidCode.test.ts
    test('compiling android goes as expected', () => { 
      expect(compileAndroidCode).toThrow(); 
      expect(compileAndroidCode).toThrow(Error);
      expect(compileAndroidCode).toThrow('you are using the wrong JDK'); 
      expect(compileAndroidCode).toThrow(/JDK/);
    });
    ```

    ```js
    // 回调
    it('done', (done) => { 
      fetch('/example')
      .then((res) => {
        expect(res).toEqual({ code: '200', data: {}, msg: 'success' }); 
        done();
      })
      .catch((err) => { 
        done(err);
      });
    });
    ```

    ```js
    function sayHello(name) { 
      return `Hello ${name}`;
    }
    function say(callback) { 
      callback('aaa');
    }
    it('Test sayHello function run correctly', () => { 
      const mockFunc = jest.fn(sayHello);
      say(mockFunc);
      // toHaveBeenCalled:判断Mock函数是否被调用 
      expect(mockFunc).toHaveBeenCalled();
      // toHaveBeenCalledWith:判断Mock函数被调用时的参数 
      expect (mockFunc) .toHaveBeenCalledWith('aaa');
      say(mockFunc);
      // toHaveBeenCalledTimes:判断Mock函数被调用的次数 
      expect(mockFunc).toHaveBeenCalledTimes(2);
      // toHaveReturned:判断Mock函数是否有返回值 
      expect(mockFunc).toHaveReturned();
      // toHaveReturnedWith:判断Mock函数被调用时的返回值 
      expect (mockFunc) .toHaveReturnedWith('Hello'); 
    });
    ```

    ```js
    it('promise resolve' , () => {
      return fetch('/example').then((res) => { 
        expect(res).toEqual({ code: '200', data: {}, msg: 'success' });
      });
    });
    it('promise reject', () => { 
      expect.assertions(1);//保证1条断言被调用 
      return fetch('/example').catch((error) => { 
        expect(error).toMatch('error');
      });
    });
    it('async/await resolve', async () => { 
      const res = await fetch('/example'); 
      expect(res).toEqual({ code: '200', data: {}, msg: 'success' });
    });
    it('async/await reject', async () => { 
      expect.assertions(1);//保证1条断言被调用 
      try {
        await fetch('/example');
      } catch (err) { 
        expect(err).toMatch('error');
      }
    });
    ```

    ```js
    describe('outer', () => {
      console.log('describe outer-a');
      describe('describe inner 1', () => { 
        console.log('describe inner 1'); 
        test('test'  , () => {
          console.log('test for describe inner 1'); 
          expect(true).toEqual(true);
        });
      });
      console.log('describe outer-b');
      test('test 1', () => {
        console.log('test for describe outer'); 
        expect(true).toEqual(true);
      });
      describe('describe inner 2', () => { 
        console.log('describe inner 2'); 
        test('test for describe inner 2', () => { 
          console.log('test for describe inner 2'); 
          expect(false).toEqual(false);
        });
      });
      console.log('describe outer-c');
    });
    // describe outer-a 
    // describe inner 1 
    // describe outer-b 
    // describe inner 2 
    // describe outer-c 
    // test for describe inner 1 
    // test for describe outer 
    // test for describe inner 2
    ```

    ```js
    //推荐
    it('best method', () => {
      return expect(fetch('./example')).resolves.toEqual({ 
        code: '200', 
        data: {}, 
        msg: 'success'
      });
    });
    it('best method', () => {
      return expect(fetch('./example')).rejects.toMatch('error');
    });
    it('best method', async () => { 
      await expect(fetch('./example')).resolves.toEqual({ 
        code: '200', 
        data: {}, 
        msg: 'success' 
      });
    });
    it('best method', async () => { 
      await expect(fetch('./example')).rejects.toMatch('error');
    });
    ```

    ```js
    // 生 命 周 期 钩 子
    beforeAll(() => console.log('1 - beforeAll')); 
    afterAll(() => console.log('1 - afterAll')); 
    beforeEach(() => console.log('1 - beforeEach')); 
    afterEach(() => console.log('1 - afterEach')); 
    test('', () => console.log('1 - test')); 
    describe('Scoped / Nested block', () =>  {
      beforeAll(() => console.log('2 - beforeAll')); 
      afterEach(() => console.log('2 - afterAll')); 
      beforeEach(() => console.log('2 - beforeEach')); 
      afterEach(() => console.log('2 - afterEach')); 
      test('', () => console.log('2 - test'));
    });
    // 1 - beforeAll 
    // 1 - beforeEach 
    // 1 - test 
    // 1 - afterEach 
    // 2 - beforeAll 
    // 1 - beforeEach 
    // 2 - beforeEach 
    // 2 - test 
    // 2 - afterEach 
    // 1 - afterEach 
    // 2 - afterAll 
    // 1 - afterAll
    ```

  - vue3-jest-typescript

    * 安装:npm i @vue/test-utils@next jest vue-jest@next ts-jest -D
    * 项目根目录下新建 jest.config.js 文件

      ```js
      module.exports = {
        moduleFileExtensions: ['vue', 'js', 'ts'],
        preset: 'ts-jest',
        testEnvironment: 'jsdom',
        transform: {
          '^.+\\.vue$': 'vue-jest', // vue 文件用 vue-jest 转换
          '^.+\\.ts$': 'ts-jest' // ts 文件用 ts-jest 转换
        },
        // 匹配 __tests__ 目录下的 .js/.ts 文件 或其他目录下的 xx.test.js/ts xx.spec.js/ts
        testRegex: '(/__tests__/.*|(\\.|/)(test|spec))\\.(ts)$'
      }
      ```

    * 创建单元测试文件

      ```txt
      ├── src/
      └── tests/                           // 单元测试目录
          ├── Test.spec.ts                 // Test 组件测试
      ```

    * Test.vue

      ```html
      <template>
        <div class="test-container page-container">
          <div class="page-title">Unit Test Page</div>
          <p>count is: {{ count }}</p>
          <button @click="increment">increment</button>
        </div>
      </template>

      <script lang="ts">
        import { defineComponent, ref } from 'vue'

        export default defineComponent({
          name: 'Vuex',
          setup() {
            const count = ref<number>(0)
            const increment = () => {
              count.value += 1
            }
            return { count, increment }
          }
        })
      </script>
      ```

    * Test.spec.ts

      ```ts
      import { mount } from '@vue/test-utils'
      import Test from '../src/views/Test.vue'

      test('Test.vue', async () => {
        const wrapper = mount(Test)
        expect(wrapper.html()).toContain('Unit Test Page')
        expect(wrapper.html()).toContain('count is: 0')
        await wrapper.find('button').trigger('click')
        expect(wrapper.html()).toContain('count is: 1')
      })
      ```

    * 安装 @types/jest(解决IDE提示某些方法不存在（如 test、describe、it、expect等）):npm i @types/jest -D
    * 把 @types/jest 添加根目录下的 ts.config.json

      ```json
      {
        "compilerOptions": {
          ...
          "types": ["vite/client", "jest"]
        },
      }
      ```

    * 安装 eslint-plugin-jest(解除对jest的校验):npm i eslint-plugin-jest -D
    * 添加 eslint-plugin-jest 到 ESLint 配置文件 .eslintrc.js 中

      ```json
      module.exports = {
        ...
        extends: [
          ...
          'plugin:jest/recommended'
        ],
        ...
      }
      ```
    * 执行单元测试

      在根目录下 package.json 文件的 scripts 中，添加一条单元测试命令： "test": "jest"

      执行命令 npm run test 即可进行单元测试，jest 会根据 jest.config.js 配置文件去查找 \__tests__ 目录下的 .ts 文件或其他任意目录下的 .spec.ts 和 .test.ts 文件，然后执行单元测试方法。

    * 单元测试约束

      使用 husky 命令在 .husky 目录下自动创建 pre-push hook 文件，并在此执行单元测试命令 npm run test。

      npx husky add .husky/pre-push "npm run test $1"

      在 git push 时就能先进行单元测试了，只有单元测试全部通过，才能成功 push。

### jenkins自动部署

1. 参考链接：

  - [让Jenkins自动布署你的Vue项目](https://mp.weixin.qq.com/s/oiznlZ_4L_0Am2SNOonLDw)
  - [windows上Jenkins安装及其配置](https://www.cnblogs.com/fuxuepan/articles/9525623.html)
  - [jenkins_windows(七)：SVN自动触发项目构建的配置](https://blog.csdn.net/kongsuhongbaby/article/details/100170537)
  - [jenkins自动化部署安装部署（Windows-SVN版）](https://blog.csdn.net/dwn1209/article/details/73189080)
  - [Jenkins](https://www.jenkins.io/)

2. 详解

  1. 安装

    通过msi/exe/yum安装java/git/nginx/jenkins

  2. 配置jenkins

    安装后，默认localhost:8080打开登录页，根据提示找到并输入密码

    安装推荐插件，设置用户名、密码等

    安装插件：Rebuilder、SafeRestart、nodeJs，在“系统管理”-“全局配置”-“NodeJs别名”指定版本

  3. github配置

    jenkins创建一个新任务，关联 GitHub项目地址，选择构建环境并编写shell 命令(参考文章1)

    构建完成后，在“工作空间”多出打包后的dist目录

    到这里已经实现了本地代码提交到github，然后在jenkins上点击构建，可以拉取代码并且打包，下一步实现打包后的dist目录放到目标服务器上。

    系统管理-> 系统设置->Publish over SSH里设置服务器信息，填写完后点击test，出现Success说明配置成功

    在刚才的testJenkins工程中配置构建后操作，选择send build artificial over SSH，在构建中添加压缩dist目录命令

    填完后执行构建。成功后登录我们目标服务器发现test目录下有了要运行的文件，访问域名发现项目可以访问

    接下来实现开发本地push代码到github上后，触发Webhook，jenkins自动执行构建。jenkins安装Generic Webhook Trigger 插件，github添加触发器

    在刚才的testJenkins工程中点击构建触发器中选择Generic Webhook Trigger，填写token

    选择github项目中的Settings->Webhooks>add webhook，配置方式按(参考文章1)，选择在push代码时触发webhook，成功后会在下方出现一个绿色的小勾勾

  4. svn配置

    jenkins中生成用户授权的Token：“系统管理”-“管理用户”-“设置按钮”-“添加新token”-“生成”-保存token
    
    在jenkins项目配置中生成项目授权Token，勾选远程触发，勾选：轮询SCM，日程表为空，表示被post-commit钩子触发执行

    SVN服务端配置webhook：新建触发脚本vbs(参考文章3),svn管理器-选择要触发的仓库-右键Properties-“Hooks”-“Post-commit hook”-输入脚本(参考文章3)-“确定”

### GitHubActions自动部署

1. 参考链接：

  - [从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境](https://juejin.cn/post/6951649464637636622)

2. 详解

  * GitHub Actions

    GitHub Actions 是 GitHub 的持续集成服务，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器、发布到第三方服务等等，GitHub 把这些操作称为 actions。

  * 步骤

    1. 创建 GitHub 仓库

      * master 分支存储项目源代码
      * gh-pages 分支存储打包后的静态文件

        gh-pages 分支，是 GitHub Pages 服务的固定分支，可以通过 HTTP 的方式访问到这个分支的静态文件资源。

    2. 创建 GitHub Token

      创建一个有 repo 和 workflow 权限的 GitHub Token

      新生成的 Token 只会显示一次，保存起来，后面要用到。如有遗失，重新生成即可。

    3. 在仓库中添加 secret

      将上面新创建的 Token 添加到 GitHub 仓库的 Secrets 里，并将这个新增的 secret 命名为 VUE3_DEPLOY （名字无所谓，看你喜欢）。

      步骤：仓库 -> settings -> Secrets -> New repository secret。

      新创建的 secret VUE3_DEPLOY 在 Actions 配置文件中要用到，两个地方需保持一致！

    4. 项目根目录下创建 .github 目录

      ```txt
      ├── .github/
      └────── workflows/
                ├── deploy.yml
      ```

      deploy.yml
      ```yml
      name: deploy

      on:
        push:
          branches: [master] # master 分支有 push 时触发

      jobs:
        deploy:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v2

            - name: Setup Node.js v14.x
              uses: actions/setup-node@v1
              with:
                node-version: '14.x'

            - name: Install
              run: npm install # 安装依赖

            - name: Build
              run: npm run build # 打包

            - name: Deploy
              uses: peaceiris/actions-gh-pages@v3 # 使用部署到 GitHub pages 的 action
              with:
                publish_dir: ./dist # 部署打包后的 dist 目录
                github_token: ${{ secrets.VUE3_DEPLOY }} # secret 名
                user_name: ${{ secrets.MY_USER_NAME }}
                user_email: ${{ secrets.MY_USER_EMAIL }}
                commit_message: Update Vite2.x + Vue3.x + TypeScript Starter # 部署时的 git 提交信息，自由填写
      ```

  * 原理

    当有新提交的代码 push 到 GitHub 仓库时，就会触发 GitHub Actions，在 GitHub 服务器上执行 Action 配置文件里面的命令，例如：安装依赖、项目打包等，然后将打包好的静态文件部署到 GitHub Pages 上，最后，我们就能通过域名访问了。

### 隐藏滚动条与伪元素控制

1. 参考链接：

  - [JS控制伪元素的方法汇总](https://www.jb51.net/article/81984.htm)
  - [CSS实现隐藏滚动条但是可以滚动](https://blog.csdn.net/qq_36538012/article/details/89200121)

2. 详解

    * CSS实现隐藏滚动条但是可以滚动

      ```css
      body::-webkit-scrollbar {
        display: none;
      }
      ```

    * JS实现隐藏滚动条但是可以滚动(不可撤销)

      ```js
      document.styleSheets[0].insertRule('body::-webkit-scrollbar{display:none}',0)
      //或
      document.styleSheets[0].addRule('body::-webkit-scrollbar','display:none')
      ```

    * JS实现隐藏滚动条但是可以滚动(可撤销)

      ```js
      var style = document.createElement("style");
      document.head.appendChild(style);
      style.sheet.addRule('body::-webkit-scrollbar','display:none');
      //或
      style.sheet.insertRule('body::-webkit-scrollbar{display:none}', 0);

      document.head.removeChild(style);
      ```

### 浏览器识别

1. 参考链接：

  - [js获取谷歌浏览器版本](https://www.cnblogs.com/bldf/p/7054295.html)
  - [区别原生chrome 和以chrome为内核的360浏览器](https://www.cnblogs.com/yiliweichinasoft/p/3794681.html)
  - [五大主流浏览器及四大内核](https://www.jianshu.com/p/f4bf35898719)
  - [如何快速判断IE浏览器的版本？](https://www.jianshu.com/p/64a72962ae75)
  - [浏览器份额及其历史以及内核变迁总结](https://blog.csdn.net/lengye7/article/details/106181547)
  - [总结各大主流浏览器内核](https://blog.csdn.net/shijichang151/article/details/81197174)
  - [Can I use](https://caniuse.com/usage-table)
  - [JS判断IE浏览器版本](https://www.cnblogs.com/huzhuhua/p/10941779.html)
  - [【总结】浏览器 User-Agent 大全](https://blog.csdn.net/u012195214/article/details/78889602)
  - [userAgent大全](https://github.com/fynas/ua)
  - [JS获取常见手机品牌](https://www.jianshu.com/p/fcf9119045c1)
  - [js-获取用户移动端网络类型](https://www.cnblogs.com/liuqingxia/p/10319862.html)
  - [JS使用userAgent判断操作系统和浏览器类型](https://blog.csdn.net/ssrrxx111/article/details/47609471?utm_source=blogxgwz7)
  - [jquery.browser.js](https://cdn.bootcdn.net/ajax/libs/jquery-browser/0.1.0/jquery.browser.js)
  - [Android各版本 发布时间 及对应API（2020.9.9截至Android最新版本 11）](https://blog.csdn.net/weixin_41101173/article/details/79620490)
  - [windows操作系统各版本及对应年份](https://www.doc88.com/p-147637134657.html)
  - [Windows操作系统](https://baike.baidu.com/item/WINDOWS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/852149)
  - [Mac](https://baike.baidu.com/item/Mac/173)
  - [iPhone全系列型号+系统版本对应表](https://wenku.baidu.com/view/a590d00277a20029bd64783e0912a21614797fb3.html)
  - [iOS](https://baike.baidu.com/item/ios/45705)
  - [chromedriver与chrome最新版本对应表](https://www.jianshu.com/p/21123424c227)
  - [Firefox版本历史](https://zh.wikipedia.org/wiki/Firefox%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2)
  - [Internet Explorer](https://baike.baidu.com/item/Internet%20Explorer)
  - [Microsoft Edge](https://baike.baidu.com/item/Microsoft%20Edge/17511966)
  - [jQuery 历史发布版本时间表](https://blog.csdn.net/yetugeng/article/details/104960860)

2. 详解

  * 写在前面：样例见根目录/userAgent大全

  * userAgent包含的信息

    * 浏览器标识
    * 操作系统标识:Windows/Mac/Linux/SunOS/FreeBSD
    * 加密等级标识
      * N: 表示无安全加密
      * I: 表示弱安全加密
      * U: 表示强安全加密
    * 浏览器语言
    * 渲染引擎:Gecko、WebKit、KHTML、Presto、Trident、Tasman
    * 版本信息
    * 可能有手机品牌
    * 可能有网络状态
    * 可能有语言环境

  * 浏览器userAgent

    更多见根目录/userAgent大全/userAgentData.js
    ```txt
    Chrome：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36

    包含chrome字样，以及有自身浏览器标识，版本号为Chrome/**
    Opera：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 OPR/64.0.3417.54
    Edge：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393
    QQ浏览器："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3869.400"
    猎豹："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36 LBBROWSER"
    搜狗："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"
    2345："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3947.100 Safari/537.36 2345Explorer/10.9.0.20506"
    世界之窗：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36 TheWorld 7
    遨游："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 Maxthon/5.3.8.2000"
    百度："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 BIDUBrowser/8.7 Safari/537.36"
    UC："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4098.3 Safari/537.36"

    包含chrome字样，没有自身浏览器标识，版本号为Chrome/**
    360："Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"

    有Safari，没Chrome，版本号为Version/*
    Safari："Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"

    特征为Trident，版本号为MSIE *
    IE："Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)"

    特征为Gecko和Firefox，版本号为rv:*
    火狐："Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0"
    ```

    ```js
    let browser_match = /(edge)[\/]([\w.]+)/.exec(ua) ||
        /(opr)[\/]([\w.]+)/.exec(ua) ||
        /(qqbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(lbbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(metasr)[ ]([\w.]+)/.exec(ua) ||
        /(2345explorer)[\/]([\w.]+)/.exec(ua) ||
        /(theworld)[ ]([\w.]+)/.exec(ua) ||
        /(maxthon)[\/]([\w.]+)/.exec(ua) ||
        /(bidubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ucbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(micromessenger)[\/]([\w.]+)/.exec(ua) ||
        /(firefox)[\/]([\w.]+)/.exec(ua) ||
        /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(iemobile)[\/]([\w.]+)/.exec(ua) ||
        /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [];

    //browser: browser_match[5] || browser_match[3] || browser_match[1] || "unknown"
    ```

    判断移动端
    ```js
    function isMobileDevice(userAgent){
      return userAgent.includes('iphone') || userAgent.includes('android') || userAgent.includes('ipad') || userAgent.includes('ucweb') || userAgent.includes('blackberry') || userAgent.includes('symbianos') || userAgent.includes('windows phone') || userAgent.includes('opera mini') || userAgent.includes('micromessenger');
    }
    ```

  * 浏览器内核

    ```txt
    IE：Trident内核，又称IE内核
    Edge：IE内核---->Edge内核----->Blink内核
    Firefox：Gecko内核
    Safari：webkit内核
    Opera：Presto内核---->Webkit内核----->Blink内核
    Chrome：Webkit内核---->Blink内核
    Sansung Internet：Webkit内核---->Blink内核 （完全紧跟Chromium）
    UC浏览器：U3内核（实际基于Webkit）
    360浏览器、猎豹浏览器内核：IE+Chrome双内核
    搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）
    百度浏览器、世界之窗内核：IE+Chrome（极速模式）
    2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核
    ```

  * 判断360浏览器

    ```js
    function isChrome360() {
        if( navigator.userAgent.toLowerCase().indexOf('chrome') > -1 ) {
            var desc = navigator.mimeTypes['application/x-shockwave-flash'].description.toLowerCase();
            if( desc.indexOf('adobe') > -1 ) {
                return true;
            }
        }
        return false;
    }
    ```

  * 获取浏览器版本

    谷歌浏览器版本
    ```js
    function getChromeVersion() {
        var arr = navigator.userAgent.split(' ');
        var chromeVersion = '';
        for(var i=0;i < arr.length;i++){
            if(/chrome/i.test(arr[i]))
            chromeVersion = arr[i]
        }
        if(chromeVersion){
            return Number(chromeVersion.split('/')[1].split('.')[0]);
        } else {
            return false;
        }
    }
    ```

    ```js
    let browser_match = /(edge)[\/]([\w.]+)/.exec(ua) ||
        /(opr)[\/]([\w.]+)/.exec(ua) ||
        /(qqbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(lbbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(metasr)[ ]([\w.]+)/.exec(ua) ||
        /(2345explorer)[\/]([\w.]+)/.exec(ua) ||
        /(theworld)[ ]([\w.]+)/.exec(ua) ||
        /(maxthon)[\/]([\w.]+)/.exec(ua) ||
        /(bidubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ubrowser)[\/]([\w.]+)/.exec(ua) ||
        /(ucbrowser)[\/]([\w.]+)/.exec(ua) ||
        /(micromessenger)[\/]([\w.]+)/.exec(ua) ||
        /(firefox)[\/]([\w.]+)/.exec(ua) ||
        /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(iemobile)[\/]([\w.]+)/.exec(ua) ||
        /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [];

    //browser_match[4] || browser_match[2] || "0"
    ```

  * 各IE版本支持情况

    ```js
    var ie = (function () {
        if (document.all && !window.XMLHttpRequest) return 6;
        if (document.all && !document.querySelector) return 7;
        if (document.all && !document.addEventListener) return 8;
        if (document.all && !window.atob) return 9;
        if (document.all && document.addEventListener && window.atob) return 10;
        return 11;
    })();
    alert(ie)
    ```

  * 获取操作系统

    ```js
    let os_match = /(windows nt)[ ]([\w.]+)/.exec(ua) ||
        /(windows me)/.exec(ua) ||
        /(windows 98)/.exec(ua) ||
        /(android )([\w.]+)/.exec(ua) ||
        /(linux ppc64)/.exec(ua) ||
        /(linux ppc)/.exec(ua) ||
        /(linux i686)/.exec(ua) ||
        /(linux x86_64)/.exec(ua) ||
        /(ipad).*os ([\w.]+ )/.exec(ua) ||
        /(ipod).*os ([\w.]+ )/.exec(ua) ||
        /(iphone).*os ([\w.]+ )/.exec(ua) ||
        /(ppc mac os x )([\w.]+)/.exec(ua) ||
        /(intel mac os x )([\w.]+)/.exec(ua) ||
        /(freebsd)/.exec(ua) ||
        /(sunos i86pc)/.exec(ua) ||
        /(sunos sun4u)/.exec(ua) ||
        /(windows phone)(\sos)?([\s\w.]+)/.exec(ua) ||
        /(kindle)/.exec(ua) ||
        /(silk)/.exec(ua) ||
        /(cros)/.exec(ua) ||
        /(playbook)/.exec(ua) ||
        /(bb)/.exec(ua) ||
        /(blackberry)/.exec(ua) ||
        [];
    ```

  * 获取网络状态

    ```js
    let net_match = /(nettype)[\/]([\w.]+)/.exec(ua) || [];
    ```

  * 获取语言环境

    ```js
    let language_match = /(language)[\/]([\w.]+)/.exec(ua) ||
        /(zh-cn)/.exec(ua) ||
        /(zh-tw)/.exec(ua) ||
        /(zh-hk)/.exec(ua) ||
        /(en-us)/.exec(ua) ||
        /(\w\w-\w\w)/.exec(ua) ||
        [];
    ```

  * 获取手机型号

    ```js
    let model_match = /(build)[\/]([\w.]+)/.exec(ua) ||
        /(ipad)/.exec(ua) ||
        /(ipod)/.exec(ua) ||
        /(iphone)/.exec(ua) ||
        /(huawei)/.exec(ua) ||
        /(vivo)/.exec(ua) ||
        /(oppo)/.exec(ua) ||
        /(samsung)/.exec(ua) ||
        /(sony)/.exec(ua) ||
        /(nokia)/.exec(ua) ||
        /(htc)/.exec(ua) ||
        /(zte)/.exec(ua) ||
        /(lenovo)/.exec(ua) ||
        [];
    //model: model_match[2] || model_match[0] || "unknown"
    ``` 

  * 操作系统年份参考

    * android

      ```txt
      1	2008年9月23日
      1.1	2009年2月2日
      1.5	2009年4月17日
      1.6	2009年9月15日
      2.0.1	2009年12月3日
      2.1	2010年1月12日
      2.2.x	2010年1月12日
      2.3–2.3.2	2011年1月1日
      2.3.3–2.3.7	2011年9月2日
      3	2011年2月24日
      3.1	2011年5月10日
      3.2.x	2011年7月15日
      4.0.1–4.0.2	2011年10月19日
      4.0.3–4.0.4	2012年2月6日
      4.1	2012年6月28日
      4.1.1	2012年6月28日
      4.2-4.2.2	2012年11月
      4.3	2013年7月
      4.4	2013年7月24日
      4.4W	2014年6月
      5.0/5.1	2014年6月25日
      6	2015年5月28日
      7	2016年5月18日
      7.1	2016年12月
      8	2017年8月22日
      8.1	2017年12月5日
      9	2018年8月7日
      10	2019年9月3日
      10	2019年9月3日
      11	2020年9月9日
      ```

    * windows

      ```txt
      Windows1.0	1985-11-20
      Windows2.0	1987-11-1
      Windows3.0	1990-5-22
      Windows3.1	1992-3-18
      Windows3.2	1994-4-14
      WindowsNT3.1	1993-7-27
      WindowsNT3.5	1995-11-20
      Windows95	1995-8-28
      WindowsNT4.0	1996-7-29
      Windows98	1998-6-25
      Windows98SE	1999-6-10
      Windows2000	2000-2-17
      WindowsME	2000-9-14
      WindowsXP	2001-10-25
      WindowsServer2003	2003-4-24
      WindowsVista	2007-1-30
      WindowsServer2008	2008-2-27
      Windows7	2009-10-22
      WindowsServer2008R2	2009-10-22
      WindowsServer2012	2012-9-4
      Windows8	2012-10-26
      Windows8.1	2013-10-17
      Windows10	2015-7-29
      WindowsServer2016	2016-9-4
      WindowsServer2019	2018-10-25
      ```

    * mac

      ```txt
      OS X 10.0	2001年3月24日
      OS X 10.1	2001年9月25日
      OS X 10.2	2002年8月24日
      OS X 10.3	2003年10月24日
      OS X 10.4	2005年4月29日
      OS X 10.5	2007年10月26日
      OS X 10.6	2008年6月9日
      OS X 10.7	2011年6月7日
      OS X 10.8	2012年2月16日
      OS X 10.9	2013年6月10日
      OS X 10.10	2014年6月3日
      macOS Sierra	2016年6月14日
      macOS 10.13	2017年6月6日
      macOS 10.14	2018年6月5日
      macOS 10.15	2019年6月4日
      macOS 11.0	2020年06月23日
      ```

    * iphone

      ```txt
      iPhone2G	2007年1月9日
      iPhone3G	2008年06月10日
      iPhone3GS	2009年6月9日
      iPhone4	2010年6月8日
      iPhone4s	2011年10月04日
      iPhone5	2012年9月13日
      iPhone 5S及iPhone 5C	2013年9月10日
      第八代iPhone 6及iPhone 6 Plus	2014年9月10日
      第九代iPhone 6s及iPhone 6s Plus	2015年9月10日
      iPhone 7及iPhone 7 Plus	2016年9月8日
      iPhone 8，iPhone 8 Plus，iPhone X	2017年9月13日
      iPhone XR，iPhone XS，iPhone XS Max	2018年9月13日
      iPhone 11， iPhone 11 Pro，iPhone 11 Pro Max	2019年9月11日
      iPhone SE 2	2020年4月15日
      iPhone 12 mini，iPhone 12，iPhone 12 Pro， iPhone 12 Pro Max	2020年10月13日
      ```

    * IOS

      ```txt
      iPhone runs OS X	2007年10月17日
      iPhone OS	2008年3月6日
      iOS	2010年6月
      iOS 6	2012年6月
      iOS 7	2013年6月10日
      iOS 8	2014年6月3日
      iOS 9	2015年9月17日
      iOS 10	2016年9月14日
      iOS 11	2017年9月20日
      iOS 12	2018年9月18日
      iOS 13	2019年9月11日
      iOS 14	2020年9月17日
      ```

  * 浏览器年份参考

    * chrome

      ```txt
      Chrome v43-46	2015-08-19
      Chrome v46-50	2016-01-28
      Chrome v51-53	2016-08-04
      Chrome v56-58	2017-04-04
      Chrome v63-65	2018-03-02
      Chrome v71-73	2019-02-01
      ```

    * firefox

      ```txt
      Firefox 40.0	2015年8月11日
      Firefox 49.0	2016年9月20日
      Firefox 56.0	2017年9月28日
      Firefox 60.0	2018年5月9日
      Firefox 70.0	2019年10月22日
      Firefox 80.0	2020年8月25日
      Firefox 90.0	2021年6月15日
      ```

    * IE+Edge

      ```txt
      IE9	2011年3月14日	Windows Vista SP2和Windows 7/SP1
      IE10	2011年4月11日	Windows 7和Windows 8
      IE11	2013年6月26日	Windows 8.1
      Microsoft Edge20	2015-07-15	pdf
      Microsoft Edge38	2016-08-02	rtc,es2016
      Microsoft Edge40	2017-04-11	WebAssembly
      Microsoft Edge44	2018-2020	overflow-wrap和overscroll-behavior,Promise.prototype.finally
      Microsoft Edge83	2020-07-04	
      ```

  * 库年份参考

    * jquery

      ```txt
      1.7.2 (2012年3月21日)	新的事件API：.on()和.off()，而旧的API仍然支持。			
      1.8.3 (2012年11月13日)	重写Sizzle选择器引擎，改善动画和$(html, props)的灵活性。			
      1.9.1 (2013年2月4日)	移除弃用接口，清理代码			
      1.10.2 (2013年7月3日)	修复了1.9和2.0 beta版本周期的bug和差异			
      1.11.3 (2015年4月28日)	 			
      1.12.4 (2016年5月20日)	 			
      2.0.3 (2013年7月3日)	除去对IE 6-8的支持以提高性能，并降低文件大小			
      2.1.4 (2015年4月28日)	 			
      2.2.4 (2016年5月20日)	 			
      3.0.0 (2016年6月9日)	Deferred、$.ajax、$.when支持Promises/A+，令.data()兼容HTML5			
      3.1.1 (2016年9月23日)	加入jQuery.readyException，ready handler错误现在不会不显示了			
      3.2.1 (2017年3月20日)	增加了对检索<template>元素内容的支持，弃用了多种旧方法。			
      3.3.1 (2018年1月20日)	弃用旧函数，函数现在可以接受类，并支持其写成数组格式。			
      ```

### HTML5特性

1. 参考链接：

  - [10个好用的 HTML5 特性](https://juejin.im/post/6881779044505878542#heading-17)

2. 详解

  - details

    向用户提供按需查看详细信息的效果
    ```html
    <details>
      <summary>Click Here to get the user details</summary>
      <table>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>Location</th>
          <th>Job</th>
        </tr>
        <tr>
          <td>1</td>
          <td>Adam</td>
          <td>Huston</td>
          <td>UI/UX</td>
        </tr>
      </table>
    </details>
    ```

  - contenteditable属性

    在元素上设置以使内容可编辑的属性,适用于DIV，P，UL等元素。
    ```html
    <h2> Shoppping List(Content Editable) </h2>
    <ul class="content-editable" contenteditable="true">
        <li> 1. Milk </li>
        <li> 2. Bread </li>
        <li> 3. Honey </li>
    </ul>
    ```

  - mark

    高亮
    ```html
    <p> Did you know, you can <mark>"Highlight something interesting"</mark> just with an HTML tag? </p>
    ```

  - map area

    定义一个图像映射(一个可点击的链接区域)。可点击的区域可以是这些形状中的任何一个，矩形，圆形或多边形区域。如果不指定任何形状，则会考虑整个图像。
    ```html
    <div>
        <img src="circus.jpg" width="500" height="500" alt="Circus" usemap="#circusmap">

        <map name="circusmap">
            <area shape="rect" coords="67,114,207,254" href="elephant.htm">
            <area shape="rect" coords="222,141,318, 256" href="lion.htm">
            <area shape="rect" coords="343,111,455, 267" href="horse.htm">
            <area shape="rect" coords="35,328,143,500" href="clown.htm">
            <area shape="circle" coords="426,409,100" href="clown.htm">
        </map>
    </div>
    ```

  - data-* 属性

    用于存储页面或应用程序专用的自定义数据。 可以在 JavaScript 代码中使用存储的数据来创建更多的用户体验。

    属性名不能包含任何大写字母，并且必须在前缀“data-”之后至少有一个字符

    属性值可以是任何字符串

    ```html
    <h2> Know data attribute </h2>
    <div 
        class="data-attribute" 
        id="data-attr" 
        data-custom-attr="You are just Awesome!"> 
    I have a hidden secret!
    </div>
    ```

  - output 

    表示计算或用户操作的结果
    ```html
    <form oninput="x.value=parseInt(a.value) * parseInt(b.value)">
      <input type="number" id="a" value="0">
              * <input type="number" id="b" value="0">
                    = <output name="x" for="a b"></output>
    </form>
    ```

  - datalist

    包含了一组option元素，这些元素表示其它表单控件可选值,dataList的表现很像是一个select下拉列表，但它只是提示作用，并不限制用户在input输入框里输入什么
    ```html
    <form action="" method="get">
        <label for="fruit">Choose your fruit from the list:</label>
        <input list="fruits" name="fruit" id="fruit">
            <datalist id="fruits">
              <option value="Apple">
              <option value="Orange">
              <option value="Banana">
              <option value="Mango">
              <option value="Avacado">
            </datalist>
        <input type="submit">
    </form>  
    ```

  - input range

    给定一个滑块类型的范围选择器
    ```html
    <form method="post">
        <input 
            type="range" 
            name="range" 
            min="0" 
            max="100" 
            step="1" 
            value=""
            onchange="changeValue(event)"/>
    </form>
    <div class="range">
          <output id="output" name="result">  </output>
    </div>
    ```

  - meter

    用来显示已知范围的标量值或者分数值。
    ```html
    <label for="home">/home/atapas</label>
    <meter id="home" value="4" min="0" max="10">2 out of 10</meter><br>

    <label for="root">/root</label>
    <meter id="root" value="0.6">60%</meter><br>
    ```

  - progress

    进度条
    ```html
    <label for="file">Downloading progress:</label>
    <progress id="file" value="32" max="100"> 32% </progress>
    ```

  - input color

    颜色选择器
    ```html
    <input type="color" onchange="showColor(event)">
    <p id="colorMe">Color Me!</p>
    ```

### 微信扫码登录实现

1. 参考链接：

  - [某跳动面试官：说说微信扫码登录背后的实现原理？](https://juejin.im/post/6881597417637511181)

2. 详解

  1. 打开网页请求二维码
  2. 服务器生成uuid唯一标记和过期时间，存入redis数据库，uuid为key
  3. 服务器调用微信生成二维码接口，需要微信OAuth2.0协议参数(AppID 和 AppSecrect)
  4. 微信校验后返回二维码
  5. 手机已经登录过微信app，存在用户token，app服务器从中可以解密出userId
  6. 手机扫码发送登录请求(二维码信息+token)，app服务器验证app token，通过后app服务器调用网页服务器后端回调接口，传入临时票据code，同时app服务器向app确认信息
  7. app显示登录确认框
  8. 确认后再次发送请求(二维码信息+token+ack)，app服务器得到uuid和userId，redis中保存uuid-userId
  9. 接第6点，网页服务器拿到code，加上AppID和AppSecret请求微信开发平台换取access_token，则可请求获得用户账号数据
  10. 根据微信账号数据，找到注册时的用户的网站数据

### Dom转图片

1. 参考链接：

  - [Dom转图片](https://juejin.im/post/6881947480439652366)
  - [html2canvas github](https://github.com/niklasvh/html2canvas)
  - [html2canvas](http://html2canvas.hertzen.com/configuration/)
  - [dom-to-image github](https://github.com/tsayen/dom-to-image)

2. 详解

  1. html2canvas

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #poster{
                width: 700px; 
                height: 500px;
                background-color: green;
            }
        </style>
        <script type="text/javascript" src="http://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
        <script type="text/javascript">
            function takeScreenshot() {
                const node = document.getElementById('poster')
                html2canvas(node, {
                    useCORS: true,
                    height: node.offsetHeight,
                    width: node.offsetWidth,
                    scrollY: 0,
                    scrollX: 0
                }).then(async (canvas) => {
                    let oImg = new Image();
                    oImg.src = canvas.toDataURL();  // 导出图片
                    document.body.appendChild(oImg);  // 将生成的图片添加到body
                })
            }
        </script>
    </head>
    <body>
        <div id="poster">
            <input type="button" value="截图" onclick="takeScreenshot()">
        </div>
    </body>
    </html>
    ```

    注意事项：

    1. 生成的图片模糊

      导出的图片局部有些图片没有原图那么清晰，因为使用背景图片的原因。解决方法是直接使用标签

    2. 生成出来的图片有白色边框

      在配置项中设置backgroundColor: null

    3. 生成图片不显示

      图片素材出现跨域，在方法上调用时增加两个配置:allowTaint: true,useCORS: true 

      还有一个方法就是，把跨域的图片转为base64。

    4. PNG图片不透明

      用到透明的PNG图片作为背景图，最后生成的图片却并不透明，因为html2canvas生成的canvas背景颜色默认为白色。

      添加一个配置项就好:backgroundColor: 'transparent'

    5. 生成的图片加载闪动效果

      先让生成的图片隐藏，添加图片加载状态，等图片生成好以后再展示。

  2. dom-to-image

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #poster{
                width: 700px; 
                height: 500px;
                background-color: green;
            }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
        <script type="text/javascript">
            function filter (node) {
              return (node.tagName !== 'i');
            }
            function takeScreenshot() {
                const node = document.getElementById('poster')
                domtoimage.toPng(node)
                .then((dataUrl) => {
                    var img = new Image();
                    img.src = dataUrl;
                    document.body.appendChild(img);
                })
                .catch((error) => {
                    console.error('oops, something went wrong!', error);
                });
                //将节点转化为jpg格式的图片
                // domtoimage.toJpeg(node, { quality: 0.95 })
                // .then((dataUrl) => {
                //     var img = new Image();
                //     img.src = dataUrl;
                //     document.body.appendChild(img);
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //将节点转化为svg格式的图片，生成的图片的格式都是base64格式
                // domtoimage.toSvg(node, { filter: filter })
                // .then((dataUrl) => {
                //     var img = new Image();
                //     img.src = dataUrl;
                //     document.body.appendChild(img);
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //将节点转化为二进制格式，这个可以直接将图片下载
                // domtoimage.toBlob(node)
                // .then((blob) => {
                //   window.saveAs(blob, 'poster.png');
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
                //获取原始像素值，以Uint8Array 数组的形式返回，每4个数组元素表示一个像素点，即rgba值。这个方法也是挺实用的，可以用于WebGL中编写着色器颜色。
                // domtoimage.toPixelData(node)
                // .then((pixels) => {
                //   for (var y = 0; y < node.scrollHeight; ++y) {
                //     for (var x = 0; x < node.scrollWidth; ++x) {
                //       pixelAtXYOffset = (4 * y * node.scrollHeight) + (4 * x);
                //       /* pixelAtXY is a Uint8Array[4] containing RGBA values of the pixel at (x, y) in the range 0..255 */
                //       pixelAtXY = pixels.slice(pixelAtXYOffset, pixelAtXYOffset + 4);
                //     }
                //   }
                // })
                // .catch((error) => {
                //     console.error('oops, something went wrong!', error);
                // });
            }
        </script>
    </head>
    <body>
        <div id="poster">
            <input type="button" value="截图" onclick="takeScreenshot()">
        </div>
    </body>
    </html>
    ```

    注意事项：

    1. 用于生成图片的dom元素不能display:none或opacity:0。可以用z-index放到其它元素下面；或者用绝对定位，将其放到某个div容器的可视区之外，然后容器设置overflow:hidden
    2. 用于生成图片的dom元素的父元素们不能display:none
    3. 综合1、2，即用于生成图片的dom元素要本身是可见的，且能计算到尺寸值，但不需要出现在视野中
    4. 页面不能出现隐藏iframe的样式，例如iframe{display:none}
    5. 生成后的图，会自动追加到用于生成的dom元素后面，类名是dom2img-result，如果不想把图片的样子展示给用户，可将其样式设置为opacity:0

### nodejs版本管理

1. 参考链接：

  - [安装nvm之后node不可用，“node”不是内部或外部命令，也不是可运行的程序或批处理文件（ng）](https://www.cnblogs.com/cencenyue/p/10430618.html)
  - [windows npm -g 全局安装的命令找不到](https://blog.csdn.net/jizhuanfan0742/article/details/80910187)
  - [解决nvm 切换node版本切换不成功的问题](https://www.cnblogs.com/imMeya/p/14649938.html)

2. 详解

  nvm能够随意切换nodejs版本

  * 下载安装nvm(nvm-setup.zip)：https://github.com/coreybutler/nvm-windows/releases
  * 设置好环境变量，如：D:\nvm,D:\nvm\nodejs，如已安装过nodejs，会提示涵盖此版本
  * nvm v 查看到nvm版本号表示安装成功
  * nvm on 开启nvm
  * nvm use [version] 出现* [version] 表示目前使用版本
  * node -v 查看到node版本号表示成功

  * 命令大全

    * nvm arch [32|64]： 显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。
    * nvm install [version] [arch]：该可以是node.js版本或最新稳定版本latest。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为all以安装32和64位版本。在命令后面添加–insecure，可以绕过远端下载服务器的SSL验证。
    * nvm list [available]：列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为nvm ls [available]。
    * nvm on： 启用node.js版本管理。
    * nvm off： 禁用node.js版本管理(不卸载任何东西)
    * nvm proxy [url]： 设置用于下载的代理。留[url]空白，以查看当前的代理。设置[url]为none删除代理。
    * nvm node_mirror [url]：设置node镜像，默认为https://nodejs.org/dist/.。可以设置为淘宝的镜像https://npm.taobao.org/mirrors/node/
    * nvm npm_mirror [url]：设置npm镜像，默认为https://github.com/npm/npm/archive/。可以设置为淘宝的镜像https://npm.taobao.org/mirrors/npm/
    * nvm uninstall version： 卸载指定版本的nodejs。
    * nvm use [version] [arch]： 切换到使用指定的nodejs版本。可以指定32/64位[arch]。
    * nvm use <arch>：将继续使用所选版本，但根据提供的值切换到32/64位模式
    * nvm root [path]： 设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。
    * nvm version： 显示当前运行的nvm版本，可以简写为nvm v 

  注意：如果原本已经安装过nodejs，此时nodejs文件夹会移入nvm中，导致全局安装依赖后，无法找到命令，并且安装路径为原nodejs路径，因此需要设置npm安装全局依赖路径，并把环境变量设为此路径，才能使命令生效。见参考链接2。

  如果切换版本不成功，先尝试升级npm，在nvm的setting.txt加上以下内容：
  ```txt
  node_mirror: https://npm.taobao.org/mirrors/node/
  npm_mirror: https://npm.taobao.org/mirrors/npm/
  ```
  重新卸载安装指定版本nodejs，最后可考虑使用管理员命令行进行切换

### js监听url变化

1. 参考链接：

  - [如何监听URL的变化？](https://blog.csdn.net/liubangbo/article/details/103272393)

2. 详解

  * 监听hashchange:#改变触发

    ```js
    window.onhashchange=function(event){
      console.log(event);
    }
    //或者
    window.addEventListener('hashchange',function(event){
      console.log(event);
    })
    ```

  * 监听popstate:前进后退触发

    ```js
    window.addEventListener('popstate', function(event) {
        console.log(event);
    })
    ```

  * 自定义事件replaceState和pushState行为的监听:单页面应用url改变能生效

    ```js
    let historyEvent = function(type) {
        let origin = history[type];
        return function() {
            let result = origin.apply(this, arguments);
            let event = new Event(type);
            event.arguments = arguments;
            window.dispatchEvent(event);
            return result;
        };
    };
    history.pushState = historyEvent('pushState');
    history.replaceState = historyEvent('replaceState');

    window.addEventListener('replaceState', function(e) {
      console.log('THEY DID IT AGAIN! replaceState 111111');
    });
    window.addEventListener('pushState', function(e) {
      console.log('THEY DID IT AGAIN! pushState 2222222');
    });
    ```

### html5相关

1. 参考链接：

  - [基础面试题+答案、分类学习整理（良心制作）持续更新](https://juejin.cn/post/6914831351271292936)
  - [html5手机网站需要加的那些meta/link标签，html5 meta全解](https://blog.csdn.net/kongjiea/article/details/17092413)
  - [HTML5离线存储原理](https://www.cnblogs.com/zhangym118/archive/2016/09/22/5897056.html)

2. 详解

  1. 对 Html5 的离线储存资源管理和加载

    * 使⽤

      1. ⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性；

        ```html
        <!DOCTYPE HTML>
        <html manifest = "cache.manifest">
        ...
        </html>
        ```

      2. 在 cache.manifest ⽂件的编写离线存储的资源

        ```txt
        CACHE MANIFEST
        #v0.11

        CACHE:

        js/app.js
        css/style.css

        NETWORK:
        resourse/logo.png

        FALLBACK:
        / /offline.html
        ```
        * CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。
        * NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。
        * FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。

      3. 在离线状态时，操作 window.applicationCache 进⾏需求实现

        缓存立即执行
        ```js
        /*code1,简单粗暴的*/
        applicationCache.onupdateready = function(){
        　　applicationCache.swapCache();
        　　location.reload();
        };
        /*code2，缓存公用方法*/
        // var EventUtil = {
        // addHandler: function(element, type, handler) {
        // if (element.addEventListener) {
        // element.addEventListener(type, handler, false);
        // } else if (element.attachEvent) {
        // element.attachEvent(“on” + type, handler);
        // } else {
        // element["on" + type] = handler;
        // }
        // }
        // };
        // EventUtil.addHandler(applicationCache, “updateready”, function() { //缓存更新并已下载，要在下次进入页面生效
        // applicationCache.update(); //检查缓存manifest文件是否更新，ps:页面加载默认检查一次。
        // applicationCache.swapCache(); //交换到新的缓存项中，交换了要下次进入页面才生效
        // location.reload(); //重新载入页面
        // });
        ```

    * 概念

      在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如 果是第⼀次访问 app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏ 离线存储。

      如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。

    * 优势

      1. 离线浏览--用户可在离线时使用它们
      2. 速度--已经缓存的资源加载得更快
      3. 减少服务器负载--浏览器将只从服务器下载更改过的资源

    * 原理和环境

      HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

      引入manifest的页面,即使没有被列入缓存清单中，仍然会被用户代理缓存。因此，把.appcache文件更新下(如头部版本号)，刷新页面后才能更新离线HTML

    * 注意事项

      * 站点离线存储的容量限制是5M
      * 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存
      * 引用manifest的html必须与manifest文件同源，在同一个域下
      * 在manifest中使用的相对路径，相对参照物为manifest文件
      * CACHE MANIFEST字符串应在第一行，且必不可少
      * 系统会自动缓存引用清单文件的 HTML 文件
      * manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面
      * FALLBACK中的资源必须和manifest文件同源
      * 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。
      * 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问
      * 当manifest文件发生改变时，资源请求本身也会触发更新

  2. 严格模式与混杂模式

    !DOCTYPE声明位于⽂档中的最前⾯，处于 html 标签之前。告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档

    严格模式的排版和 JS 运作模式是 以该浏览器⽀持的最⾼标准运⾏

    在混杂模式中，⻚⾯以宽松的向后兼容的⽅式显示。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

  3. HTML全局属性

    * class :为元素设置类标识
    * data-* : 为元素增加⾃定义属性
    * draggable : 设置元素是否可拖拽
    * id : 元素 id ，⽂档内唯⼀
    * lang : 元素内容的的语⾔
    * style : ⾏内 css 样式
    * title : 元素相关的建议信息

  4. viewport的content属性作用

    ```html
    <meta name="viewport" content="" />
    width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；
    height – viewport 的高度 （范围从 223 到 10,000 ）
    user-scalable [yes | no]是否允许缩放
    initial-scale [数值] 初始化比例（范围从 > 0 到 10）
    minimum-scale [数值] 允许缩放的最小比例
    maximum-scale [数值] 允许缩放的最大比例
    target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性）
         -- dpi_value 一般是70-400//没英寸像素点的个数
         -- device-dpi设备默认像素密度
         -- high-dpi 高像素密度
         -- medium-dpi 中等像素密度
         -- low-dpi 低像素密度
    ```

    怎样处理 移动端 1px 被 渲染成 2px 问题?

    * 局部处理

      mate 标签中的 viewport 属性 ， initial-scale 设置为 1

      rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；

    * 全局处理

      mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5

      rem 按照设计稿标准⾛即可

  5. meta 相关

    ```html
    <!DOCTYPE html> <!--H5标准声明，使⽤ HTML5 doctype，不区分⼤⼩写-->
    <head lang=”en”> <!--标准的 lang 属性写法-->
    <meta charset=’utf-8′> <!--声明⽂档使⽤的字符编码-->
    <!-- 让IE浏览器用最高级内核渲染页面 还有用 Chrome 框架的页面用webkit 内核-->
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> <!--优先使用指定浏览器使用特定的文档模式-->
    <meta name=”description” content=”不超过150个字符”/> <!--⻚⾯描述-->
    <meta name=”keywords” content=””/> <!-- ⻚⾯关键词-->
    <meta name=”author” content=”name, email@gmail.com”/> <!--⽹⻚作者-->
    <meta name=”robots” content=”index,follow”/> <!--搜索引擎抓取-->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin-->
    <meta name=”apple-mobile-web-app-capable” content=”yes”/> <!--添加到主屏后的标 是否启⽤ WebApp 全屏模式，删除苹果默认的⼯具栏和菜单栏-->
    <meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
    <meta name=”renderer” content=”webkit”> <!-- 启⽤360浏览器的极速模式(webkit)-->
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge”> <!--避免IE使⽤兼容模式-->
    <meta http-equiv=”Cache-Control” content=”no-siteapp” /> <!--不让百度转码-->
    <meta name=”HandheldFriendly” content=”true”> <!--针对⼿持设备优化，主要是针对一些老的不识别viewport的浏览器-->
    <meta name=”MobileOptimized” content=”320″> <!--微软的⽼式浏览器-->
    <meta name=”screen-orientation” content=”portrait”> <!--uc强制竖屏-->
    <meta name=”x5-orientation” content=”portrait”> <!--QQ强制竖屏-->
    <meta name=”full-screen” content=”yes”> <!--UC强制全屏-->
    <meta name=”x5-fullscreen” content=”true”> <!--QQ强制全屏-->
    <meta name=”browsermode” content=”application”> <!--UC应⽤模式-->
    <meta name=”x5-page-mode” content=”app”> <!-- QQ应⽤模式-->
    <meta name=”msapplication-tap-highlight” content=”no”> <!--windows phone 设置⻚⾯不缓存-->
    <meta http-equiv=”pragma” content=”no-cache”>
    <meta http-equiv=”cache-control” content=”no-cache”>
    <meta http-equiv=”expires” content=”0″>
    ```

### css解决height:auto动画问题

1. 参考链接：

  - [CSS 奇技淫巧：动态高度过渡动画](https://juejin.cn/post/6917061427958120461)

2. 详解

  height:auto配transition不能产生动画效果，解决方法：

  1. max-height

    ```html
    <style type="text/css">
      div{
        position: relative;
      }
      p{
        width: 100px;
        position: absolute;
        top: 20px;
        left: 0px;
        max-height: 0;
        transition: max-height 0.3s linear;
        overflow: hidden;
      }
      div:hover p{
        max-height: 100px;
      }
    </style>
    <div>
      <h3>hover</h3>
      <p>testtesttesttesttesttesttesttesttesttest</p>
    </div>
    ```

  2. translateY

    ```html
    <style type="text/css">
        div{
          position: relative;
          background-color: #fff;
        }
        h3{
          background-color: #fff;
          margin: 0;
          position: relative;
          z-index: 1;
        }
        p{
          width: 100px;
          position: absolute;
          top: 20px;
          left: 0px;
          transition: all 0.3s linear;
          transform: translateY(-200%);
          height: 0;
          overflow: hidden;
        }
        div:hover p{
          transform: translateY(0);
          height: auto;
        }
      </style>
      <div>
      <h3>hover</h3>
      <p>testtesttesttesttesttesttesttesttesttest</p>
    </div>
    ```

### 在线预览文件

1. 参考链接：

  - [前端实现在线预览pdf、word、xls、ppt等文件](https://juejin.cn/post/6844903561017425927)

2. 详解

  * 免费纯前端方式实现在线预览word、excel、ppt最优选择微软在线预览（不可编辑）

    1. 微软的在线预览功能(必须是公共网络可访问的office文件)

      https://view.officeapps.live.com/op/view.aspx?src=http://www.xdocin.com/demo/demo.docx

    2. google的文档在线预览(需翻墙)

      https://docs.google.com/viewer?url=http://www.xdocin.com/demo/demo.docx

  * 利用后端将文件转为图片，前端以图片形式预览（可行方案）

  * 购买在线预览服务
  
    * [百度DOC文档服务](https://cloud.baidu.com/product/doc.html?track=cp:nsem%7Cpf:pc%7Cpp:doc%7Cpu:long%7Cci:%7Ckw:118945)
    
    * [永中](http://dcs.yozosoft.com/help.html)
    
    * [I DOC VIEW](https://www.idocv.com/docs.html)

    * [XDOC](http://www.xdocin.com/web.html#func)

  * 其它

    * [kkfileview](https://file.keking.cn/)

### 移动端开发指南

1. 参考链接：

  - [中高级前端必须注意的40条移动端H5坑位指南 | 网易三年实践](https://juejin.cn/post/6921886428158754829)

2. 详解

  * 调用系统功能

    ```html
    <a href="tel:10086">拨打电话给10086</a>
    <a href="sms:10086">发送短信给10086</a>
    <a href="mailto:a@aa.com">发送邮件给a@aa.com</a>
    <input type="file" accept="image/*"><!-- 选择指定类型文件 -->
    <input type="file" multiple><!-- 多选文件 -->
    ```

  * 忽略自动识别

    有些移动端浏览器会自动将数字字母符号识别为电话/邮箱并将其渲染成上述调用系统功能里的a

    ```html
    <!-- 忽略自动识别电话 -->
    <meta name="format-detection" content="telephone=no">
    <!-- 忽略自动识别电话和邮箱 -->
    <meta name="format-detection" content="telephone=no, email=no">
    ```

  * 弹出数字键盘

    ```html
    <!-- 纯数字带#和* -->
    <input type="tel">

    <!-- 纯数字 -->
    <input pattern="\d*">
    ```

  * 唤醒原生应用

    通过location.href与原生应用建立通讯渠道，这种页面与客户端的通讯方式称为URL Scheme，其基本格式为scheme://[path][?query]

    * scheme：应用标识，表示应用在系统里的唯一标识
    * path：应用行为，表示应用某个页面或功能
    * query：应用参数，表示应用页面或应用功能所需的条件参数

    URL Scheme一般由前端与客户端共同协商。唤醒原生应用的前提是必须在移动设备里安装了该应用，有些移动端浏览器即使安装了该应用也无法唤醒原生应用，因为它认为URL Scheme是一种潜在的危险行为而禁用它，像Safari和微信浏览器。还好微信浏览器可开启白名单让URL Scheme有效。

    若在页面引用第三方原生应用的URL Schema，可通过抓包第三方原生应用获取其URL。

    ```html
    <!-- 打开微信 -->
    <a href="weixin://">打开微信</a>

    <!-- 打开支付宝 -->
    <a href="alipays://">打开支付宝</a>

    <!-- 打开支付宝的扫一扫 -->
    <a href="alipays://platformapi/startapp?saId=10000007">打开支付宝的扫一扫</a>

    <!-- 打开支付宝的蚂蚁森林 -->
    <a href="alipays://platformapi/startapp?appId=60000002">打开支付宝的蚂蚁森林</a>
    ```

  * 禁止页面缩放

    具体见[html5相关](#html5相关),或css常见问题-flexible与高清屏

    ```html
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1">
    ```

  * 禁止页面缓存

    解析见网络相关问题-强制缓存和协商缓存

    ```html
    <meta http-equiv="Cache-Control" content="no-cache">
    ```

  * 禁止字母大写

    有时在输入框里输入文本会默认开启首字母大写纠正，就是输入首字母小写会被自动纠正成大写，直接声明autocapitalize=off关闭首字母大写功能和autocorrect=off关闭纠正功能。

    ```html
    <input autocapitalize="off" autocorrect="off">
    ```

  * 浏览器配置

    具体见[html5相关](#html5相关)
  
    针对Safari配置

    ```html
    <!-- 设置Safari全屏，在iOS7+无效 -->
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- 改变Safari状态栏样式，可选default/black/black-translucent，需在上述全屏模式下才有效 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black">

    <!-- 添加页面启动占位图 -->
    <link rel="apple-touch-startup-image" href="pig.jpg" media="(device-width: 375px)">

    <!-- 保存网站到桌面时添加图标 -->
    <link rel="apple-touch-icon" sizes="76x76" href="pig.jpg">

    <!-- 保存网站到桌面时添加图标且清除默认光泽 -->
    <link rel="apple-touch-icon-precomposed" href="pig.jpg">
    ```

    针对其他浏览器配置

    ```html
    <!-- 强制QQ浏览器竖屏 -->
    <meta name="x5-orientation" content="portrait">

    <!-- 强制QQ浏览器全屏 -->
    <meta name="x5-fullscreen" content="true">

    <!-- 开启QQ浏览器应用模式 -->
    <meta name="x5-page-mode" content="app">

    <!-- 强制UC浏览器竖屏 -->
    <meta name="screen-orientation" content="portrait">

    <!-- 强制UC浏览器全屏 -->
    <meta name="full-screen" content="yes">

    <!-- 开启UC浏览器应用模式 -->
    <meta name="browsermode" content="application">

    <!-- 开启360浏览器极速模式 -->
    <meta name="renderer" content="webkit">
    ```

  * 让:active有效，让:hover无效

    有些元素的:active可能会无效，而元素的:hover在点击后会一直处于点击状态，需点击其他位置才能解除点击状态。给body注册一个空的touchstart事件可将两种状态反转。

    ```html
    <body ontouchstart></body>
    ```

  * 优化弹性滚动

    在苹果系统上非body元素的滚动操作可能会存在卡顿，但安卓系统不会出现该情况。通过声明overflow-scrolling:touch调用系统原生滚动事件优化弹性滚动，增加页面滚动的流畅度。

    ```css
    body {
        -webkit-overflow-scrolling: touch;
    }
    .elem {
        overflow: auto;
    }
    ```

  * 禁止滚动传播

    移动端浏览器有一个奇怪行为:当页面包含多个滚动区域时，滚完一个区域后若还存在滚动动量则会将这些剩余动量传播到下一个滚动区域，造成该区域也滚动起来。这种行为称为滚动传播。若不想产生这种奇怪行为可直接禁止。

    ```css
    .elem {
        overscroll-behavior: contain;
    }
    ```

  * 禁止屏幕抖动

    对于一些突然出现滚动条的页面，可能会产生左右抖动的不良影响。在一个滚动容器里，打开弹窗就隐藏滚动条，关闭弹窗就显示滚动条，来回操作会让屏幕抖动起来。提前声明滚动容器的padding-right为滚动条宽度，就能有效消除这个不良影响。

    每个移动端浏览器的滚动条宽度都有可能不一致，甚至不一定占位置，通过以下方式能间接计算出滚动条的宽度。100vw为视窗宽度，100%为滚动容器内容宽度，相减就是滚动条宽度，妥妥的动态计算。

    ```css
    body {
        padding-right: calc(100vw - 100%);
    }
    ```

  * 禁止长按操作

    有时不想用户长按元素呼出菜单进行点链接、打电话、发邮件、保存图片或扫描二维码等操作，声明touch-callout:none禁止用户长按操作。

    有时不想用户复制粘贴盗文案，声明user-select:none禁止用户长按操作和选择复制。

    但声明user-select:none会让input和textarea无法输入文本，可对其声明user-select:auto排除在外。

    ```css
    * {
        /* pointer-events: none; */ /* 微信浏览器还需附加该属性才有效 */
        user-select: none; /* 禁止长按选择文字 */
        -webkit-touch-callout: none;
    }
    input,textarea {
        user-select: auto;
    }
    ```

  * 禁止字体调整

    旋转屏幕可能会改变字体大小，声明text-size-adjust:100%让字体大小保持不变。

    ```css
    * {
        text-size-adjust: 100%;
    }
    ```

  * 禁止高亮显示

    触摸元素会出现半透明灰色遮罩

    ```css
    * {
        -webkit-tap-highlight-color: transparent;
    }
    ```

  * 禁止动画闪屏

    在移动设备上添加动画，多数情况会出现闪屏，给动画元素的父元素构造一个3D环境就能让动画稳定运行了。

    ```css
    .elem {
        perspective: 1000;
        backface-visibility: hidden;
        transform-style: preserve-3d;
    }
    ```

  * 美化滚动条

    * ::-webkit-scrollbar：滚动条整体部分
    * ::-webkit-scrollbar-track：滚动条轨道部分
    * ::-webkit-scrollbar-thumb：滚动条滑块部分

    ```css
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
        background-color: transparent;
    }
    ::-webkit-scrollbar-track {
        background-color: transparent;
    }
    ::-webkit-scrollbar-thumb {
        border-radius: 3px;
        background-image: linear-gradient(135deg, #09f, #3c9);
    }
    ```

  * placeholder颜色

    ```css
    input::-webkit-input-placeholder {
        color: #66f;
    }
    ```

  * input文本偏上问题

    桌面端浏览器里声明line-height等于height就能解决，但移动端浏览器里还是未能解决，需将line-height声明为normal才行。

    ```css
    input {
        line-height: normal;
    }
    ```

  * 下拉选项右对齐

    ```css
    select option {
        direction: rtl;
    }
    ```

  * 修复点击无效

    在苹果系统上有些情况下非可点击元素监听click事件可能会无效，针对该情况只需对不触发click事件的元素声明cursor:pointer就能解决。

    ```css
    .elem {
        cursor: pointer;
    }
    ```

  * 文本换行

    若接口返回字段包含\n或br，千万别替换掉，可声明white-space:pre-line交由浏览器做断行处理。

    ```css
    * {
        white-space: pre-line;
    }
    ```

  * 描绘一像素边框

    详见css常见问题-flexible与高清屏

    ```css
    .elem {
        position: relative;
        width: 200px;
        height: 80px;
        &::after {
            position: absolute;
            left: 0;
            top: 0;
            border: 1px solid #f66;
            width: 200%;
            height: 200%;
            content: "";
            transform: scale(.5);
            transform-origin: left top;
        }
    }
    ```

  * 溢出文本省略号

    ```css
    .elem {
        width: 400px;
        line-height: 30px;
        font-size: 20px;
        &.sl-ellipsis {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        &.ml-ellipsis {
            display: -webkit-box;
            overflow: hidden;
            text-overflow: ellipsis;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
    }
    ```

  * 禁止点击穿透

    当用户执行第一次单击后会预留300ms检测用户是否继续执行单击，若是则执行缩放操作，若否则执行点击操作。

    在移动端浏览器上不使用click事件而使用touch事件是因为click事件有着明显的延迟，后续又出现fastclick。该解决方案监听用户是否做了双击操作，所以还是可直接使用click事件，而点击穿透就交给该fastclick自动判断。

    ```js
    import Fastclick from "fastclick";

    FastClick.attach(document.body);
    ```

  * 禁止滑动穿透

    移动端浏览器里出现弹窗时，若在屏幕上滑动能触发弹窗底下的内容跟着滚动。

    禁止body滚动又会引发其它问题：

      * 弹窗打开后内部内容无法滚动
      * 弹窗关闭后页面滚动位置丢失
      * Webview能上下滑动露出底色

    ```css
    body.static {
        position: fixed;
        left: 0;
        width: 100%;
    }
    ```
    ```js
    const body = document.body;
    const openBtn = document.getElementById("open-btn");
    const closeBtn = document.getElementById("close-btn");
    openBtn.addEventListener("click", e => {
        e.stopPropagation();
        const scrollTop = document.scrollingElement.scrollTop;
        body.classList.add("static");
        body.style.top = `-${scrollTop}px`;
    });
    closeBtn.addEventListener("click", e => {
        e.stopPropagation();
        body.classList.remove("static");
        body.style.top = "";
    });
    ```

  * 支持往返刷新

    点击移动端浏览器的前进按钮或后退按钮，有时不会自动执行旧页面的JS代码，这与往返缓存有关。

    往返缓存指浏览器为了在页面间执行前进后退操作时能拥有更流畅体验的一种策略，以下简称BFCache。

    该策略具体表现为：当用户前往新页面前将旧页面的DOM状态保存在BFCache里，当用户返回旧页面前将旧页面的DOM状态从BFCache里取出并加载。大部分移动端浏览器都会部署BFCache，可大大节省接口请求的时间和带宽。

    若在Vue SPA上使用keep-alive也不能让页面刷新，可将接口请求放到beforeRouteEnter()里。

    解决方案1
    ```js
    // 在新页面监听页面销毁事件
    window.addEventListener("onunload", () => {
        // 执行旧页面代码
    });
    ```

    解决方案2:pageshow事件在每次页面加载时都会触发，无论是首次加载还是再次加载都会触发，这就是它与load事件的区别。pageshow事件暴露的persisted可判断页面是否从BFCache里取出。
    ```js
    window.addEventListener("pageshow", e => e.persisted && location.reload());
    ```

  * 解析有效日期

    在苹果系统上解析YYYY-MM-DD HH:mm:ss这种日期格式会报错Invalid Date，但在安卓系统上解析这种日期格式完全无问题。可用YYYY/MM/DD HH:mm:ss这种日期格式

    ```js
    const date = "2019-03-31 21:30:00";
    new Date(date.replace(/\-/g, "-"));
    ```

  * 修复高度坍塌

    出现以下三个条件时,输入框失焦后页面未回弹:
    * 页面高度过小
    * 输入框在页面底部或视窗中下方
    * 输入框聚焦输入文本

    只要保持前后滚动条偏移量一致就不会出现上述问题。在输入框聚焦时获取页面当前滚动条偏移量，在输入框失焦时赋值页面之前获取的滚动条偏移量，这样就能间接还原页面滚动条偏移量解决页面高度坍塌。

    ```js
    const input = document.getElementById("input");
    let scrollTop = 0;
    input.addEventListener("focus", () => {
        scrollTop = document.scrollingElement.scrollTop;
    });
    input.addEventListener("blur", () => {
        document.scrollingElement.scrollTo(0, this.scrollTop);
    });
    ```

  * 修复输入监听

    在苹果系统上的输入框输入文本，keyup/keydown/keypress事件可能会无效。当输入框监听keyup事件时，逐个输入英文和数字会有效，但逐个输入中文不会有效，需按回车键才会有效。此时可用input事件代替输入框的keyup/keydown/keypress事件。

  * 简化回到顶部

    编写一个返回顶部函数需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，一行核心代码就能搞定。

    * scrollIntoView

      * behavior：动画过渡效果，默认auto无，可选smooth平滑
      * inline：水平方向对齐方式，默认nearest就近对齐，可选start顶部对齐、center中间对齐和end底部对齐
      * block：垂直方向对齐方式，默认start顶部对齐，可选center中间对齐、end底部对齐和nearest就近对齐

    ```js
    const gotopBtn = document.getElementById("gotop-btn");
    openBtn.addEventListener("click", () => document.body.scrollIntoView({ behavior: "smooth" }));
    ```

  * 简化懒加载

    编写一个懒性加载函数也同样需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，该函数无需监听容器的scroll事件，通过浏览器自身机制完成滚动监听。

    懒加载
    ```html
    <img data-src="pig.jpg">
    <!-- 很多<img> -->
    ```
    ```js
    const imgs = document.querySelectorAll("img.lazyload");
    const observer = new IntersectionObserver(nodes => {
        nodes.forEach(v => {
            if (v.isIntersecting) { // 判断是否进入可视区域
                v.target.src = v.target.dataset.src; // 赋值加载图片
                observer.unobserve(v.target); // 停止监听已加载的图片
            }
        });
    });
    imgs.forEach(v => observer.observe(v));
    ```

    下拉加载
    ```html
    <ul>
        <li></li>
        <!-- 很多<li> -->
    </ul>
    <!-- 也可将#bottom以<li>的形式插入到<ul>内部的最后位置 -->
    <div id="bottom"></div>
    ```
    ```js
    const bottom = document.getElementById("bottom");
    const observer = new IntersectionObserver(nodes => {
        const tgt = nodes[0]; // 反正只有一个
        if (item.isIntersecting) {
            console.log("已到底部，请求接口");
            // 执行接口请求代码
        }
    })
    bottom.observe(bottom);
    ```

  * 优化扫码识别

    通常移动端浏览器都会配备长按二维码图片识别链接的功能，但长按二维码可能无法识别或错误识别。

    二维码生成方式有以下三种:

      * 使用img渲染
      * 使用svg渲染
      * 使用canvas渲染

    大部分移动端浏览器只能识别img渲染的二维码，若使用SVG和Canvas的方式生成二维码，那就想方设法把二维码数据转换成Base64再赋值到img的src上。

    一个页面可能存在多个二维码，若长按二维码只能识别最后一个，那只能控制每个页面只存在一个二维码。

  * 自动播放媒体

    少部分浏览器autoplay即可

    一般浏览器需js控制
    ```js
    const audio = document.getElementById("audio");
    const video = document.getElementById("video");
    audio.play();
    video.play();
    ```

    微信浏览器需监听其应用SDK加载完成才能触发
    ```js
    document.addEventListener("WeixinJSBridgeReady", () => {
        // 执行上述媒体自动播放代码
    });
    ```

    苹果系统上明确规定用户交互操作开始后才能播放媒体，未得到用户响应会被Safari自动拦截，因此需监听用户首次触摸操作并触发媒体自动播放，而该监听仅此一次。
    ```js
    document.body.addEventListener("touchstart", () => {
        // 执行上述媒体自动播放代码
    }, { once: true });
    ```

### 如何找到当前页面出现次数最多的HTML标签

1. 参考链接：

  - [山月最近的面试总结](https://juejin.cn/post/6922229465468633095)

2. 详解

  * 列出所有标签

    1. document.querySelector('*')，标准规范实现
    2. $$('*')，devtools 实现
    3. document.all，非标准规范实现

  * 实现

    使用 document.querySelectorAll 实现

    ```js
    const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)

    function getFrequentTag () {
      const tags = [...document.querySelectorAll('*')].map(x => x.tagName).reduce((o, tag) => { 
        o[tag] = o[tag] ? o[tag] + 1 : 1;
        return o
      }, {})
      return maxBy(Object.entries(tags), tag => tag[1])
    }
    ```

    DOM 的体积过大会影响页面性能，假如你想在用户关闭页面时统计（计算并反馈给服务器）当前页面中元素节点的数量总和、元素节点的最大嵌套深度以及最大子元素个数，请用 JS 配合原生 DOM API 实现该需求（不用考虑陈旧浏览器以及在现代浏览器中的兼容性，可以使用任意浏览器的最新特性；不用考虑 shadow DOM）。比如在如下页面中运行后：
    ```html
    <html>
      <head></head>
      <body>
        <div>
          <span>f</span>
          <span>o</span>
          <span>o</span>
        </div>
      </body>
    </html>
    ```
    ```json
    {
      totalElementsCount: 7,
      maxDOMTreeDepth: 4,
      maxChildrenCount: 3
    }
    ```

    ```js
    window.onload = function() {
      let outer = document.querySelectorAll('*');
      let totalElementsCount = 0;
      let maxDOMTreeDepth = 0;
      let maxChildrenCount = 0;
      //console.log(outer)
      let elementQueue = [outer[0]];
      let htmlObject = {
        tagName: '',
        deep: 0,
        childrenCount: 0
      };
      let nodeInfo = [];
      let deepInfo = [];
      let childrenCountInfo = [];
      let currentDeep = 1;

      while(elementQueue.length != 0){
        for(let i = 0;i < elementQueue.length;i++){
          let info = JSON.parse(JSON.stringify(htmlObject));
          info.tagName = elementQueue[i].tagName;
          info.deep = currentDeep;
          info.childrenCount = elementQueue[i].childElementCount;
          nodeInfo.push(info);
          deepInfo.push(info.deep);
          childrenCountInfo.push(info.childrenCount);
        }
        //console.log(nodeInfo)
        let newQueue = [];
        for(let i = 0;i < elementQueue.length;i++){
          if(elementQueue[i].hasChildNodes()){
            //console.log(elementQueue[i].children)
            Array.prototype.push.apply(newQueue,elementQueue[i].children);
          }
        }
        //console.log(newQueue)
        elementQueue = newQueue;
        currentDeep++;
      }
      deepInfo = deepInfo.sort((a,b)=>(b-a));
      childrenCountInfo = childrenCountInfo.sort((a,b)=>(b-a));

      totalElementsCount = nodeInfo.length;
      maxDOMTreeDepth = deepInfo[0];
      maxChildrenCount = childrenCountInfo[0];
      console.log({
        totalElementsCount: totalElementsCount,
        maxDOMTreeDepth: maxDOMTreeDepth,
        maxChildrenCount: maxChildrenCount
      })
    }
    ```

### 导入ics日历日程

1. 参考链接：

  - [制作ics日历提醒文件](https://www.jianshu.com/p/237c336f0b7f)

2. 详解

  ```txt
  Calendar文件模板
  SUMMARY：主题，修改称自己想要的即可
  日期：20191112替换成开始日期，20191113提传承结束日期
  UID：如果需要添加多个的话UID一直增加就可以了
  多个时间的就增加从BEGIN:VEVENT到END:VEVENT中间的就可以了
  VALARM可以加也可以不加
  ```

  ```ics
  BEGIN:VCALENDAR
  METHOD:PUBLISH
  VERSION:2.0
  X-WR-CALNAME:个人
  PRODID:-//Apple Inc.//Mac OS X 10.14.5//EN
  X-APPLE-CALENDAR-COLOR:#34AADC
  X-WR-TIMEZONE:Asia/Shanghai
  CALSCALE:GREGORIAN
  BEGIN:VEVENT
  CREATED:20191112T155023Z
  UID:0
  RRULE:FREQ=YEARLY;INTERVAL=1
  DTEND;VALUE=DATE:20191113
  TRANSP:TRANSPARENT
  X-APPLE-TRAVEL-ADVISORY-BEHAVIOR:AUTOMATIC
  SUMMARY:生日
  LAST-MODIFIED:20191112T160624Z
  DTSTAMP:20191112T155045Z
  DTSTART;VALUE=DATE:20191112
  SEQUENCE:0
  BEGIN:VALARM
  X-WR-ALARMUID:4A310C10-E78D-4B17-95F4-005E529D0E7D
  UID:1
  TRIGGER;VALUE=DATE-TIME:19760401T005545Z
  ACTION:NONE
  END:VALARM
  BEGIN:VALARM
  X-WR-ALARMUID:53D56D83-9C94-4F29-9436-93878ACE68A5
  UID:2
  TRIGGER:PT9H
  ATTACH;VALUE=URI:Chord
  ACTION:AUDIO
  END:VALARM
  END:VEVENT
  END:VCALENDAR
  ```

  ```ics
  BEGIN:VCALENDAR
  METHOD:PUBLISH
  VERSION:2.0
  X-WR-CALNAME:2021 消费者权益日发布会。
  PRODID:-//Apple Inc.//Mac OS X 10.14.5//EN
  X-APPLE-CALENDAR-COLOR:#34AADC
  X-WR-TIMEZONE:Asia/Shanghai
  CALSCALE:GREGORIAN
  BEGIN:VEVENT
  CREATED:20210314T155023Z
  UID:0
  DTEND;VALUE=DATE:20210315T110000
  TRANSP:TRANSPARENT
  X-APPLE-TRAVEL-ADVISORY-BEHAVIOR:AUTOMATIC
  LOCATION:微信视频号、抖音、斗鱼、京东、天猫各大平台同步直播
  DESCRIPTION: 观看2021 消费者权益日发布会。
  URL;VALUE=URI:https://xiaofeizhequanyi
  SUMMARY:2021 消费者权益日发布会
  LAST-MODIFIED:20210315T160624Z
  DTSTAMP:20210315T155045Z
  DTSTART;VALUE=DATE:20210315T100000
  SEQUENCE:0
  BEGIN:VALARM
  X-WR-ALARMUID:4A310C10-E78D-4B17-95F4-005E529D0E7D
  UID:1
  TRIGGER;VALUE=DATE-TIME:19760401T005545Z
  ACTION:NONE
  END:VALARM
  BEGIN:VALARM
  X-WR-ALARMUID:53D56D83-9C94-4F29-9436-93878ACE68A5
  UID:2
  TRIGGER:-PT10M
  ATTACH;VALUE=URI:Chord
  ACTION:AUDIO
  END:VALARM
  END:VEVENT
  END:VCALENDAR
  ```

  注意：
  
    * 时区没有Asia/Beijing，但有Asia/Shanghai
    * 安卓手机可能无法删除导入后的日程，因为导入后文件变为只读，可考虑删除导入日程的账号

### 流程可视化

1. 参考链接：

  - [滴滴开源 LogicFlow：专注流程可视化的前端框架](https://juejin.cn/post/6933413834682007560)
  - [LogicFlow 官方网站](http://logic-flow.org/)
  - [LogicFlow github](https://github.com/didi/LogicFlow)

2. 详解

  * 市场横向对比-BPMN.js、X6、Jsplumb、G6-editor

    * activiti 作为工作流引擎提供了前后端的解决方案，简单二次开发就可以部署一套业务流程的管理平台
    * Bpmn.js：基于 BPMN2.0 规范，设计的流程图编辑器
    * G6：antv 旗下专注图形可视化，各类分析类图表。比如生态树、脑图、辐射图、缩进图等等
    * X6：图编辑引擎，核心能力是节点、连线和画布。不仅支持了流程图，还有 Dag 图、ER 图

    * BMPN.js、Jsplumb 的拓展能力不足，自定义节点支持成本很高；只能全量引入，各系统无法按需引入
    * 与后端配套的流程引擎适配，成本较高。均不支持数据转换、不支持流程的校验等业务定制需求。
    * 文档、示例不健全。X6 和 BPMN 的文档不健全，示例少（2020 初调研结论）

### 基准URL与刷新重定向

1. 参考链接：

  - [HTML <base> 标签的 href 属性](https://www.w3school.com.cn/tags/att_base_href.asp)
  - [5个不常提及的HTML技巧](https://mp.weixin.qq.com/s/Sr6GwTdoQrMoyBZ5BWmo_g)

2. 详解

  使用base后，如果不是完整链接，则变为base+后缀的链接，对于完整链接则不变
  ```html
  <head>
    <base href="https://www.weibo.com/" target="_blank">  
  </head>
  <body>
    <a href="jackiechan">成龙</a>
    <a href="kukoujialing">贾玲</a>
    <img src="eg_smile.gif" />
    <a href="https://www.baidu.com/">百度</a>
  </body>
  ```

  刷新重定向
  ```html
  <meta http-equiv="refresh" content="4; URL='https://www.baidu.com'" />
  ```

### 阿里云直播

1. 参考链接：

  - [阿里云文档](https://help.aliyun.com/document_detail/199326.html)
  - [利用ffmpeg实现rtmp推流](https://www.jianshu.com/p/c141fc7881e7)
  - [视频和视频帧：ffmpeg的RTMP推流](https://zhuanlan.zhihu.com/p/73984438)
  - [前端视频插件Aliplayer播放器简单使用（基于地址播放）](https://www.cnblogs.com/phper12580/p/10748418.html)

2. 详解

  * 视频直播架构

    主播obs/服务方服务器 推视频流到直播中心(阿里云、斗鱼、虎牙等)，直播中心包含各种视频服务(直播、点播、导播、截图、转码、流量监控、安全等)，再通过rtmp协议拉流到各cdn节点，播放端通过HLS/HTTP-FLV/RTMP拉流播放

  * 应用场景

    在线教育、娱乐直播、电商带货、赛事直播、广电新媒体、企业直播

  * 基本概念

    * 推流

      推流是把采集阶段封装好的音视频直播流推送到阿里云直播服务中心的过程。

    * 拉流

      拉流是将第三方直播流地址拉取到阿里直播中心进行加速分发的过程。

    * 播流

      播流是将直播服务中心已有直播内容，分发到播放器进行播放过程。

    * 窄带高清™

      窄带高清™技术，根据画面内容进行编码优化，使用户在同等带宽情况下观看更清晰的视频。从人眼视觉模型出发，在节省码率的同时，也能提供更加清晰的观看体验，同等视频质量下最高节省20%~40%带宽。

    * 推流域名

      推流域名是用于推送直播流的域名，为必选配置，您必须在使用直播服务前完成该域名的注册并备案。经过解析域名（CNAME解析）、关联推播流域名和配置鉴权（可选）操作后，可以使用控制台的地址生成器生成对应的推流地址。

    * 播流域名

      播流域名是用于拉取直播流的域名，为必选配置，您必须在使用直播服务前完成该域名的注册并备案。经过解析域名（CNAME解析）、关联推播流域名和配置鉴权（可选）操作后，可以使用控制台的地址生成器生成对应的播放地址。

    * CNAME域名

      CNAME域名是在阿里云控制台添加加速域名后，给您分配的一个域名。该CNAME域名的形式为*.*kunlun*.com。 您需要在您的DNS解析服务商添加一条CNAME记录，将自己的加速域名指向*.*kunlun*.com的域名。记录生效后，域名解析的工作就正式转向阿里云直播，该域名所有的请求都将转向阿里云直播的边缘节点，达到加速效果。

    * H.264

      H.264是由ITU-T视频编码专家组（VCEG）和ISO/IEC动态图像专家组（MPEG）联合组成的联合视频组（JVT）提出的，高度压缩数字视频编解码器标准，同时也是MPEG-4第十部分。拥有低码率、图像质量高、容错能力强和网络适应性强等优点。

    * H.265

      H.265是ITU-T视频编码专家组（VCEG）继H.264之后所制定的新的视频编码标准。H.265标准围绕着现有的视频编码标准H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。

    * 直播地址

      直播地址包含推流地址和播放地址，由域名、AppName、StreamName和鉴权串（可选）组成，每个域名下可以创建多个应用，每个应用下可以创建多个直播流。控制台提供地址生成器功能，支持快速生成推流地址和播放地址，可用于第三方软件（如OBS）推流。

    * RTMP

      RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。是Adobe公司开发的一个基于TCP的应用层协议，也就是说，RTMP是和HTTP/HTTPS一样，是应用层的一个协议族。RTMP在TCP通道上一般传输的是flv 格式流。请注意，RTMP是网络传输协议，而flv则是视频的封装格式。

      * RTMP工作在TCP之上，默认使用端口1935，这个是基本形态
      * RTMPE在RTMP的基础上增加了加密功能
      * RTMPT封装在HTTP请求之上，可穿透防火墙
      * RTMPS类似RTMPT，增加了TLS/SSL的安全功能
      * RTMFP使用UDP进行传输的RTMP

  * 准备工作

    实名认证的阿里云账号，2个已完成备案的域名(用于推流和播流)

  * 备案流程

    备案是指向主管机关报告事由存案以备查考。

    1. 购买一台阿里云服务器：[准备备案服务器](https://help.aliyun.com/document_detail/147845.html)
    2. 备案所需资料，身份证、域名证书、其它监管部门要求的资料：[准备备案所需资料](https://help.aliyun.com/document_detail/147846.html)
    3. [PC端和移动端备案](https://help.aliyun.com/document_detail/147848.html)

  * 直播配置

    见[快速入门](https://help.aliyun.com/document_detail/198676.html)

    1. 购买阿里云直播服务
    2. 添加推流域名和播流域名
    3. 配置CNAME
    4. 关联推流域名和播流域名
    5. 配置鉴权
    6. 生成推流地址和播放地址
    7. 推流与播流

      推流OBS/ffmpeg

      播流 VLC media player
      
      推流地址rtmp://push.aliyunlive.com/app/stream?auth_key=1543302081-0-0-9c6e7c8190c10bdfb3c0***********

  * 前端播放器

    ```html
    <!DOCTYPE html>
    <html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="IE=edge" >
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/>
    <title>Aliplayer在线配置</title>
    <link rel="stylesheet" href="https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css" />
    <script type="text/javascript" charset="utf-8" src="https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js"></script>
    </head>
    <body>
    <div class="prism-player" id="player-con"></div>
    <script>
    var player = new Aliplayer({
      "id": "player-con",
      "source": "//player.alicdn.com/video/aliyunmedia.mp4",
      "width": "100%",
      "height": "500px",
      "autoplay": true,
      "isLive": false,
      "rePlay": true,
      "playsinline": true,
      "preload": true,
      "controlBarVisibility": "hover",
      "useH5Prism": true
    }, function (player) {
        player._switchLevel = 0;
        console.log("播放器创建了。");
      }
    );
    </script>
    </body>
    ```

  * 关于斗鱼首页视频，在chrome中无法自动播放的提示

    ```html
    <video id="video" src="..." controls autoplay></video>
    <div id="mask"></div>
    <script>
        window.onload = function () {
            document.getElementById('video').addEventListener('canplay', function (e) {
                console.log(1, e)
                document.getElementById('mask').innerHTML="遮罩";
                document.getElementById('video').addEventListener('playing', function (e) {
                    console.log(2, e)
                    document.getElementById('mask').innerHTML="取消遮罩";
                },{once:true})
            },{once:true})
        }
    </script>
    ```

### 生成指定范围不重复随机数最快捷方法

1. 参考链接：

  - [金③银④ 分享一道曾让我栽在二面的面试题｜项目复盘](https://juejin.cn/post/6939352081446731790)
  - [Array.from的三种用法](https://www.cnblogs.com/shaofl/p/10521660.html)

2. 详解

  ```js
  const fn = (len, from = 0, to = 100) => {
    const ratio = (to - from) / len
    let result = []
    
    //生成随机数量占比较大，采用随机下标法生成
    if (ratio > 0.3) {
      const allNums = Array.from({ length: to - from }, (_, i) => i + from)

      for (let i = len; i-- > 0;) {
        result.push(allNums.splice(Math.floor(Math.random() * allNums.length), 1)[0])
      }
    }
    //生成随机数量占比较小(稀疏)，采用随机数去重法生成
    else {
      for (let i = len; i-- > 0;) {
        result.push(Math.round(Math.random() * to + from))
      }

      result = [...new Set(result)]

      let length = result.length

      while (len - length > 0) {
        result = [...new Set(result.concat(fn(len - length, from, to)))]
        length = result.length
      }
    }

    return result
  }
  ```

  Array.from的三种用法:

  1. Array.from (obj, mapFn)

    Array.from(new Set([1,2,3,4]), x => x*2) //[2,4,6,8]

  2. Array.from ({length:n}, Fn)

    Array.from({length:3}, () => 'jack') //["jack", "jack", "jack"]

  3. Array.from(string)　

    Array.from('abc') //['a','b','c']

### Svelte

1. 参考链接：

  - [都快2020年，你还没听说过SvelteJS?](https://zhuanlan.zhihu.com/p/97825481)
  - [Svelte文档](https://www.sveltejs.cn/)
  - [如何看待 svelte 这个前端框架？](https://www.zhihu.com/question/53150351)

2. 详解

  * Svelte解决的问题

    Svelte 的核心思想在于『通过静态编译减少框架运行时的代码量』

    框架无论是 React Angular 还是 Vue，不管你怎么编译，使用的时候必然需要『引入』框架本身，也就是所谓的运行时 (runtime)。

    一个 Svelte 组件编译了以后，所有需要的运行时代码都包含在里面了，除了引入这个组件本身，你不需要再额外引入一个所谓的框架运行时

  * 编译规则

    编译前
    ```html
    <a>{{ msg }}</a>
    ```

    编译后
    ```js
    function renderMainFragment ( root, component, target ) {
      var a = document.createElement( 'a' );
      
      var text = document.createTextNode( root.msg );
      a.appendChild( text );
      
      target.appendChild( a )

      return {
        update: function ( changed, root ) {
          text.data = root.msg;
        },

        teardown: function ( detach ) {
          if ( detach ) a.parentNode.removeChild( a );
        }
      };
    }
    ```

  * 优点

    * 不需要 Virtual DOM 的 diff/patch 操作，自然可以省去大量代码
    * 在编译时，如果一个功能没用到，对应的代码就根本不会被编译到结果里去

  * 缺点

    * 项目里的组件越多，代码量的差异就会逐渐缩小，大型项目反而没有优势
    * 它的更新策略也需要类似 React 的 shouldComponentUpdate 的机制来防止过度更新，比起现在的主流框架并不是质的区别
    * 享受不到 Virtual DOM 带来的诸多好处，比如基于 render function 的组件的强大抽象能力，基于 vdom 做测试，服务端/原生渲染亲和性

### 全景图VR漫游

1. 参考链接：

  - [720云](https://720yun.com/)
  - [720云教程](https://www.sveltejs.cn/)
  - [720云教程汇总](https://bbs2.720yun.com/article?id=234)
  - [Krpano](http://www.krpano360.com/)
  - [krpano英文文档](https://krpano.com/home/)
  - [不到30行代码实现一个酷炫H5全景](https://juejin.cn/post/6968263858309824526)
  - [三种前端实现VR全景看房的方案！说不定哪天就用得上！](https://juejin.cn/post/6973865268426571784)
  - [three.js github](https://github.com/mrdoob/three.js/tree/master)
  - [threejs官方立方体全景示例](https://github.com/mrdoob/three.js/blob/master/examples/webgl_panorama_cube.html)
  - [threejs官方球体全景示例](https://github.com/mrdoob/three.js/blob/master/examples/webgl_panorama_equirectangular.html)
  - [css3d-engine](https://github.com/shrekshrek/css3d-engine)
  - [2天赚了4个W，手把手教你用Threejs搭建一个Web3D汽车展厅！](https://juejin.cn/post/6981249521258856456)
  - [threejs editor](https://threejs.org/editor/)

2. 详解

  * 技术调研

    以下网站实现全景图VR漫游，均基于Krpano：

    需给钱：pano2vr、playcanvas、得图云、airpano、720云、动景网、全景客、ivrpano、全景旅行者、光鱼全景、全景云、720think、三维家、视网、网展

    krpano核心是js/flash/html5/xml，支持webGL下的webVR

    其它实现方法：CSS3 3D，ThreeJS

  * 720制作方法

    1. 根据教程导图
    2. 在线制作全景图VR漫游
    3. 开通vip下载离线包，部署到自己的网站
    4. iframe嵌套，添加其它功能

  * WebGL3D引擎(three.js,babylon.js,playcanvas)

    * three.js概念

      * 场景（scene）

        一个容器，容纳着除渲染器以外的三维世界里的一切。场景的元素采用右手笛卡尔坐标系，x轴正方向向右，y轴正方向向上，z轴由屏幕从里向外

      * 摄像机（camera）

        在一个空间里可以看向任意方向，可以通过参数调节可视角度和可视距离。

        符合物理世界近大远小真实情况的透视相机PerspectiveCamera
        ```js
        PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )
        //构造函数参数
        //fov：视场角
        //aspect：视场宽高比（一般用 画布宽/画布 高即可）
        //near：能看多近
        //far：能看多远
        //这几个参数决定了哪些scene里的三维顶点会被渲染/绘制出来
        ```

        需要远近大小是一样的，那就要用正交相机OrthographicCamera
        
      * 渲染器（renderer）

        将camera在scene里看到的内容渲染/绘制到画布上

      * 几何体（geometry）

        3D世界里的所有物体都是点组成面，面组成几何体

      * 灯光（light）

        3d引擎在没有手动创建光的情况下会默认有个环境光，不然你什么都看不到。常见的灯光有以下几种类型:

        1. AmbientLight（环境光，没有方向全局打亮，不会产生明暗）
        2. DirectionLight（平行光，参考日光来理解）
        3. PointLight（点光源，参考灯泡来理解）
        4. SpotLight（聚光灯，参考舞台聚光灯）

      * 贴图（texture）

        想象一下你手里有一个立方体，你用一张A4纸包裹上立方体的所有面，并在上面画画。你画的内容就是贴图。

        1. 普通贴图（_col）:material.map，替代颜色

        2. 法线贴图（_nor）:material.normalMap，让细节程度较低的表面生成高细节程度的精确光照方向和反射效果

        3. 环境光遮蔽贴图（_occ）:material.aoMap，用来描绘物体和物体相交或靠近的时候遮挡周围漫反射光线的效果

        4. 环境反射贴图:material.envMap，用于模拟材质反射周围环境的效果

        贴图文件统一加载到内存
        ```js
        var allTexture;
        function loadAllTexture(cb){
            allTexture = {};

            var loadIndex = 0;
            var textures = [
                "skymap",
                "shache_occ",
                "shache_nor",
                "shache_col",
                "neishi_occ",
                "neishi_nor",
                "mennei_col",
                "luntai_nor",
                "luntai_col",
                "lungu_occ",
                "lungu_nor",
                "lungu_col",
                "linjian_occ",
                "linjian_nor",
                "linjian_col",
                "floor",
                "deng_occ",
                "deng_nor",
                "deng_col",
                "cheshen_occ",
                "cheshen_nor",
                "chejia_occ",
                "chejia_nor",
                "chedengzhao_nor"
            ];

            function loadNextTexture(){
                var textureName = textures[loadIndex];
                loadTexture("images/textures/"+textureName+".jpg",function(texture){
                    if(loadIndex<textures.length-1){
                        allTexture[textureName] = {
                            texture:texture
                        };

                        loadIndex++;
                        loadNextTexture();
                    }else{
                        if(cb)cb();
                    }
                });
            }
            loadNextTexture();
        }
        function loadTexture(filepath,cb){
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(filepath,cb);
        }
        ```

        根据名称手动一一对应
        ```js
        for(var i=0;i<gltf.scene.children[0].children.length;i++){
            var modelObj = gltf.scene.children[0].children[i];

            if(modelObj.name=="smart_lungu0"||modelObj.name=="smart_lungu1"||modelObj.name=="smart_lungu2"||modelObj.name=="smart_lungu3"){
                modelObj.material = new THREE.MeshStandardMaterial();
                modelObj.material.map = allTexture["lungu_col"].texture;
                modelObj.material.normalMap = allTexture["lungu_nor"].texture;
                modelObj.material.aoMap = allTexture["lungu_occ"].texture;
            }
        }
        ```

      * 材质（material）

        延续贴图里的想象，你用白卡纸画画，还是用油纸画画，呈现出来的质感是不同

        1. MeshBasicMaterial（基础材质，不受光照影响）
        2. MeshStandardMaterial（PBR标准材质）
        3. MeshPhongMaterial（高光材质，适用于陶瓷，烤漆类质感）
        4. MeshToonMaterial（卡通材质，俗称三渲二）
        5. MeshStandardMaterial（PBR标准材质模拟金属反射）

        * 样例

          * 透明的玻璃

            天窗和前挡风玻璃的透明度以及基底颜色是不同的
            ```js
            else if(child.name=="smart_boli"){
                child.material=new THREE.MeshPhongMaterial();
                child.material.color = new THREE.Color( 0x333333 );
                child.material.transparent=true;
                child.material.opacity=.2;
            }else if(child.name=="smart_tianchuang"){
                child.material=new THREE.MeshPhongMaterial();
                child.material.color = new THREE.Color( 0x000 );
                child.material.transparent=true;
                child.material.opacity=.5;
            }
            ```

          * 玻璃的反射

            ```js
            child.material.envMap=allTexture["skymap"].texture;
            //环境反射贴图envMap的映射方式，这里用的是一个叫等量矩形投影的映射方法
            child.material.envMap.mapping = THREE.EquirectangularReflectionMapping;
            //环境反射贴图的强度
            child.material.envMapIntensity=1;
            ```

          * 车身漆面质感

            使用MeshStandardMaterial材质，通过调节metalness，roughness的值来调节金属的质感
            ```js
            child.material = new THREE.MeshStandardMaterial();
                                
            child.material.color=new THREE.Color(0x70631B);
            child.material.metalness = 0.44;
            child.material.roughness = 0;
            ```

      * 3d模型的文件格式

        1. OBJ格式

          老牌通用3d模型文件，不包含贴图，材质，动画等信息。

        2. GLTF格式（图形语言传输格式）

          由OpenGL官方维护团队推出的现代3d模型通用格式，可以包含几何体、材质、动画及场景、摄影机等信息，并且文件量还小。有3D模型界的JPEG之称。

          ```js
          //<script src="js/GLTFLoader.js"></script>
          //放到之前添加立方体的代码处
          const loader = new THREE.GLTFLoader();

          //加载一个.gltf格式的3d模型文件
          loader.load(
              'images/model.gltf',
              function ( gltf ) {
                  scene.add( gltf.scene );
              },
              function ( xhr ) {
                  //侦听模型加载进度
                  console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
              },
              function ( error ) {
                  //加载出错时的回调
                  console.log( 'An error happened' );
              }
          );

          //遍历查看模型里的几何体列表
          //console.log(gltf.scene.children);
          //可以用for，也可以用traverse api
          //gltf.scene.children.traverse((child){});
          ```

      * 信息点

        Sprite+Raycast
        ```js
        //frame只是一个标记，叫什么都行
        var poiPosArray=[
            {x:-1.47,y:0.87,z:-0.36,frame:1},
            {x:-1.46,y:0.49,z:-0.69,frame:2},
            {x:1.5,y:.7,z:0,frame:8},
            {x:0.33,y:1.79,z:0,frame:3},
            {x:0,y:0.23,z:0.96,frame:4},
            {x:0.73,y:1.38,z:-0.8,frame:5},
            {x:-.1,y:1.17,z:0.88,frame:6},
            {x:-1.16,y:0.16,z:0.89,frame:7}
        ],poiObjects=[];
        function setupInfoPoint(){
            const pointTexture = new THREE.TextureLoader().load("images/point.png");

            var group = new THREE.Group();
            var materialC = new THREE.SpriteMaterial( { map: pointTexture, color: 0xffffff, fog: false } );
            for ( var a = 0; a < poiPosArray.length; a ++ ) {
                var x = poiPosArray[a].x;
                var y = poiPosArray[a].y-.5;
                var z = poiPosArray[a].z;

                var sprite = new THREE.Sprite( materialC );
                sprite.scale.set( .15, .15, 1 );
                sprite.position.set( x, y, z );
                sprite.idstr="popup_"+poiPosArray[a].frame;
                group.add( sprite );

                poiObjects.push(sprite);
            }
            scene.add( group );

            document.body.addEventListener("click",function (event) {
                event.preventDefault();

                var raycaster = new THREE.Raycaster();
                var mouse = new THREE.Vector2();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );

                var intersects = raycaster.intersectObjects( poiObjects );
                if(intersects.length>0){
                    var popIndex=parseInt(intersects[ 0 ].object.idstr.substr(6,1));
                    console.log(popIndex);
                }
            });
        }
        ```

      * 平台

        模型:sketchfab
        编辑器:[threejs editor](https://threejs.org/editor/)

      * 优化

        在移动端网页里流畅运行，最多不能超过10万面

    * three.js

      1. 思路

        * 第一步：构建一个空间直角坐标系 ：Three中称之为场景(Scene)
        * 第二步：在坐标系中，绘制几何体： Three中的几何体有很多种，包括BoxGeometry（立方体），SphereGeometry（球体）等等
        * 第三步：选择一个观察点，并确定观察方向等：Three中称之为相机(Camera)
        * 第四步：将观察到的场景渲染到屏幕上的指定区域 ：Three中使用Renderer完成这一工作（相当于拍照）

      2. 素材

        球体全景所需的图片素材：宽是高的两倍，数值是2的整数倍最好，建议图片宽高为2048px*1024px

      3. 理论基础

        ```txt
        经度：lon，取值范围：[0,360]，纬度：lat，取值范围：[-90,90];

        经纬度转换三维坐标

        X = R * cos(lat)* sin(lon)
        Y = R * sin(lat)
        Z = R * cos(lat)*cos(lon)

        ThreeJS中默认的坐标系是右手坐标系，X轴为左右，Y轴为上下，Z轴为前后。
        ```

      4. 具体步骤

        * 第一步：创建一个场景（Scene）
        * 第二步：创建一个球体，并将全景图片贴到球体的内表面，放入场景中
        * 第三步：创建一个透视投影相机将camera拉到球体的中心，相机观看球体内表面
        * 第四步：通过修改经纬度来，改变相机观察的点

      5. 样例代码

        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8">
            <title>手把手教你制作酷炫Web全景</title>
            <meta name="viewport" id="viewport" content="width=device-width,initial-scale=1,minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
        </head>
        <body>
            <div id="wrap" style="position: absolute;z-index: 0;top: 0;bottom: 0;left: 0;right: 0;width: 100%;height: 100%;overflow: hidden;">
            </div>
            <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js"></script>
            <script>
                const width = window.innerWidth, height = window.innerHeight // 屏幕宽高
                const radius = 50 // 球体半径

                // 第一步：创建场景
                const scene = new THREE.Scene()

                // 第二步：绘制一个球体
                const geometry = new THREE.SphereBufferGeometry(radius, 32, 32)
                geometry.scale(-1, 1, 1) // 球面反转，由外表面改成内表面贴图
                const material = new THREE.MeshBasicMaterial({
                    map: new THREE.TextureLoader().load('./img/1.jpeg') // 上面的全景图片
                })
                const mesh = new THREE.Mesh(geometry, material)
                scene.add(mesh)

                // 第三步：创建相机，并确定相机位置
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100)
                camera.position.x = 0  // 确定相机位置移到球心
                camera.position.y = 0
                camera.position.z = 0

                camera.target = new THREE.Vector3(radius, 0, 0) // 设置一个对焦点
              

                // 第四步：拍照并绘制到canvas
                const renderer = new THREE.WebGLRenderer()
                renderer.setPixelRatio(window.devicePixelRatio)
                renderer.setSize(width, height) // 设置照片大小

                document.querySelector('#wrap').appendChild(renderer.domElement) // 绘制到canvas
                renderer.render(scene, camera)

                let lat = 0, lon = 0

                function render() {
                    lon += 0.003 // 每帧加一个偏移量
                    // 改变相机的对焦点，计算公式参考：2.2.2章节
                    camera.target.x = radius * Math.cos(lat) * Math.cos(lon);
                    camera.target.y = radius * Math.sin(lat);
                    camera.target.z = radius * Math.cos(lat) * Math.sin(lon)
                    camera.lookAt(camera.target) // 对焦

                    renderer.render(scene, camera)
                    requestAnimationFrame(render)
                }
                render()
            </script>
        </body>

        </html>
        ```

      6. 手指在屏幕滑动过程

        * touchstart：记录滑动起始的位置（startX，startY, startTime）
        * touchmove：记录当前位置（curX，curY）相减上一次位置的值，乘以factor，计算出（lon，lat），【触摸跟随】
        * touchend：记录endTime,计算本次滑动过程中的平均速度，然后，每帧减去减速度d，直至速度为0或者touchstart事件被触发 【触摸结束触发惯性动画】

        ```js
        distanceX = clientX1 - clientX2   // X轴方向
        distanceY = clientY1 - clientY2   // Y轴方向

        // 其中R为球体半径，根据弧长公式：
        lon = distanX / R
        lat = distanY / R
        ```
        ```js
        // 增加touch事件监听
        let lastX, lastY       // 上次屏幕位置
        let curX, curY         // 当前屏幕位置
        const factor = 1 / 10  // 灵敏系数

        const $wrap = document.querySelector('#wrap')
        // 触摸开始
        $wrap.addEventListener('touchstart', function (evt) {
            const obj = evt.targetTouches[0] // 选择第一个触摸点
            startX = lastX = obj.clientX
            startY = lastY = obj.clientY
        })

        // 触摸中
        $wrap.addEventListener('touchmove', function (evt) {
            evt.preventDefault()
            const obj = evt.targetTouches[0]
            curX = obj.clientX
            curY = obj.clientY

            // 参考：弧长公式
            lon -= ((curX - lastX) / radius) * factor // factor为了全景旋转平稳，乘以一个灵敏系数
            lat += ((curY - lastY) / radius) * factor

            lastX = curX
            lastY = curY
        })
        ```

      7. 手势缩放

        ```txt
        const camera = new THREE.PerspectiveCamera( fov , aspect , near , fear )
        near：取默认值：0.1即可
        fear：只要大于球体半径就可，取值为：球体半径R
        aspect：在全景的场景已经确定了，照片的长宽比：屏幕宽度 / 屏幕高度
        fov：视场，缩放是通过修改它的值来完成全景图片的缩放；
        ```
        ```js
        // 其中，（clientX1，clientY1）和（clientX2，clientY2）为双指在屏幕的当前位置

        // 计算距离，简化运输不用平方计算
        const distance = Math.abs(clientX1 - clientX2) + Math.abc(clientY1 - clientY)
        // 计算缩放比
        const scale = distance / lastDiance 
        // 计算新的视角
        fov = camera.fov / scale

        // 视角范围取值
        camera.fov = Math.min(90, Math.max(fov,60)) // 90 > fov > 60 ,从参数说明中选取

        // 视角需要主动更新
        camera.updateProjectionMatrix()
        ```
      
    * three,js2

      1. 思路

        * 创建黑色场景
        * 创建六面体/球体并贴图
        * 视角(相机)移到空间
        * 添加信息点和点击热点事件

      2. 实现

        * 创建黑色场景

          ```js
          var scene, camera, renderer;

          function initThree(){
              //场景
              scene = new THREE.Scene();
              //镜头
              camera = new THREE.PerspectiveCamera(90, document.body.clientWidth / document.body.clientHeight, 0.1, 100);
              camera.position.set(0, 0, 0.01);
              //渲染器
              renderer = new THREE.WebGLRenderer();
              renderer.setSize(document.body.clientWidth, document.body.clientHeight);
              document.getElementById("container").appendChild(renderer.domElement);
              //镜头控制器
              var controls = new THREE.OrbitControls(camera, renderer.domElement);
              
              //一会儿在这里添加3D物体

              loop();
          }

          //帧同步重绘
          function loop() {
              requestAnimationFrame(loop);
              renderer.render(scene, camera);
          }

          window.onload = initThree;
          ```

        * 使用立方体（box）实现

          ```js
          var materials = [];
          //根据左右上下前后的顺序构建六个面的材质集
          var texture_left = new THREE.TextureLoader().load( './images/scene_left.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_left} ) );

          var texture_right = new THREE.TextureLoader().load( './images/scene_right.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_right} ) );

          var texture_top = new THREE.TextureLoader().load( './images/scene_top.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_top} ) );

          var texture_bottom = new THREE.TextureLoader().load( './images/scene_bottom.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_bottom} ) );

          var texture_front = new THREE.TextureLoader().load( './images/scene_front.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_front} ) );

          var texture_back = new THREE.TextureLoader().load( './images/scene_back.jpeg' );
          materials.push( new THREE.MeshBasicMaterial( { map: texture_back} ) );

          var box = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), materials );
          scene.add(box);
          ```

        * 使用球体（sphere）实现

          ```js
          var sphereGeometry = new THREE.SphereGeometry(/*半径*/1, /*垂直节点数量*/50, /*水平节点数量*/50);//节点数量越大，需要计算的三角形就越多，影响性能

          var sphere = new THREE.Mesh(sphereGeometry);
          sphere.material.wireframe  = true;//用线框模式大家可以看得清楚是个球体而不是圆形
          scene.add(sphere);

          var texture = new THREE.TextureLoader().load('./images/scene.jpeg');
          var sphereMaterial = new THREE.MeshBasicMaterial({map: texture});

          var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
          // sphere.material.wireframe  = true;
          ```

        * 视角(相机)移到立方体

          ```js
          box.geometry.scale( 1, 1, -1 );
          ```

        * 视角(相机)移到球体

          ```js
          var sphereGeometry = new THREE.SphereGeometry(/*半径*/1, 50, 50);
          sphereGeometry.scale(1, 1, -1);
          ```

        * 添加信息点

          点的数组
          ```js
          var hotPoints=[
              {
                  position:{
                      x:0,
                      y:0,
                      z:-0.2
                  },
                  detail:{
                      "title":"信息点1"
                  }
              },
              {
                  position:{
                      x:-0.2,
                      y:-0.05,
                      z:0.2
                  },
                  detail:{
                      "title":"信息点2"
                  }
              }
          ];
          ```

          遍历这个数组，并将信息点的指示图添加到3D场景中
          ```js
          var pointTexture = new THREE.TextureLoader().load('images/hot.png');
          var material = new THREE.SpriteMaterial( { map: pointTexture} );

          for(var i=0;i<hotPoints.length;i++){
              var sprite = new THREE.Sprite( material );
              sprite.scale.set( 0.1, 0.1, 0.1 );
              sprite.position.set( hotPoints[i].position.x, hotPoints[i].position.y, hotPoints[i].position.z );

            scene.add( sprite );
          }
          ```

        * 点击热点事件

          ```js
          sprite.detail = hotPoints[i].detail;
          poiObjects.push(sprite);
          ```

          通过射线检测（raycast），就像是镜头中心向鼠标所点击的方向发射出一颗子弹，去检查这个子弹最终会打中哪些物体
          ```js
          document.querySelector("#container").addEventListener("click",function(event){
              event.preventDefault();

              var raycaster = new THREE.Raycaster();
              var mouse = new THREE.Vector2();

              mouse.x = ( event.clientX / document.body.clientWidth ) * 2 - 1;
              mouse.y = - ( event.clientY / document.body.clientHeight ) * 2 + 1;

              raycaster.setFromCamera( mouse, camera );

              var intersects = raycaster.intersectObjects( poiObjects );
              if(intersects.length>0){
                  alert("点击了热点"+intersects[0].object.detail.title);
              }
          });
          ```

    * three.js官方示例

      * 立方体实现

        [效果](https://threejs.org/examples/?q=webgl_panorama_cube#webgl_panorama_cube)
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <title>three.js webgl - panorama</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
            <link type="text/css" rel="stylesheet" href="main.css">
          </head>
          <body>
            <div id="container"></div>
            <div id="info">
              <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - cube panorama demo
            </div>

            <script type="module">

              import * as THREE from '../build/three.module.js';

              import { OrbitControls } from './jsm/controls/OrbitControls.js';

              let camera, controls;
              let renderer;
              let scene;

              init();
              animate();

              function init() {

                const container = document.getElementById( 'container' );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 100 );
                camera.position.z = 0.01;

                controls = new OrbitControls( camera, renderer.domElement );
                controls.enableZoom = false;
                controls.enablePan = false;
                controls.enableDamping = true;
                controls.rotateSpeed = - 0.25;

                const textures = getTexturesFromAtlasFile( "textures/cube/sun_temple_stripe.jpg", 6 );

                const materials = [];

                for ( let i = 0; i < 6; i ++ ) {

                  materials.push( new THREE.MeshBasicMaterial( { map: textures[ i ] } ) );

                }

                const skyBox = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), materials );
                skyBox.geometry.scale( 1, 1, - 1 );
                scene.add( skyBox );

                window.addEventListener( 'resize', onWindowResize );

              }

              function getTexturesFromAtlasFile( atlasImgUrl, tilesNum ) {

                const textures = [];

                for ( let i = 0; i < tilesNum; i ++ ) {

                  textures[ i ] = new THREE.Texture();

                }

                const imageObj = new Image();

                imageObj.onload = function () {

                  let canvas, context;
                  const tileWidth = imageObj.height;

                  for ( let i = 0; i < textures.length; i ++ ) {

                    canvas = document.createElement( 'canvas' );
                    context = canvas.getContext( '2d' );
                    canvas.height = tileWidth;
                    canvas.width = tileWidth;
                    context.drawImage( imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth );
                    textures[ i ].image = canvas;
                    textures[ i ].needsUpdate = true;

                  }

                };

                imageObj.src = atlasImgUrl;

                return textures;

              }

              function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

              }

              function animate() {

                requestAnimationFrame( animate );

                controls.update(); // required when damping is enabled

                renderer.render( scene, camera );

              }

            </script>
          </body>
        </html>
        ```

      * 球体实现:
      
        [效果](https://threejs.org/examples/?q=webgl_panorama_equirectangular#webgl_panorama_equirectangular)
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <title>three.js webgl - equirectangular panorama</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
            <link type="text/css" rel="stylesheet" href="main.css">
          </head>
          <body>

            <div id="container"></div>
            <div id="info">
              <a href="https://threejs.org" target="_blank" rel="noopener">three.js webgl</a> - equirectangular panorama demo. photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank" rel="noopener">Jón Ragnarsson</a>.<br />
              drag equirectangular texture into the page.
            </div>

            <script type="module">

              import * as THREE from '../build/three.module.js';

              let camera, scene, renderer;

              let isUserInteracting = false,
                onPointerDownMouseX = 0, onPointerDownMouseY = 0,
                lon = 0, onPointerDownLon = 0,
                lat = 0, onPointerDownLat = 0,
                phi = 0, theta = 0;

              init();
              animate();

              function init() {

                const container = document.getElementById( 'container' );

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );

                scene = new THREE.Scene();

                const geometry = new THREE.SphereGeometry( 500, 60, 40 );
                // invert the geometry on the x-axis so that all of the faces point inward
                geometry.scale( - 1, 1, 1 );

                const texture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );
                const material = new THREE.MeshBasicMaterial( { map: texture } );

                const mesh = new THREE.Mesh( geometry, material );

                scene.add( mesh );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                container.style.touchAction = 'none';
                container.addEventListener( 'pointerdown', onPointerDown );

                document.addEventListener( 'wheel', onDocumentMouseWheel );

                //

                document.addEventListener( 'dragover', function ( event ) {

                  event.preventDefault();
                  event.dataTransfer.dropEffect = 'copy';

                } );

                document.addEventListener( 'dragenter', function () {

                  document.body.style.opacity = 0.5;

                } );

                document.addEventListener( 'dragleave', function () {

                  document.body.style.opacity = 1;

                } );

                document.addEventListener( 'drop', function ( event ) {

                  event.preventDefault();

                  const reader = new FileReader();
                  reader.addEventListener( 'load', function ( event ) {

                    material.map.image.src = event.target.result;
                    material.map.needsUpdate = true;

                  } );
                  reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

                  document.body.style.opacity = 1;

                } );

                //

                window.addEventListener( 'resize', onWindowResize );

              }

              function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

              }

              function onPointerDown( event ) {

                if ( event.isPrimary === false ) return;

                isUserInteracting = true;

                onPointerDownMouseX = event.clientX;
                onPointerDownMouseY = event.clientY;

                onPointerDownLon = lon;
                onPointerDownLat = lat;

                document.addEventListener( 'pointermove', onPointerMove );
                document.addEventListener( 'pointerup', onPointerUp );

              }

              function onPointerMove( event ) {

                if ( event.isPrimary === false ) return;

                lon = ( onPointerDownMouseX - event.clientX ) * 0.1 + onPointerDownLon;
                lat = ( event.clientY - onPointerDownMouseY ) * 0.1 + onPointerDownLat;

              }

              function onPointerUp() {

                if ( event.isPrimary === false ) return;

                isUserInteracting = false;

                document.removeEventListener( 'pointermove', onPointerMove );
                document.removeEventListener( 'pointerup', onPointerUp );

              }

              function onDocumentMouseWheel( event ) {

                const fov = camera.fov + event.deltaY * 0.05;

                camera.fov = THREE.MathUtils.clamp( fov, 10, 75 );

                camera.updateProjectionMatrix();

              }

              function animate() {

                requestAnimationFrame( animate );
                update();

              }

              function update() {

                if ( isUserInteracting === false ) {

                  lon += 0.1;

                }

                lat = Math.max( - 85, Math.min( 85, lat ) );
                phi = THREE.MathUtils.degToRad( 90 - lat );
                theta = THREE.MathUtils.degToRad( lon );

                const x = 500 * Math.sin( phi ) * Math.cos( theta );
                const y = 500 * Math.cos( phi );
                const z = 500 * Math.sin( phi ) * Math.sin( theta );

                camera.lookAt( x, y, z );

                renderer.render( scene, camera );

              }

            </script>
          </body>
        </html>
        ```

  * 更加轻量的3D引擎(css3d)

    好处除了库很小以外，还是div+css来搭建三维场景的。但这个库的作者几乎不维护，遇到问题必须得自己想办法解决，比如使用在电脑上会看到明显的面片边缘，但是在手机上浏览的话表现还是相当完美的

    使用skybox实现
    ```js
    window.onload=initCSS3D;

    function initCSS3D(){
        var s = new C3D.Stage();
        s.size(window.innerWidth, window.innerHeight).update();
        document.getElementById('container').appendChild(s.el);

        var box = new C3D.Skybox();
        box.size(954).position(0, 0, 0).material({
            front: {image: "images/scene_front.jpeg"},
            back: {image: "images/scene_back.jpeg"},
            left: {image: "images/scene_right.jpeg"},
            right: {image: "images/scene_left.jpeg"},
            up: {image: "images/scene_top.jpeg"},
            down: {image: "images/scene_bottom.jpeg"},

        }).update();
        s.addChild(box);

        function loop() {
            angleX += (curMouseX - lastMouseX + lastAngleX - angleX) * 0.3;
            angleY += (curMouseY - lastMouseY + lastAngleY - angleY) * 0.3;

            s.camera.rotation(angleY, -angleX, 0).updateT();
            requestAnimationFrame(loop);
        }

        loop();

        var lastMouseX = 0;
        var lastMouseY = 0;
        var curMouseX = 0;
        var curMouseY = 0;
        var lastAngleX = 0;
        var lastAngleY = 0;
        var angleX = 0;
        var angleY = 0;

        document.addEventListener("mousedown", mouseDownHandler);
        document.addEventListener("mouseup", mouseUpHandler);

        function mouseDownHandler(evt) {
            lastMouseX = curMouseX = evt.pageX;
            lastMouseY = curMouseY = evt.pageY;
            lastAngleX = angleX;
            lastAngleY = angleY;

            document.addEventListener("mousemove", mouseMoveHandler);
        }

        function mouseMoveHandler(evt) {
            curMouseX = evt.pageX;
            curMouseY = evt.pageY;
        }

        function mouseUpHandler(evt) {
            curMouseX = evt.pageX;
            curMouseY = evt.pageY;

            document.removeEventListener("mousemove", mouseMoveHandler);
        }
    }
    ```

    添加信息点
    ```js
    var hotPoints=[
        {
            position:{
                x:0,
                y:0,
                z:-476
            },
            detail:{
                "title":"信息点1"
            }
        },
        {
            position:{
                x:0,
                y:0,
                z:476
            },
            detail:{
                "title":"信息点2"
            }
        }
    ];
    function initPoints(){
        var poiObjects = [];
        for(var i=0;i<hotPoints.length;i++){
            var _p = new C3D.Plane();

            _p.size(207, 162).position(hotPoints[i].position.x,hotPoints[i].position.y,hotPoints[i].position.z).material({
                image: "images/hot.png",
                repeat: 'no-repeat',
                bothsides: true,//注意这个两面贴图的属性
            }).update();
            s.addChild(_p);

            _p.el.detail = hotPoints[i].detail;

            _p.on("click",function(e){
                console.log(e.target.detail.title);
            })
        }
    }
    ```

    bothsides属性为true时，背面的信息点图片是反的。需根据其与相机的夹角重置一下信息点的旋转角度。
    ```js
    var r = Math.atan2(hotPoints[i].position.z-0,0-0) * 180 / Math.PI+90;
    _p.size(207, 162).position(hotPoints[i].position.x,hotPoints[i].position.y,hotPoints[i].position.z).material({
                image: "images/hot.png",
                repeat: 'no-repeat',
                bothsides: false,
            }).update();
    ```

### 前端代码规范

1. 参考链接：

  - [从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境](https://juejin.cn/post/6951649464637636622)
  - [EditorConfig](https://editorconfig.org/)
  - [.prettierrc文件常见配置](https://blog.csdn.net/onlyliii/article/details/89312857)
  - [prettier自定义配置](https://www.yuque.com/sida/file/bitad9)
  - [Eslint 配置项说明](https://blog.csdn.net/To_North/article/details/113789590)

2. 详解

  1. EditorConfig

    为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格

    项目根目录下增加 .editorconfig 文件：
    ```conf
    # Editor configuration, see http://editorconfig.org

    # 表示是最顶层的 EditorConfig 配置文件
    root = true

    [*] # 表示所有文件适用
    charset = utf-8 # 设置文件字符集为 utf-8
    indent_style = space # 缩进风格（tab | space）
    indent_size = 2 # 缩进大小
    end_of_line = lf # 控制换行类型(lf | cr | crlf)
    trim_trailing_whitespace = true # 去除行首的任意空白字符
    insert_final_newline = true # 始终在文件末尾插入一个新行

    [*.md] # 表示仅 md 文件适用以下规则
    max_line_length = off
    trim_trailing_whitespace = false
    ```

    VSCode 使用 EditorConfig 需要去插件市场下载插件 EditorConfig for VS Code 。

    JetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 EditorConfig 配置。

    更多配置
    ```conf
    # EditorConfig is awesome: https://EditorConfig.org

    # top-most EditorConfig file
    root = true

    # Unix-style newlines with a newline ending every file
    [*]
    end_of_line = lf
    insert_final_newline = true

    # Matches multiple files with brace expansion notation
    # Set default charset
    [*.{js,py}]
    charset = utf-8

    # 4 space indentation
    [*.py]
    indent_style = space
    indent_size = 4

    # Tab indentation (no size specified)
    [Makefile]
    indent_style = tab

    # Indentation override for all JS under lib directory
    [lib/**.js]
    indent_style = space
    indent_size = 2

    # Matches the exact files either package.json or .travis.yml
    [{package.json,.travis.yml}]
    indent_style = space
    indent_size = 2
    ```

  2. Prettier

    Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。

    * 安装：npm i prettier -D
    * 项目根目录下创建 .prettierrc 文件

      ```json
      {
        "useTabs": false,
        "tabWidth": 2,
        "printWidth": 100,
        "singleQuote": true,
        "trailingComma": "none",
        "bracketSpacing": true,
        "semi": false
      }
      ```

      常见配置
      ```json
      {
          // tab缩进大小,默认为2
          "tabWidth": 4,
          // 使用tab缩进，默认false
          "useTabs": false,
          // 使用分号, 默认true
          "semi": false,
          // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
          "singleQuote": false,
          // 行尾逗号,默认none,可选 none|es5|all
          // es5 包括es5中的数组、对象
          // all 包括函数对象等所有可选
          "TrailingCooma": "all",
          // 对象中的空格 默认true
          // true: { foo: bar }
          // false: {foo: bar}
          "bracketSpacing": true,
          // JSX标签闭合位置 默认false
          // false: <div
          //          className=""
          //          style={{}}
          //       >
          // true: <div
          //          className=""
          //          style={{}} >
          "jsxBracketSameLine": false,
          // 箭头函数参数括号 默认avoid 可选 avoid| always
          // avoid 能省略括号的时候就省略 例如x => x
          // always 总是有括号
          "arrowParens": "avoid"
      }
      {
          // 一行最多 100 字符
          printWidth: 100,
          // 使用 2 个空格缩进
          tabWidth: 2,
          // 不使用缩进符，而使用空格
          useTabs: false,
          // 行尾需要有分号
          semi: true,
          // 使用单引号
          singleQuote: true,
          // 对象的 key 仅在必要时用引号
          quoteProps: 'as-needed',
          // jsx 不使用单引号，而使用双引号
          jsxSingleQuote: false,
          // 末尾不需要逗号
          trailingComma: 'none',
          // 大括号内的首尾需要空格
          bracketSpacing: true,
          // jsx 标签的反尖括号需要换行
          jsxBracketSameLine: false,
          // 箭头函数，只有一个参数的时候，也需要括号
          arrowParens: 'always',
          // 每个文件格式化的范围是文件的全部内容
          rangeStart: 0,
          rangeEnd: Infinity,
          // 不需要写文件开头的 @prettier
          requirePragma: false,
          // 不需要自动在文件开头插入 @prettier
          insertPragma: false,
          // 使用默认的折行标准
          proseWrap: 'preserve',
          // 根据显示样式决定 html 要不要折行
          htmlWhitespaceSensitivity: 'css',
          // 换行符使用 lf
          endOfLine: 'lf'
      }
      ```

    * 使用命令来格式化代码
    
      ```conf
      # 格式化所有文件（. 表示所有文件）
      npx prettier --write .
      ```

    VSCode 编辑器使用 Prettier 配置需要下载插件 Prettier - Code formatter

    JetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 Prettier 配置。

  3. ESLint

    ESLint 是一款用于查找并报告代码中问题的工具，并且支持部分问题自动修复。其核心是通过对代码解析得到的 AST（Abstract Syntax Tree 抽象语法树）进行模式匹配，来分析代码达到检查代码质量和风格问题的能力。

    * 安装:npm i eslint -D
    * 终端操作提示完成一系列设置:npx eslint --init

      1. How would you like to use ESLint? （你想如何使用 ESLint?） 
      
        To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）

      2. What type of modules does your project use?（你的项目使用哪种类型的模块?）

        JavaScript modules (import/export)

      3. Which framework does your project use? （你的项目使用哪种框架?）

        Vue.js

      4. Does your project use TypeScript?（你的项目是否使用 TypeScript？）

        Yes

      5. Where does your code run?（你的代码在哪里运行?）

        Browser 和 Node（按空格键进行选择，选完按回车键确定）

      6. How would you like to define a style for your project?（你想怎样为你的项目定义风格？）

        Use a popular style guide（使用一种流行的风格指南）

      7. Which style guide do you want to follow?（你想遵循哪一种风格指南?）

        Airbnb: github.com/airbnb/javascript

      8. What format do you want your config file to be in?（你希望你的配置文件是什么格式?）

        JavaScript

      9. Would you like to install them now with npm?（你想现在就用 NPM 安装它们吗?）

        Yes

        如果自动安装依赖失败，那么需要手动安装:
        
        npm i @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue -D
        
      10. 项目根目录下自动生成 .eslintrc.js 配置文件

        ```conf
        module.exports = {
          env: {
            browser: true,
            es2021: true,
            node: true
          },
          extends: ['plugin:vue/essential', 'airbnb-base'],
          parserOptions: {
            ecmaVersion: 12,
            parser: '@typescript-eslint/parser',
            sourceType: 'module'
          },
          plugins: ['vue', '@typescript-eslint'],
          rules: {}
        }
        ```

    VSCode 使用 ESLint 配置文件需要去插件市场下载插件 ESLint 。

    编辑器保存文件时自动执行 eslint --fix 命令进行代码风格修复，VSCode 在 settings.json 设置文件中，增加以下代码：

    ```json
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": true
    }
    ```

    etBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。

    rules配置项
    ```json
    "no-alert": 0,//禁止使用alert confirm prompt
    "no-array-constructor": 2,//禁止使用数组构造器
    "no-bitwise": 0,//禁止使用按位运算符
    "no-caller": 1,//禁止使用arguments.caller或arguments.callee
    "no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名
    "no-class-assign": 2,//禁止给类赋值
    "no-cond-assign": 2,//禁止在条件表达式中使用赋值语句
    "no-console": 2,//禁止使用console
    "no-const-assign": 2,//禁止修改const声明的变量
    "no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)
    "no-continue": 0,//禁止使用continue
    "no-control-regex": 2,//禁止在正则表达式中使用控制字符
    "no-debugger": 2,//禁止使用debugger
    "no-delete-var": 2,//不能对var声明的变量使用delete操作符
    "no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/
    "no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}
    "no-dupe-args": 2,//函数参数不能重复
    "no-duplicate-case": 2,//switch中的case标签不能重复
    "no-else-return": 2,//如果if语句里面有return,后面不能跟else语句
    "no-empty": 2,//块语句中的内容不能为空
    "no-empty-character-class": 2,//正则表达式中的[]内容不能为空
    "no-empty-label": 2,//禁止使用空label
    "no-eq-null": 2,//禁止对null使用==或!=运算符
    "no-eval": 1,//禁止使用eval
    "no-ex-assign": 2,//禁止给catch语句中的异常参数赋值
    "no-extend-native": 2,//禁止扩展native对象
    "no-extra-bind": 2,//禁止不必要的函数绑定
    "no-extra-boolean-cast": 2,//禁止不必要的bool转换
    "no-extra-parens": 2,//禁止非必要的括号
    "no-extra-semi": 2,//禁止多余的冒号
    "no-fallthrough": 1,//禁止switch穿透
    "no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3.
    "no-func-assign": 2,//禁止重复的函数声明
    "no-implicit-coercion": 1,//禁止隐式转换
    "no-implied-eval": 2,//禁止使用隐式eval
    "no-inline-comments": 0,//禁止行内备注
    "no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）
    "no-invalid-regexp": 2,//禁止无效的正则表达式
    "no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量
    "no-irregular-whitespace": 2,//不能有不规则的空格
    "no-iterator": 2,//禁止使用__iterator__ 属性
    "no-label-var": 2,//label名不能与var声明的变量名相同
    "no-labels": 2,//禁止标签声明
    "no-lone-blocks": 2,//禁止不必要的嵌套块
    "no-lonely-if": 2,//禁止else语句内只有if语句
    "no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）
    "no-mixed-requires": [0, false],//声明时不能混用声明类型
    "no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格
    "linebreak-style": [0, "windows"],//换行风格
    "no-multi-spaces": 1,//不能用多余的空格
    "no-multi-str": 2,//字符串不能用\换行
    "no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行
    "no-native-reassign": 2,//不能重写native对象
    "no-negated-in-lhs": 2,//in 操作符的左边不能有!
    "no-nested-ternary": 0,//禁止使用嵌套的三目运算
    "no-new": 1,//禁止在使用new构造一个实例后不赋值
    "no-new-func": 1,//禁止使用new Function
    "no-new-object": 2,//禁止使用new Object()
    "no-new-require": 2,//禁止使用new require
    "no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number
    "no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()
    "no-octal": 2,//禁止使用八进制数字
    "no-octal-escape": 2,//禁止使用八进制转义序列
    "no-param-reassign": 2,//禁止给参数重新赋值
    "no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接
    "no-plusplus": 0,//禁止使用++，--
    "no-process-env": 0,//禁止使用process.env
    "no-process-exit": 0,//禁止使用process.exit()
    "no-proto": 2,//禁止使用__proto__属性
    "no-redeclare": 2,//禁止重复声明变量
    "no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/
    "no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错
    "no-return-assign": 1,//return 语句中不能有赋值表达式
    "no-script-url": 0,//禁止使用javascript:void(0)
    "no-self-compare": 2,//不能比较自身
    "no-sequences": 0,//禁止使用逗号运算符
    "no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名
    "no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用
    "no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格
    "no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]
    "no-sync": 0,//nodejs 禁止同步方法
    "no-ternary": 0,//禁止使用三目运算符
    "no-trailing-spaces": 1,//一行结束后面不要有空格
    "no-this-before-super": 0,//在调用super()之前不能使用this或super
    "no-throw-literal": 2,//禁止抛出字面量错误 throw "error";
    "no-undef": 1,//不能有未定义的变量
    "no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined
    "no-undefined": 2,//不能使用undefined
    "no-unexpected-multiline": 2,//避免多行表达式
    "no-underscore-dangle": 1,//标识符不能以_开头或结尾
    "no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;
    "no-unreachable": 2,//不能有无法执行的代码
    "no-unused-expressions": 2,//禁止无用的表达式
    "no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数
    "no-use-before-define": 2,//未定义前不能使用
    "no-useless-call": 2,//禁止不必要的call和apply
    "no-void": 2,//禁用void操作符
    "no-var": 0,//禁用var，用let和const代替
    "no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注
    "no-with": 2,//禁用with
    "array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格
    "arrow-parens": 0,//箭头函数用小括号括起来
    "arrow-spacing": 0,//=>的前/后括号
    "accessor-pairs": 0,//在对象中使用getter/setter
    "block-scoped-var": 0,//块语句中使用var
    "brace-style": [1, "1tbs"],//大括号风格
    "callback-return": 1,//避免多次调用回调什么的
    "camelcase": 2,//强制驼峰法命名
    "comma-dangle": [2, "never"],//对象字面量项尾不能有逗号
    "comma-spacing": 0,//逗号前后的空格
    "comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾
    "complexity": [0, 11],//循环复杂度
    "computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的
    "consistent-return": 0,//return 后面是否允许省略
    "consistent-this": [2, "that"],//this别名
    "constructor-super": 0,//非派生类不能调用super，派生类必须调用super
    "curly": [2, "all"],//必须使用 if(){} 中的{}
    "default-case": 2,//switch语句最后必须有default
    "dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾
    "dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号
    "eol-last": 0,//文件以单一的换行符结束
    "eqeqeq": 2,//必须使用全等
    "func-names": 0,//函数表达式必须有名字
    "func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式
    "generator-star-spacing": 0,//生成器函数*的前后空格
    "guard-for-in": 0,//for in循环要用if语句过滤
    "handle-callback-err": 0,//nodejs 处理错误
    "id-length": 0,//变量名长度
    "indent": [2, 4],//缩进风格
    "init-declarations": 0,//声明时必须赋初值
    "key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格
    "lines-around-comment": 0,//行前/行后备注
    "max-depth": [0, 4],//嵌套块深度
    "max-len": [0, 80, 4],//字符串最大长度
    "max-nested-callbacks": [0, 2],//回调嵌套深度
    "max-params": [0, 3],//函数最多只能有3个参数
    "max-statements": [0, 10],//函数内最多有几个声明
    "new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用
    "new-parens": 2,//new时必须加小括号
    "newline-after-var": 2,//变量声明后是否需要空一行
    "object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格
    "object-shorthand": 0,//强制对象字面量缩写语法
    "one-var": 1,//连续声明
    "operator-assignment": [0, "always"],//赋值运算符 += -=什么的
    "operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首
    "padded-blocks": 0,//块语句内行首行尾是否要空行
    "prefer-const": 0,//首选const
    "prefer-spread": 0,//首选展开运算
    "prefer-reflect": 0,//首选Reflect的方法
    "quotes": [1, "single"],//引号类型 `` "" ''
    "quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号
    "radix": 2,//parseInt必须指定第二个参数
    "id-match": 0,//命名检测
    "require-yield": 0,//生成器函数必须有yield
    "semi": [2, "always"],//语句强制分号结尾
    "semi-spacing": [0, {"before": false, "after": true}],//分号前后空格
    "sort-vars": 0,//变量声明时排序
    "space-after-keywords": [0, "always"],//关键字后面是否要空一格
    "space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格
    "space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格
    "space-in-parens": [0, "never"],//小括号里面要不要有空格
    "space-infix-ops": 0,//中缀操作符周围要不要有空格
    "space-return-throw-case": 2,//return throw case后面要不要加空格
    "space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格
    "spaced-comment": 0,//注释风格要不要有空格什么的
    "strict": 2,//使用严格模式
    "use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()
    "valid-jsdoc": 0,//jsdoc规则
    "valid-typeof": 2,//必须使用合法的typeof的值
    "vars-on-top": 2,//var必须放在作用域顶部
    "wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格
    "wrap-regex": 0,//正则表达式字面量用小括号包起来
    "yoda": [2, "never"]//禁止表达条件
    ```

  4. 解决 Prettier 和 ESLint 的冲突

    在项目中根据实际情况添加一些额外的 ESLint 和 Prettier 配置规则，难免会存在规则冲突情况。例如：

      ESLint 配置中使用了 Airbnb JavaScript 风格指南校验，其规则之一是代码结束后面要加分号

      Prettier 配置文件中加了代码结束后面不加分号的配置项

    需要用到 eslint-plugin-prettier 和 eslint-config-prettier。

      eslint-plugin-prettier 将 Prettier 的规则设置到 ESLint 的规则中。

      eslint-config-prettier 关闭 ESLint 中与 Prettier 中会发生冲突的规则。

    最后形成优先级：Prettier 配置规则 > ESLint 配置规则。

    * 安装：npm i eslint-plugin-prettier eslint-config-prettier -D
    * 在 .eslintrc.js 添加 prettier 插件

      ```json
      module.exports = {
        ...
        extends: [
          'plugin:vue/essential',
          'airbnb-base',
          'plugin:prettier/recommended' // 添加 prettier 插件
        ],
        ...
      }
      ```

  5. husky 和 lint-staged

    让没通过 ESLint 检测和修复的代码禁止提交，从而保证仓库代码都是符合规范的。

    需要用到 Git Hook，在本地执行 git commit 的时候，就对所提交的代码进行 ESLint 检测和修复（即执行 eslint --fix），如果这些代码没通过 ESLint 规则校验，则禁止提交。

    * 配置：npx husky-init
    * 安装：npm install
    * 修改 .husky/pre-commit hook 文件的触发命令：eslint --fix ./src --ext .vue,.js,.ts

      当我们执行 git commit -m "xxx" 时，会先对 src 目录下所有的 .vue、.js、.ts 文件执行 eslint --fix 命令，如果 ESLint 通过，成功 commit，否则终止 commit。

    在提交代码时，也会对其他未修改的“历史”文件都进行检查，可能会造成大量文件出现 ESLint 错误，显然不是我们想要的结果。

    lint-staged 这个工具一般结合 husky 来使用，它可以让 husky 的 hook 触发的命令只作用于 git add那些文件（即 git 暂存区的文件），而不会影响到其他文件。

    * 安装：npm i lint-staged -D
    * package.json里增加 lint-staged 配置项

      这行命令表示：只对 git 暂存区的 .vue、.js、.ts 文件执行 eslint --fix。
      ```json
      "lint-staged": {
        "*.{vue,js,ts}": "eslint --fix"
      },
      ```

    * 修改 .husky/pre-commit hook 的触发命令为：npx lint-staged

### 前端提交规范

1. 参考链接：

  - [从 0 开始手把手带你搭建一套规范的 Vue3.x 项目工程环境](https://juejin.cn/post/6951649464637636622)

2. 详解

  * angular提交规范

    使用社区最流行、最知名、最受认可的 Angular 团队提交规范

    * 格式规范

      * header

        * type(scope): subject

          1. type（必需）

            type 用于说明 commit 的提交类型

            * feat新增一个功能
            * fix修复一个 Bug
            * docs文档变更
            * style代码格式（不影响功能，例如空格、分号等格式修正）
            * refactor代码重构
            * perf改善性能
            * test测试
            * build变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）
            * ci更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等
            * chore变更构建流程或辅助工具
            * revert代码回退
        
          2. scope（可选）

            指定本次 commit 影响的范围。
            
            例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。

          3. subject（必需）

            本次 commit 的简洁描述，长度约定在 50 个字符以内

            * 用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes
            * 第一个字母小写
            * 结尾不加句号（.）

      * body

        对本次 commit 的详细描述，可以分成多行。（body 可省略）

        跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。

      * footer

        如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。

        * 突破性的变更

          当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。

        * 关闭缺陷

          如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。

    * 例子

      * feat

        ```txt
        feat(browser): onUrlChange event (popstate/hashchange/polling)

        Added new event to browser:
        - forward popstate event if available
        - forward hashchange event if popstate not available
        - do polling when neither popstate nor hashchange available

        Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
        ```

      * fix

        ```txt
        fix(compile): couple of unit tests for IE9

        Older IEs serialize html uppercased, but IE9 does not...
        Would be better to expect case insensitive, unfortunately jasmine does
        not allow to user regexps for throw expectations.

        Closes #392
        Breaks foo.bar api, foo.baz should be used instead
        ```

      * style

        ```txt
        style(location): add couple of missing semi colons
        ```

      * chore

        ```txt
        chore(release): v3.4.2
        ```

    * 规范 commit message 的好处

      * 首行就是简洁实用的关键信息，方便在 git history 中快速浏览。
      * 具有更加详细的 body 和 footer，可以清晰的看出某次提交的目的和影响。
      * 可以通过 type 过滤出想要查找的信息，也可以通过关键字快速查找相关提交。
      * 可以直接从 commit 生成 change log。

  * Commitizen

    Commitizen 是一个帮助撰写规范 commit message 的工具。它有一个命令行工具 cz-cli。

    * 安装:npm install commitizen -D
    * 初始化项目:npx commitizen init cz-conventional-changelog --save-dev --save-exact
    * 使用 Commitizen

      以前提交代码都是 git commit -m "xxx"，现在改为 git cz，然后按照终端操作提示，逐步填入信息，就能自动生成规范的 commit message。

    * 自定义配置提交说明(如使用中文)

      * cz-customizable 初始化项目(之前已经初始化过一次，这次再初始化，需要加 --force 覆盖。):npx commitizen init cz-customizable --save-dev --save-exact --force
      * 项目根目录下创建 .cz-config.js 文件

        ```js
        module.exports = {
          // type 类型（定义之后，可通过上下键选择）
          types: [
            { value: 'feat', name: 'feat:     新增功能' },
            { value: 'fix', name: 'fix:      修复 bug' },
            { value: 'docs', name: 'docs:     文档变更' },
            { value: 'style', name: 'style:    代码格式（不影响功能，例如空格、分号等格式修正）' },
            { value: 'refactor', name: 'refactor: 代码重构（不包括 bug 修复、功能新增）' },
            { value: 'perf', name: 'perf:     性能优化' },
            { value: 'test', name: 'test:     添加、修改测试用例' },
            { value: 'build', name: 'build:    构建流程、外部依赖变更（如升级 npm 包、修改 webpack 配置等）' },
            { value: 'ci', name: 'ci:       修改 CI 配置、脚本' },
            { value: 'chore', name: 'chore:    对构建过程或辅助工具和库的更改（不影响源文件、测试用例）' },
            { value: 'revert', name: 'revert:   回滚 commit' }
          ],

          // scope 类型（定义之后，可通过上下键选择）
          scopes: [
            ['components', '组件相关'],
            ['hooks', 'hook 相关'],
            ['utils', 'utils 相关'],
            ['element-ui', '对 element-ui 的调整'],
            ['styles', '样式相关'],
            ['deps', '项目依赖'],
            ['auth', '对 auth 修改'],
            ['other', '其他修改'],
            // 如果选择 custom，后面会让你再输入一个自定义的 scope。也可以不设置此项，把后面的 allowCustomScopes 设置为 true
            ['custom', '以上都不是？我要自定义']
          ].map(([value, description]) => {
            return {
              value,
              name: `${value.padEnd(30)} (${description})`
            }
          }),

          // 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。
          // allowCustomScopes: true,
          // allowTicketNumber: false,
          // isTicketNumberRequired: false,
          // ticketNumberPrefix: 'TICKET-',
          // ticketNumberRegExp: '\\d{1,5}',
          // 针对每一个 type 去定义对应的 scopes，例如 fix
          /*
          scopeOverrides: {
            fix: [
              { name: 'merge' },
              { name: 'style' },
              { name: 'e2eTest' },
              { name: 'unitTest' }
            ]
          },
          */

          // 交互提示信息
          messages: {
            type: '确保本次提交遵循 Angular 规范！\n选择你要提交的类型：',
            scope: '\n选择一个 scope（可选）：',
            // 选择 scope: custom 时会出下面的提示
            customScope: '请输入自定义的 scope：',
            subject: '填写简短精炼的变更描述：\n',
            body:
              '填写更加详细的变更描述（可选）。使用 "|" 换行：\n',
            breaking: '列举非兼容性重大的变更（可选）：\n',
            footer: '列举出所有变更的 ISSUES CLOSED（可选）。 例如: #31, #34：\n',
            confirmCommit: '确认提交？'
          },

          // 设置只有 type 选择了 feat 或 fix，才询问 breaking message
          allowBreakingChanges: ['feat', 'fix'],

          // 跳过要询问的步骤
          // skipQuestions: ['body', 'footer'],

          // subject 限制长度
          subjectLimit: 100
          breaklineChar: '|', // 支持 body 和 footer
          // footerPrefix : 'ISSUES CLOSED:'
          // askForBreakingChangeFirst : true,
        }
        ```

      * 很多时候我们不需要写长描述，公司内部的代码仓库也不需要管理 issue，那么可以把询问 body 和 footer 的步骤跳过（在 .cz-config.js 中修改成 skipQuestions: ['body', 'footer']）。

  * commitlint

    提交代码这个环节，我们也增加一个限制：只让符合 Angular 规范的 commit message 通过，我们借助 @commitlint/config-conventional 和 @commitlint/cli 来实现

    * 安装:npm i @commitlint/config-conventional @commitlint/cli -D
    * 项目根目录下创建 commitlint.config.js 文件

      ```js
      module.exports = { extends: ['@commitlint/config-conventional'] }
      ```

    * 使用 husky 的 commit-msg hook 触发验证提交信息的命令:npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"

### 页面崩溃通信

1. 参考链接：

  - [从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面？](https://juejin.cn/post/6953774253389021191)
  - [使用 iframe + postMessage 实现跨域通信](https://blog.csdn.net/tang_yi_/article/details/79401280)

2. 详解

  * 页面通信方式

    1. onbeforeunload + url 传参

      ```html
      <!-- A.html -->
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>A</title>
      </head>
      <body>
          <h1>A 页面</h1>
          <button type="button" onclick="openB()">B</button>
          <script>
              window.name = 'A'
              function openB() {
                  window.open("B.html", "B")
              }

              window.addEventListener('hashchange', function () {// 监听 hash
                  alert(window.location.hash)
              }, false);
          </script>
      </body>
      </html>
      ```
      ```html
      <!-- B.html -->
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>B</title>
          <button type="button" onclick="sendA()">发送A页面消息</button>
      </head>
      <body>
          <h1>B 页面</h1>
          <span></span>
          <script>
              window.name = 'B'
              window.onbeforeunload = function (e) {
                  window.open('A.html#close', "A")
                  return '确定离开此页吗？';
              }
          </script>
      </body>
      </html>
      ```

    2. postmessage(也可用于iframe跨域通信)

      ```html
      <!-- A.html -->
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>A</title>
      </head>
      <body>
          <h1>A 页面</h1>
          <button type="button" onclick="openB()">B</button>
          <script>
              window.name = 'A'
              function openB() {
                  window.open("B.html?code=123", "B")
              }
              window.addEventListener("message", receiveMessage, false);
              function receiveMessage(event) {
                  console.log('收到消息：', event.data)
              }
          </script>
      </body>
      </html>
      ```
      ```html
      <!-- B.html -->
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>B</title>
          <button type="button" onclick="sendA()">发送A页面消息</button>
      </head>
      <body>
          <h1>B 页面</h1>
          <span></span>
          <script>
              window.name = 'B'
              function sendA() {
                  let targetWindow = window.opener
                  targetWindow.postMessage('Hello A', "http://localhost:3000");
              }
          </script>
      </body>
      </html>
      ```

    3. localStorage

      ```js
      // A
      localStorage.setItem('testB', 'sisterAn');

      // B
      let testB = localStorage.getItem('testB');
      console.log(testB)
      // sisterAn
      ```

    4. WebSocket

    5. SharedWorker

      SharedWorker 接口代表一种特定类型的 worker，可以从几个浏览上下文中访问，例如几个窗口、iframe 或其他 worker。它们实现一个不同于普通 worker 的接口，具有不同的全局作用域, SharedWorkerGlobalScope 。
      
      ```js
      // A.html
      var sharedworker = new SharedWorker('worker.js')
      sharedworker.port.start()
      sharedworker.port.onmessage = evt => {
        // evt.data
          console.log(evt.data) // hello A
      }

      // B.html
      var sharedworker = new SharedWorker('worker.js')
      sharedworker.port.start()
      sharedworker.port.postMessage('hello A')

      // worker.js
      const ports = []
      onconnect = e => {
      const port = e.ports[0]
        ports.push(port)
        port.onmessage = evt => {
            ports.filter(v => v!== port) // 此处为了贴近其他方案的实现，剔除自己
            .forEach(p => p.postMessage(evt.data))
        }
      }
      ```

    6. Service Worker

      Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。

      ```js
      // 注册
      navigator.serviceWorker.register('./sw.js').then(function () {
          console.log('Service Worker 注册成功');
      })
      // A
      navigator.serviceWorker.addEventListener('message', function (e) {
          console.log(e.data)
      });
      // B
      navigator.serviceWorker.controller.postMessage('Hello A');
      ```

  * B 页面正常关闭，如何通知 A 页面?

    onbeforeunload + url 传参

  * B 页面意外崩溃，又该如何通知 A 页面

    心跳检测

    1. B 页面加载后，通过 postMessage API 每 5s 给 sw 发送一个心跳，表示自己的在线，sw 将在线的网页登记下来，更新登记时间；
    2. B 页面在 beforeunload 时，通过 postMessage API 告知自己已经正常关闭，sw 将登记的网页清除；
    3. 如果 B页面在运行的过程中 crash 了，sw 中的 running 状态将不会被清除，更新时间停留在奔溃前的最后一次心跳；
    4. A 页面 Service Worker 每 10s 查看一遍登记中的网页，发现登记时间已经超出了一定时间（比如 15s）即可判定该网页 crash 了。

    实现

    ```js
    // B
    if (navigator.serviceWorker.controller !== null) {
      let HEARTBEAT_INTERVAL = 5 * 1000 // 每五秒发一次心跳
      let sessionId = uuid() // B页面会话的唯一 id
      let heartbeat = function () {
        navigator.serviceWorker.controller.postMessage({
          type: 'heartbeat',
          id: sessionId,
          data: {} // 附加信息，如果页面 crash，上报的附加数据
        })
      }
      window.addEventListener("beforeunload", function() {
        navigator.serviceWorker.controller.postMessage({
          type: 'unload',
          id: sessionId
        })
      })
      setInterval(heartbeat, HEARTBEAT_INTERVAL);
      heartbeat();
    }
    ```
    ```js
    // A
    // 每 10s 检查一次，超过15s没有心跳则认为已经 crash
    const CHECK_CRASH_INTERVAL = 10 * 1000 
    const CRASH_THRESHOLD = 15 * 1000
    const pages = {}
    let timer
    function checkCrash() {
      const now = Date.now()
      for (var id in pages) {
        let page = pages[id]
        if ((now - page.t) > CRASH_THRESHOLD) {
          // 上报 crash
          delete pages[id]
        }
      }
      if (Object.keys(pages).length == 0) {
        clearInterval(timer)
        timer = null
      }
    }

    worker.addEventListener('message', (e) => {
      const data = e.data;
      if (data.type === 'heartbeat') {
        pages[data.id] = {
          t: Date.now()
        }
        if (!timer) {
          timer = setInterval(function () {
            checkCrash()
          }, CHECK_CRASH_INTERVAL)
        }
      } else if (data.type === 'unload') {
        delete pages[data.id]
      }
    })
    ```

### 报表可视化

1. 参考链接：

  - [数据可视化探索之 SpreadJS](https://juejin.cn/post/6955998176549535758)
  - [SpreadJS](https://www.grapecity.com.cn/developer/spreadjs)

2. 详解

  * 难点

    * 并发

      频繁地上传、下载文档，服务器带宽承受了很大的压力

      所有 Excel 解析、提取的操作都在服务器端，频繁的 IO 操作让服务器不堪重负

      硬堆服务器配置带来运维的压力

    * 培训成本和兼容性要求较高

    * 报表格式灵活多变

    * 对计算公式的种类和性能要求较高

    * 对文件服务器的带来了很大压力，后台也不得不定期做批量的数据拆分和维护

  * 选型

    * 云文档类型

      WPS、石墨文档、office online具备较高的完成度，支持一定程度的二次开发而且可以私有化部署，但按时间、按并发量、用户数量等方式授权，价格昂贵

    * 控件类型

      LuckySheet、Handsontable、SpreadJS

  * SpreadJS

    * 渲染性能

      50 万条数据加载耗时 200 ms左右，实时渲染 + 双层缓存，用 Canvas 渲染表格部分，并且只渲染用户看到的部分内容

      Double buffering 在图形学里，一般称作双缓冲，实际上的绘图指令是在一个缓冲区完成，这里的绘图非常的快，在绘图指令完成之后，再通过交换指令把完成的图形立即显示在屏幕上，这就避免了出现绘图的不完整，同时效率很高。

    * 计算引擎

      * 引用数据原生化
      * AST 树解析公式计算
      * 性能接近原生JS的计算性能极限
    
    * 使用

      支持纯js，vue，react，angular

### WebGIS

1. 参考链接：

  - [openlayers](https://openlayers.org/)
  - [OpenLayers教程一：OpenLayers概述](https://blog.csdn.net/qq_35732147/article/details/90675012)
  - [Openlayers API整理](https://segmentfault.com/a/1190000020297846)
  - [webgis](http://webgis.cn/openlayers-openstreet.html)
  - [WebGIS开发进阶练手题（二）](https://zhuanlan.zhihu.com/p/22424372)
  - [cesium](https://cesium.com/platform/cesiumjs/)
  - [Cesium简介](https://www.cnblogs.com/laixiangran/p/4984522.html)
  - [【三维GIS可视化】基于Vue+Cesium+Supermap实现智慧城市（一）](https://juejin.cn/post/6953968499089735711)
  - [【三维GIS可视化】基于Vue+Cesium+Supermap实现智慧城市（二）](https://juejin.cn/post/6955011037070360589)
  - [【三维GIS可视化】基于Vue+Cesium+Supermap实现智慧城市（三）](https://juejin.cn/post/6958708504618237960)
  - [【三维GIS可视化】基于Vue+Cesium+Supermap实现智慧城市（四）](https://juejin.cn/post/6965347246061649934)
  - [SuperMap iClient JavaScript](https://iclient.supermap.io/)
  - [Turf.js—让你在浏览器上实现地理分析](https://juejin.cn/post/6968626897156603918)
  - [Turf.js英文](http://turfjs.org/)
  - [Turf.js中文](https://turfjs.fenxianglu.cn/)

2. 详解

  * openlayers

    * 样例

      ```html
      <!doctype html>
      <html lang="en">
        <head>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/css/ol.css" type="text/css">
          <style>
            .map {
              height: 400px;
              width: 100%;
            }
          </style>
          <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/build/ol.js"></script>
          <title>OpenLayers example</title>
        </head>
        <body>
          <h2>My Map</h2>
          <div id="map" class="map"></div>
          <script type="text/javascript">
            var map = new ol.Map({
              target: 'map',
              layers: [
                new ol.layer.Tile({
                  source: new ol.source.OSM()
                })
              ],
              view: new ol.View({
                center: ol.proj.fromLonLat([37.41, 8.82]),
                zoom: 4
              })
            });
          </script>
        </body>
      </html>
      ```

  * cesium

    1. 下载cesium：https://cesium.com/downloads/

    2. 部署到服务器

    3. 项目

      index.html
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <!-- Use correct character set. -->
        <meta charset="utf-8">
        <!-- Tell IE to use the latest, best version. -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
        <title>Hello World!</title>
        <!--引入cesium.js。该文件定义了Cesium对象，它包含了我们需要的一切。-->
        <script src="../Build/Cesium/Cesium.js"></script>
        <style>
            /*为了能使用Cesium各个可视化控件，我们需要引入widgets.css。*/
            @import url(../Build/Cesium/Widgets/widgets.css);
            html, body, #cesiumContainer {
                width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
            }
        </style>
      </head>
      <body>
        <!--在HTML的body中我们创建一个DIV，用来作为三维地球的容器。-->
        <div id="cesiumContainer"></div>
        <script>
          var viewer = new Cesium.Viewer('cesiumContainer');
        </script>
      </body>
      </html>
      ```

    * Turf.js
    
      地理空间分析库，处理各种地图算法

### 脚手架搭建

1. 参考链接：

  - [从 0 构建自己的脚手架知识体系（万字）](https://juejin.cn/post/6966119324478079007)
  - [GENERATORS](https://yeoman.io/generators/)

2. 详解

  * 创建流程

    1. 建立package.json

      npm init

      ```json
      {
          "name": "cliExample",
          "version": "1.0.0",
          "description": "",
          "main": "cli.js",
          "bin": "cli.js",
          "scripts": {
              "test": "echo \"Error: no test specified\" && exit 1"
          },
          "author": "",
          "license": "ISC",
          "dependencies": {
              "ejs": "^3.1.6",
              "inquirer": "^8.1.0"
          }
      }
      ```

    2. 建立执行文件

      对应上方cli.js

      可建立模板文件，对文件进行读写等操作

    3. 链接到全局

      npm link

      可在全局执行命令，对应上方cliExample

    4. 执行命令即可搭建自定义脚手架

  * 工具库

    1. 命令行交互工具:询问用户信息

      npm install inquirer --dev
      ```js
      const inquirer = require('inquirer')

      inquirer.prompt([
        {
          type: 'input', //type： input, number, confirm, list, checkbox ... 
          name: 'name', // key 名
          message: 'Your name', // 提示信息
          default: 'my-node-cli' // 默认值
        }
      ]).then(answers => {
        // 打印互用输入结果
        console.log(answers)
      })
      ```

    2. 自定义命令行指令

      npm install commander
      ```js
      const program = require('commander')

      program
      .version('0.1.0')
      .command('create <name>')
      .description('create a new project')
      .action(name => { 
          // 打印命令行输入的值
          console.log("project name is " + name)
      })

      program.parse()
      ```

      npm link后，即可使用命令：[包名] create [项目名]

      如：vue create myProject

    3. 命令行美化工具

      npm install chalk
      ```js
      const program = require('commander')
      const chalk = require('chalk')

      program
      .version('0.1.0')
      .command('create <name>')
      .description('create a new project')
      .action(name => { 
          // 打印命令行输入的值

          // 文本样式
          console.log("project name is " + chalk.bold(name))

          // 颜色
          console.log("project name is " + chalk.cyan(name))
          console.log("project name is " + chalk.green(name))

          // 背景色
          console.log("project name is " + chalk.bgRed(name))

          // 使用RGB颜色输出
          console.log("project name is " + chalk.rgb(4, 156, 219).underline(name));
          console.log("project name is " + chalk.hex('#049CDB').bold(name));
          console.log("project name is " + chalk.bgHex('#049CDB').bold(name))
      })

      program.parse()
      ```

    4. ora 命令行 loading 动效

      ```js
      // 自定义文本信息
      const message = 'Loading unicorns'
      // 初始化
      const spinner = ora(message);
      // 开始加载动画
      spinner.start();

      setTimeout(() => {
          // 修改动画样式

          // Type: string
          // Default: 'cyan'
          // Values: 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray'
          spinner.color = 'red';    
          spinner.text = 'Loading rainbows';

          setTimeout(() => {
              // 加载状态修改
              spinner.stop() // 停止
              spinner.succeed('Loading succeed'); // 成功 ✔
              // spinner.fail(text?);  失败 ✖
              // spinner.warn(text?);  提示 ⚠
              // spinner.info(text?);  信息 ℹ
          }, 2000);
      }, 2000);
      ```

    5. cross-spawn 跨平台 shell 工具

      在脚手架里面，可以用来自动执行 shell 命令
      ```js
      const spawn = require('cross-spawn');
      const chalk = require('chalk')

      // 定义需要按照的依赖
      const dependencies = ['vue', 'vuex', 'vue-router'];

      // 执行安装
      const child = spawn('npm', ['install', '-D'].concat(dependencies), { 
          stdio: 'inherit' 
      });

      // 监听执行结果
      child.on('close', function(code) {
          // 执行失败
          if(code !== 0) {
              console.log(chalk.red('Error occurred while installing dependencies!'));
              process.exit(1);
          }
          // 执行成功
          else {
              console.log(chalk.cyan('Install finished'))   
          }
      })
      ```

  * 脚手架

    1. Yeoman：一个通用的脚手架系统

      Yeoman 实际上是三个工具的总和：

        * yo --- 脚手架，自动生成工具
        * grunt、gulp --- 构建工具
        * bower、npm --- 包管理工具

      Yeoman 提供了 yeoman-generator 让我们快速生成一个脚手架模板，我们可以通过各类 Generator 实现任何类型的项目搭建

      * 全局范围安装 yo
      
        npm install yo --global

      * 安装对应的 generator

        yo 搭配不同 generator-xxx 可以创建对应的项目，例如 generator-webapp、generator-node、generator-vue

        例如：npm install generator-node --global

        yo node 快捷搭建一个 node 项目
        ```txt
        yo-project
        ├─ .editorconfig
        ├─ .eslintignore
        ├─ .travis.yml
        ├─ .yo-rc.json
        ├─ LICENSE
        ├─ README.md
        ├─ lib
        │  ├─ __tests__
        │  │  └─ testCli.test.js
        │  └─ index.js
        ├─ package-lock.json
        └─ package.json
        ```

        也可去官网下载[GENERATORS](https://yeoman.io/generators/)

      * 自定义 Generator

        自定义 Generator 实际上就是创建一个特定结构的 npm 包

        结构1
        ```txt
        generator-xxx ............ 自定义项目目录  
        ├─ generators ............ 生成器目录   
        │  └─ app ................ 默认生成器目录      
        │     └─ index.js ........ 默认生成器实现
        └─ package.json .......... 模块包配置文件
        ```

        结构2
        ```txt
        generator-xxx   
        ├─ app           
        │  └─ index.js     
        ├─ router        
        │  └─ index.js   
        └─ package.json
        ```

        npm init 创建package.json
        ```json
        {
          "name": "generator-simple",//name 属性值须是 "generator-<name>"
          "version": "1.0.0",
          "description": "",
          "main": "index.js",
          "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1"
          },
          "keywords": [ 
            "yeoman-generator" //keyword 中必须包含 yeoman-generator
          ],
          //结构1
          "files": [
            "generators"//files 属性要指向项目的模板目录。
          ],
          //结构2
          //{
          //  "files": [
          //    "app",
          //    "router"
          //  ]
          //},
          "author": "ITEM",
          "license": "MIT"
        }
        ```

        npm install yeoman-generator --save

        实现入口文件index.js
        ```js
        // ～/generators/app/index.js

        // 此文件作为 Generator 的核心入口
        // 需要导出一个继承自 Yeoman Generator 的类型
        // Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法
        // 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入

        const Generator = require('yeoman-generator');

        module.exports = class extends Generator {
          // add your own methods
          method1() {
            console.log('I am a custom method');
          }
          method2() {
            console.log('I am a custom method2');
          }
        };
        ```

        npm link 把项目链接到全局

        yo simple 在全局去访问到 generator-simple 项目

        控制台的输出
        ```txt
        I am a custom method1
        I am a custom method2
        ```

        如果运行yo simple 出现下面的错误
        ```txt
        This generator (simple:app) 
        requires yeoman-environment at least 3.0.0, current version is 2.10.3,
        try reinstalling latest version of 'yo' or use '--ignore-version-check' option
        ```

        可以这样处理：

        方案一
        ```md
        # 卸载当前版本
        npm uninstall yeoman-generator

        # 安装低版本的包
        npm i yeoman-generator@4.13.0

        # 执行
        yo simple
        ```

        方案二
        ```md
        # 全局安装模块
        npm i -g yeoman-environment

        # 新的执行方式(yoe没有打错)
        yoe run simple
        ```

        Generator 基类生命周期

          * initializing -- 初始化方法（检查状态、获取配置等）
          * prompting -- 获取用户交互数据（this.prompt()）
          * configuring -- 编辑和配置项目的配置文件
          * default -- 如果 Generator 内部还有不符合任意一个任务队列任务名的方法，将会被放在 default 这个任务下进行运行
          * writing -- 填充预置模板
          * conflicts -- 处理冲突（仅限内部使用）
          * install -- 进行依赖的安装（eg：npm，bower）
          * end -- 最后调用，做一些 clean 工作

        index.js样例
        ```js
        // ～/generators/app/index.js

        const Generator = require('yeoman-generator');

        module.exports = class extends Generator {
          // yo 会自动调用该方法
          writing () {
            // 我们使用 Generator 提供的 fs 模块尝试往目录中写入文件
            this.fs.write(
              // destinationPath() 基于项目地址
              this.destinationPath('temp.txt'), // 写入地址
              Math.random().toString() // 写入内容
            )
          }
        };
        ```

    2. plop：一款小而美的脚手架工具

      npm install plop --save-dev

      项目目录下面创建 plop 的配置文件 plopfile.js

      ```js
      // ./plopfile.js

      module.exports = plop => {
        plop.setGenerator('component', {
          // 描述
          description: 'create a component',
          // 询问组件的名称
          prompts: [
            {
              type: 'input',
              name: 'name',
              message: 'Your component name',
              default: 'MyComponent'
            }
          ],
          // 获取到回答内容后续的动作
          actions: [
            //每一个对象都是一个动作
            {
              type: 'add', // 代表添加文件
              // 被创建文件的路径及名称
              // name 为用户输入的结果，使用 {{}} 使用变量
              // properCase: plop 自带方法，将 name 转换为大驼峰
              path: 'src/components/{{ properCase name }}/index.vue',
              // 模板文件地址
              templateFile: 'plop-templates/component.vue.hbs'
            },
            {
              type: 'add',
              path: 'src/components/{{ properCase name }}/index.scss',
              templateFile: 'plop-templates/component.scss.hbs'
            },
            {
              type: 'add',
              path: 'src/components/{{ properCase name }}/README.md',
              templateFile: 'plop-templates/README.md.hbs'
            }
          ]
        })
      }
      ```

      properCase 方法将 name 转化为大驼峰，其他格式还包括

        * camelCase: changeFormatToThis
        * snakeCase: change_format_to_this
        * dashCase/kebabCase: change-format-to-this
        * dotCase: change.format.to.this
        * pathCase: change/format/to/this
        * properCase/pascalCase: ChangeFormatToThis
        * lowerCase: change format to this
        * sentenceCase: Change format to this,
        * constantCase: CHANGE_FORMAT_TO_THIS
        * titleCase: Change Format To This

      项目文件夹下面创建 plop-templates 文件夹，里面创建对应的模板文件，模板引擎我们用到是 Handlebars
      ```txt
      plop-templates         
      ├─ README.md.hbs ............... 说明文档模板     
      ├─ component.scss.hbs .......... 组件样式模板
      └─ component.vue.hbs ........... 组件模板
      ```

      component.scss.hbs
      ```hbs
      {{!-- ./plop-templates/component.scss.hbs --}}
      {{!-- dashCase/kebabCase: change-format-to-this --}}
      {{!-- name: 输入模板名称 --}}

      .{{ dashCase name }} {

      }
      ```

      component.vue.hbs
      ```hbs
      {{!-- ./plop-templates/component.vue.hbs --}}

      <template>
        <div class="{{ dashCase name }}">{{ name }}</div>
      </template>

      <script>
        export default {
          name: '{{ properCase name }}',
        }
      </script>

      <style lang="scss">
      @import "./index.scss";

      </style>
      ```

      component.scss.hbs
      ```hbs
      {{!-- ./plop-templates/README.md.hbs --}}

      这里是组件 {{ name }} 的使用说明
      ```

      package.json新增命令
      ```js
      // scripts 中 增加一条命令
      ...
      "scripts": {
          ...
          "plop": "plop"
        },
      ...  
      ``` 

      npm run plop

### 禁用外链

1. 参考链接：

  - [js如何实现禁止网页跳转的目的](https://bbs.csdn.net/topics/390327100)

2. 详解

    ```js
    window.onload = function () {
        //禁用外链
        var a = document.getElementsByTagName("a");
        for (var i = 0; i < a.length; i++) {
            a[i].onclick = function (e) {
                e.preventDefault();
                if(!new RegExp('^'+window.location.origin).test(this.href)){
                    return false;
                }
                else{
                    window.location.href = this.href;
                }
            }
        }
    }
    ```

### 禁用控制台

1. 参考链接：

  - [谈谈基于JS实现阻止别人调试通过控制台调试网站的问题](https://juejin.cn/post/6976250246376456206)

2. 详解

  * 开启控制台，有三种方法

    * F12
    * 右键==》检查
    * 浏览器==》更多工具==》开发者工具（快捷键：ctrl+shift+i）

  * 阻止F12事件

    ```js
    window.onkeydown = window.onkeyup = window.onkeypress = function (event) {  
        // 判断是否按下F12，F12键码为123  
        if (event.keyCode = 123) {  
            event.preventDefault() // 阻止默认事件行为  
            window.event.returnValue = false  
        }  
    }
    ```

  * 阻止右键事件

    ```js
    window.oncontextmenu = function() {  
        event.preventDefault() // 阻止默认事件行为  
        return false  
    }
    ```

  * 定时检查浏览器窗口变化(漏洞：浮窗)

    ```js
    let threshold = 160 // 打开控制台的宽或高阈值  
    window.setInterval(function() {  
        if (window.outerWidth - window.innerWidth > threshold ||   
        window.outerHeight - window.innerHeight > threshold) {  
            // 如果打开控制台，则刷新页面  
            window.location.reload()  
        }  
    }, 1000)
    ```

  * 打开控制台弹窗,启用调试debug调试

    ```js
    setInterval(function() {
        check()
    }, 1000);
    var check = function() {
        function doCheck(a) {
            if (("" + a / a)["length"] !== 1 || a % 20 === 0) {
                (function() {}
                ["constructor"]("debugger")())
            } else {
                (function() {}
                ["constructor"]("debugger")())
            }
            doCheck(++a)
        }
        try {
            doCheck(0)
        } catch (err) {}
    };
    check();
    ```

    ```js
    if(window.location.href.indexOf('#debug')==-1){
        setInterval(function(){
            (function (a) {return (function (a) {return (Function('Function(arguments[0]+"' + a + '")()'))})(a)})('bugger')('de', 0, 0, (0, 0))
      }, 1000)
    }
    ```

  * 打开控制台提示（可实现跳转url或刷新）

    ```js
    function toDevtools(){

        let num = 0
        var devtools = new Date()
        devtools.toString = function() {
            num++;
            if(num>0){
                alert('控制台打开了')
                // 可以写刷新或者跳转的逻辑
            }
        }
        console.log(devtools);
    }
    toDevtools()
    ```

### pdf预览

1. 参考链接：

  - [Getting Started](https://mozilla.github.io/pdf.js/getting_started/)
  - [pdf.js实现pdf的预览与下载（vue+springboot+pdf.js）](https://blog.csdn.net/weixin_42551369/article/details/118527891)

2. 详解

  * 实现原理

    canvas画底图，div/span铺在上层，供文字选择

  * 使用

    * 从参考链接1中下载打包好的pdf.js压缩包(不要从github下载源码打包，会有各种报错)
    * 把文件放上服务器，打开/web/viewer.html，即可预览demo的pdf
    * 打开/web/viewer.html?file=***.pdf，即可预览自己指定的pdf
    * 可考虑使用iframe嵌入主页面

  * 附

    vue-pdf在IOS下会出现问题

### web打印

1. 参考链接：

  - [一篇搞定【web打印】知识点](https://juejin.cn/post/6985030118758416391)
  - [如何通过Nw.js纯前端实现调用热敏打印机打印小票？](https://juejin.cn/post/6844903778827649032)
  - [Egg + Puppeteer 实现Html转PDF(已开源)](https://juejin.cn/post/6907500437134376974)

2. 详解

  * 浏览器打印

    通过 window.print() 、document.execCommand('print’) 调用浏览器打印

    不同浏览器的区别：在Safari和Chrome都会弹起打印预览的窗口，FireFox（老版本）和 IE 没有预览而是直接让你选择打印机

    * 存在的问题

      1. 打印不支持自定义分页行为，默认不支持批量打印；
      2. 打印的时候样式有问题，所见非所得；
      3. 打印可以准确识别的样式单位是绝对单位（如pt、mm、cm），对相对单位识别不同打印机可能会得到意想不到的结果；

    * 局部打印

      * innerHtml

        ```js
        function innerHtmlPrint(){
            // 缓存页面内容
            const bodyHtml = window.document.body.innerHTML;
            // 获取要打印的dom
            const printContentHtml = document.getElementById("print").innerHTML;
            // 替换页面内容
            window.document.body.innerHTML = printContentHtml;
            // 全局打印
            window.print();
            // 还原页面内容
            window.document.body.innerHTML = bodyHtml;
            // 页面事件会丢失，需要刷新
            window.location.reload();
        }
        ```

      * iframe插件

        也可用于html转pdf

        [vue-iframe-print](https://github.com/alexwjj/vue-iframe-print)

        [demo](https://alexwjj.github.io/vue-iframe-print/)

        ```js
        function onIframePrint(printId) {
          const printContentHtml = document.getElementById("printId").innerHTML;
          const iframe = document.createElement("iframe");
          iframe.setAttribute(
            "style",
            "position:absolute;width:0px;height:0px;left:-500px;top:-500px;"
          );
          document.body.appendChild(iframe);
          iframe.contentDocument.write(printContentHtml);
          iframe.contentDocument.close();
          iframe.contentWindow.print();
          document.body.removeChild(iframe);
        }
        ```

      * canvas

        将打印内容转为图片，一倍清晰度模糊，可以用2倍canvas。
        
        缺点：pdf需要下载，有的产品需求需要一键打印。html2canvas不支持ie，兼容性也是个问题

        ```js
        function print() {
          var target = document.getElementsByClassName("right-aside")[0];
          target.style.background = "#FFFFFF";

          html2canvas(target, {
            onrendered:function(canvas) {
                var contentWidth = canvas.width;
                var contentHeight = canvas.height;

                //一页pdf显示html页面生成的canvas高度;
                var pageHeight = contentWidth / 592.28 * 841.89;
                //未生成pdf的html页面高度
                var leftHeight = contentHeight;
                //页面偏移
                var position = 0;
                //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高
                var imgWidth = 595.28;
                var imgHeight = 592.28/contentWidth * contentHeight;

                var pageData = canvas.toDataURL('image/jpeg', 1.0);

                var pdf = new jsPDF('', 'pt', 'a4');

                //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
                //当内容未超过pdf一页显示的范围，无需分页
                if (leftHeight < pageHeight) {
                  pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
                } else {
                    while(leftHeight > 0) {
                        pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                        leftHeight -= pageHeight;
                        position -= 841.89;
                        //避免添加空白页
                        if(leftHeight > 0) {
                          pdf.addPage();
                        }
                    }
                }

                pdf.save("content.pdf");
            }
          })
        }
        ```

        完美还原
        ```html
        <object
          type="application/pdf"
          data="./滴滴出行行程报销单A.pdf"
          width="100%"
          height="700"
        ></object>
        
        <embed 
          type="application/pdf" 
          src="./滴滴出行行程报销单A.pdf" 
          width="100%" 
          height="700px"
        />
        ```

  * 插件打印

    一般是通过项目里面嵌入脚本，或者安装本地插件来完成，优缺点也都很明显

    * 优点

      * 功能强大，可以调用到系统底层的东西，比如获取系统打印机列表，设置默认打印机等
      * 可以实现无预览打印

    * 缺点

      * 需要安装客户端，大多收费
      * 第三方插件，无技术支持，出现问题难以解决（版本问题，chrome84升级导致的证书问题）
      * 本地插件的方式基本只有window系统版本

    * 插件

      * [C-lodop](http://www.c-lodop.com/index.html)：功能强大，兼容性不好，使用之前需研究下官网给的demo，原理是在页面嵌入一段js，和本地客户端通过webscoket进行通信
      * [HttpPrinter](http://www.httpprinter.com/)：同C-lodop
      * [HiPrint](http://hiprint.io/)：不需要安装客户端，没有npm包，依赖于jQuery
      * NW.js

        ```js
        const printer = require('./printer.js')

        function getPrinterList() {  
            const list = printer.getPrinterList()  
            const res = []  
            list.forEach(item => res.push(item.name))  
            return res
        }

        // 获取当前打印机列表
        const printerList = getPrinterList()
        // 暂定使用打印机为第一个
        const printerName = printerList[0]
        // mock订单数据
        const mockData = {  id: 001,  delivery_way: '外送',  deliver_time: '立即送达',  sku_detail: [{    quantity: 10,    sku_name: '火米饼套餐',    price: 20  }],  description: '多放火贝 火火火火',  invoiced: '',  package_fee: 1,  deliver_fee: 10,  total_price: 31,  receiver_address: '火星1区101路1号',  receiver_name: '火星人',  receiver_phone: 00001,  create_time: '0001-01-01',  tagg_shop_name: '火星1号商店'}

        // 封装打印订单函数，传参为打印机名称和订单数据
        function printOrderRecive(name = '', data = {}) {  
            const Buffer = require('./escpos.js')  
            let buffer = new Buffer()
            buffer = buffer.setLineHeight(70)    
                          .setTextSize(2).setLineHeight(50).setText(data.id, 'center')    
                          .setTextSize(1).setLineHeight(100).setText(`${data.delivery_way} ${data.deliver_time}`, 'center')    
                          .setLineHeight(70).setDecLine()    
                          .setBoldOn()    
                          .setLineHeight(70)  
            data.sku_detail && data.sku_detail.forEach(item => {    
                buffer = buffer.setThreeCol(item.quantity, item.sku_name, `￥${item.price}`)  })  
                buffer = buffer.setLine()    
                              .setLineHeight(100).setText(`备注：${data.description}`).setBoldOff()    
                              .setLineHeight(50).setDecLine()    
                              .setLineHeight(70)    
                              .setTwoCol('开具发票', data.invoiced)    
                              .setTwoCol('包装费', `￥${data.package_fee}`)    
                              .setTwoCol('配送费', `￥${data.deliver_fee}`)    
                              .setLineHeight(50)    
                              .setDecLine()    
                              .setBoldOn().setText(`合计：￥${data.total_price}  `, 'right').setBoldOff()    
                              .setDecLine()    
                              .setLineHeight(70)    
                              .setText(`送货地址：${data.receiver_address}`)    
                              .setText(`客户：${data.receiver_name} ${data.receiver_phone}`)    
                              .setDecLine()    
                              .setText(`下单时间: ${data.create_time}`, 'center')    
                              .setLine(2)    
                              .setBoldOn().setText(`${data.tagg_shop_name} \n \n`, 'center').setBoldOff()    
                              .setLine(2)    
                              .cut()    
                              .getBuffer()
            printer.print(name, buffer)
        }

        // 调用打印功能
        printOrderRecive(printerName, mockData)
        ```

  * 打印样式

    * @media print

      可以控制打印时的样式，仅在打印生效，可以实现一些特殊需求。

      ```css
      /*媒体查询*/
      @media print{
        body{
          background-color:red;
        }
      }

      /*css import*/
      @import url("print.css") print;

      /*html link*/
      <link rel="stylesheet" media="print" href="print.css">
      ````

    * @page

      设置页面大小（A3，A4，A5）、边距（margin）、方向（auto、landscape、portrait）等。

      ```css
      /*去除页眉*/
      @page {
        margin-top:0;
      }
      /*去除页脚*/
      @page {
        margin-bottom:0;
      }
      /*去除页眉页脚*/
      @page {
        margin:0;
      }
      @page {
        /*auto:浏览器控制landscape:横向portrait:竖向*/
        size:A4 portrait;
        margin:1cm 3cm;
      }
      /*双面打印时会用到左右页不同样式，左右页面距为装订留出空间*/
      @page :left{
        margin-left:2.5cm;
        margin-right:2.7cm;
      }
      @page :right{
        margin-left:2.7cm;
        margin-right:2.5cm;
      }
      ```

    * page-break-xxx

      * page-break-before( after ) 用于设置元素前( 后 )的分页行为,可取值:

        * auto默认值。如果必要则在元素前插入分页符。
        * always在元素前插入分页符。
        * avoid避免在元素前插入分页符。
        * left在元素之前足够的分页符，一直到一张空白的左页为止。
        * right在元素之前足够的分页符，一直到一张空白的右页为止。
        * inherit规定应该从父元素继承 page-break-before 属性的设置。

      * page-break-inside设置元素内部的分页行为。取值如下:

        * auto默认。如果必要则在元素内部插入分页符。
        * avoid避免在元素内部插入分页符。
        * inherit规定应该从父元素继承 page-break-inside 属性的设置。
      
      orphans设置当元素内部发生分页时必须在页面底部保留的最少行数。

      widows设置当元素内部发生分页时必须在页面顶部保留的最少行数。

      ```css
      @media print{
        .img-test{
          width: 200vh;
          page-break-before:always;
        }
        h1{
          page-break-before:always;
          page-break-after:always;
        }
        p{
          page-break-inside:avoid;
        }
      }
      ```

  * 云打印（node + ipp）

    * 打印机类型

      * 激光打印机

        办公室常见的打印机，一般用打印普通文档材料。利用激光加热将墨粉固定在纸上，从而实现打印功能。平常的耗材是墨粉，使用的纸张是普通纸，一般是打印黑白色。打印速度快 后期耗材便宜

      * 针式打印机

        一般用于打印票据，或者需要按压打印的纸张。将色带上的墨水压在纸上，从而实现打印功能。平常的耗材是色带，使用的纸张是多联纸，比起其他两个分类针式打印机可以说是元老级别的，它是是市场上较早出现的种类。主要有9针、24针、72针、144针等多种针式打印机。其特点比较鲜明结构简单、技术成熟、性能价格比好、消耗费用低。

      * 热敏打印机

        使用专用纸张,靠高温显示需要打印的信息.主要用于打印小票.

      * 喷墨打印机

        一般用于打印彩色材料。将墨水喷射在纸上，从而实现打印功能。平常的耗材是墨水，使用的纸张是普通纸，一般可以打印彩色。（另外也有一个耗材是墨盒，有些机型不必频繁更换）

    * 概念

      * 互联网打印协议 （IPP；Internet Printing Protocol）

        一个在互联网上打印的标准网络协议，它容许用户可以透过互联网作遥距打印及管理打印工作等工作。用户可以透过相关界面来控制打印品所使用的纸张种类、分辨率等各种参数。

      * 无头浏览器

        使用脚本来执行以上过程的浏览器，能模拟真实的浏览器使用场景。如puppeteer

    * 实现

      [Egg + Puppeteer 实现Html转PDF(已开源)](https://juejin.cn/post/6907500437134376974)

