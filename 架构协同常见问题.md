# 架构协同常见问题

- [DevOps](#DevOps)
- [跨端框架](#跨端框架)
- [微前端](#微前端)
- [自动部署](#自动部署)
- [单点登录](#单点登录)
- [codeReview](#codeReview)
- [Serverless](#Serverless)

---

### DevOps

1. 参考链接：

   [devops （过程、方法与系统的统称）](https://baike.baidu.com/item/devops/2613029?fr=aladdin)

   [为什么大公司一定要使用 DevOps?](https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/82056948)

   [Devops](https://www.jianshu.com/p/c5d002cf25b9)

2. 详解：

   - 概念

     DevOps 是一种软件开发方法，为了让开发、运维和 QA 可以高效协作的流程。可以把 DevOps 看作开发（development）、技术运营（technology）和质量保障（quanlity assurance）三者的交集。

   - 演变

     DevOps 从现有的软件开发策略/方法发展而来，以响应业务需求。

     - 阶段 1：瀑布模型

       需要清晰固定的需求。

     - 阶段 2：敏捷开发

       需求变化快，需要快速开发。

     - 阶段 3：devops

       需求变化快，快速开发，尽可能自动化。

   - 对应用程序发布的影响

     - 频繁发布时每次程序变化少，程序能平滑生长。
     - 高效协调开发与运营，确保人员理解变更和充分合作。
     - 自动化部署，减少出错的可能性

   - 工具链

     - 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion
     - 构建工具：Ant、Gradle、maven
     - 自动部署：Capistrano、CodeDeploy
     - 持续集成（CI）：Bamboo、Hudson、Jenkins
     - 配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail
     - 容器：Docker、LXC、第三方厂商如 AWS
     - 编排：Kubernetes、Core、Apache Mesos、DC/OS
     - 服务注册与发现：Zookeeper、etcd、Consul
     - 脚本语言：python、ruby、shell
     - 日志管理：ELK、Logentries
     - 系统监控：Datadog、Graphite、Icinga、Nagios
     - 性能监控：AppDynamics、New Relic、Splunk
     - 压力测试：JMeter、Blaze Meter、loader.io
     - 预警：PagerDuty、pingdom、厂商自带如 AWS SNS
     - HTTP 加速器：Varnish
     - 消息总线：ActiveMQ、SQS
     - 应用服务器：Tomcat、JBoss
     - Web 服务器：Apache、Nginx、IIS
     - 数据库：MySQL、Oracle、PostgreSQL 等关系型数据库；cassandra、mongoDB、redis 等 NoSQL 数据库
     - 项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker

### 跨端框架

1. 参考链接：

   [腾讯开源内部跨端框架 Hippy，打磨三年，日均 PV 过亿](https://segmentfault.com/a/1190000021374633#item-2)

   [为什么要使用 Hippy 开发跨平台应用](https://zhuanlan.zhihu.com/p/98431027)

   [Taro，快速上手教程（一）](https://segmentfault.com/a/1190000016766906?utm_source=tag-newest)

   [Taro 框架](https://www.jianshu.com/p/99cef6e102d2)

   [多端统一开发解决方案](https://taro.aotu.io/)

   [【2万字长文】深入浅出主流的几款小程序跨端框架原理](https://juejin.im/post/6881597846307635214)

2. 详解：

  - 描述

    传统网页开发受浏览器能力限制太大，如 PC 端各浏览器和移动端的 android 和 ios 限制，以及前端框架 jquery，vue，react 等的不同，相同的功能需要适配不同的平台，大大增加了开发难度。造成这种问题的原因是各平台由终端开发者主导开发，而不是从前端开发者角度出发。

  - 腾讯 hippy

    https://github.com/Tencent/Hippy

    实现了类似 Flutter 的引擎直通架构（在 React Native 中的 Fabric 架构），通过 C++ 开发的模块直接插入 JS 引擎中运行，绕过了前终端通讯编解码的开销，有效提升了 JS 前端代码和终端的通讯性能。

    整体划分为框架层、引擎层、渲染层。每层均可自由替换。框架层既可以使用 React 也可以使用 Vue，或者未来的新兴框架。引擎层可以使用 JS，将来也支持 Dart，Lua 等语言。渲染层目前使用原生 Native 绘制，也支持自绘，业务可以根据需求自由选择。

    hippy-vue 的组件、参数和接口完全符合浏览器标准，前端开发用浏览器标签和常用的 CSS 选择器就可以完成跨端界面绘制。其优势如下：

    1. 前端开发基本了解一下 hippy-vue 开发的限制就可以上手跨端开发；
    2. 可以复用 Web 端绝大多数的生态；
    3. 不需要 Web 转接库就可以直接生成网页。

    应用场景：

    1. 全民 K 歌：react + hippy-react + hippy-react-web
    2. 王者营地：vue + hippy-vue

  - taro

    https://github.com/NervJS/taro

    Taro 是一套遵循 React 语法规范的多端统一开发框架,只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端,生成能运行在微信小程序、H5、React Native 等的应用。

  - uni app

    https://dcloud.io/

    uni app 使用 vue 语法

  - 跨端框架原理

    - 背景

      小跨端框架发展到如今已经百花齐放、百家争鸣：除了美团的 mpvue 、网易的 megalo 、滴滴的 chameloen 已经趋于稳定，京东的 Taro开始探索 taro next， Hbuilder 的uni-app 产品和生态持续完善，微信新推出了支持H5和微信小程序的 kbone 框架，蚂蚁金服的 remax

      按语法分类：vue/react

      按实现原理分类：compile time 编译时(通过语法树转换为小程序语法)/runtime 运行时(更有优势，通过适配层运行vue/react)

    - 从vue到小程序

      ```txt
      .vue -> .wxml/wxss/js/json
        template -> .wxml //mpvue、megalo、uni-app 的框架是采用了 ast 来解析转化模板
          div -> view
          v-if -> wx:if/a:if(支付宝)/s-if(百度)
          @click -> bindtap
        style -> wxss
        script -> js
          new Vue() -> Page()
            vue -> vnode/diff -> render函数 -> setData() //vue上数据变化，通过运行时来通知小程序，更新page，小程序触发事件，通过运行时，找到vue的回调函数
      ```

    - 从react到小程序

      ```txt
      .jsx -> babel -> ast -> .wxml/wxss/js/json
        fiber -> 自定义生命周期render的渲染器remax -> vnode/remax镜像树
        在第一次 mount 时，Remax 运行时初始化时会通过小程序的 setData 初始化小程序的 JSON 树状数据, 在小程序加载完毕后， Remax 通过递归模板的形式，把JSON 树状数据渲染为小程序的页面
        Remax 运行时在数据发生更新时，就会通过小程序的 setData 去更新上面小程序的 JSON 树状数据， JSON 树状数据被更新了，小程序自然会触发更新数据对应的那块视图的渲染
      ```

### 微前端

1. 参考链接：

   [微前端如何落地？](https://baijiahao.baidu.com/s?id=1638313846156942854&wfr=spider&for=pc)

   [微前端实践](https://www.jianshu.com/p/41ab812df9e7)

   [基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇](https://juejin.im/post/5ebbd2986fb9a0432f0fff86)

   [实施微前端的六种方式](https://segmentfault.com/a/1190000015566927)

   [实现微前端的十种方式 【第一种】](https://blog.csdn.net/petertanjinjie/article/details/107171986)

   [实现微前端的十种方式 【第二种】](https://blog.csdn.net/petertanjinjie/article/details/107218841)

   [微前端框架chunchao(春潮)开源啦](https://blog.csdn.net/petertanjinjie/article/details/106743015)

   [基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇](https://mp.weixin.qq.com/s/GjAHSvWqy70s50cwlr9udw)

   [万字长文+图文并茂+全面解析 qiankun 源码 - qiankun 篇](https://www.jianshu.com/p/db08174fa4fc)

   [解密微前端：从qiankun看沙箱隔离](https://blog.csdn.net/mashibing_web/article/details/109903615)

   [基于 qiankun 的微前端最佳实践（图文并茂） - 应用间通信篇](https://blog.csdn.net/qq_34621851/article/details/106003110)

   [基于qiankun的微前端最佳实践-通信篇（Vuex）](https://www.jianshu.com/p/b2a77373c09e)

   [基于qiankun落地部署微前端爬”坑“记](https://blog.csdn.net/u013655559/article/details/107527135)

   [微前端qiankun从搭建到部署的实践](https://www.cnblogs.com/love314159/p/13791556.html)

2. 详解：

   - 前提

      多个单页面应用聚合为一

   - 描述

     微服务架构，可以解耦后端服务间依赖。微前端借鉴微服务的概念来应用在前端上，将一个巨大的前端工程拆分成一个的小工程，这些小工程具备独立的开发和运行能力，而整个系统就由这些小工程协同合作。

   - 优点

     1. 应用自治。只需要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间是不存在依赖关系的。
     2. 单一职责。每个前端应用可以只关注于自己所需要完成的功能。
     3. 技术栈无关。你可以使用 Angular 的同时，又可以使用 React 和 Vue。

   - 缺点

     1. 应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。
     2. 拆分的粒度越小，便意味着架构变得复杂、维护成本变高。
     3. 技术栈一旦多样化，便意味着技术栈混乱。

   - 架构模式

     1. 基座模式。通过一个主应用，来管理其它应用。设计难度小，方便实践，但是通用度低。
     2. 自组织模式。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。

   - 注册表模式

     不论何种方式，都需要提供一个查找应用的机制，在微前端中称为服务的注册表模式。和微服务架构相似，不论是哪种微前端方式，也都需要有一个应用注册表的服务，它可以是一个固定值的配置文件，如 JSON 文件，又或者是一个可动态更新的配置，又或者是一种动态的服务。它主要做这么一些内容：

     1. 应用发现。让主应用可以寻找到其它应用。
     2. 应用注册。即提供新的微前端应用，向应用注册表注册的功能。
     3. 第三方应用注册。即让第三方应用，可以接入到系统中。
     4. 访问权限等相关配置。

   - 设计理念

     1. 中心化：应用注册表。这个应用注册表拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。
     2. 标识化应用。我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到指定的应用。一个简单的模式，就是通过康威定律来命名应用。
     3. 应用生命周期管理。
        1. Load，决定加载哪个应用，并绑定生命周期
        2. bootstrap，获取静态资源
        3. Mount，安装应用，如创建 DOM 节点
        4. Unload，删除应用的生命周期
        5. Unmount，卸载应用，如删除 DOM 节点、取消事件绑定
     4. 高内聚，低耦合。

   - 技术方式

     1. 路由分发式。通过 HTTP 服务器的反向代理功能，来将请求路由到对应的应用上。
     2. 前端微服务化。在不同的框架之上设计通讯、加载机制，以在一个页面内加载对应的应用。
     3. 微应用。通过软件工程的方式，在部署构建环境中，组合多个独立应用成一个单体应用。
     4. 微件化。开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可。
     5. 前端容器化。通过将 iFrame 作为容器，来容纳其它前端应用。
     6. 应用组件化。借助于 Web Components 技术，来构建跨框架的前端应用。

   - 业务拆分

     1. 按照业务拆分。
     2. 按照权限拆分。
     3. 按照变更的频率拆分。
     4. 按照组织结构拆分。
     5. 跟随后端微服务划分。

   - 与传统模式的区别

      1. 应用分发路由 -> 路由分发应用
      2. 后端：函数调用 -> 远程调用
      3. 前端：组件调用 -> 应用调用


   - 工具

      chunchao、qiankun

   - 实现方法集合

      1. 路由分发式微前端

          ```nginx
          http {
            server {
              listen       80;
              server_name  www.phodal.com;
              location /api/ {
                proxy_pass http://http://172.31.25.15:8000/api;
              }
              location /web/admin {
                proxy_pass http://172.31.25.29/web/admin;
              }
              location /web/notifications {
                proxy_pass http://172.31.25.27/web/notifications;
              }
              location / {
                proxy_pass /;
              }
            }
          }
          ```

      2. iFrame

        - 加载机制：应用切换需要过渡平滑
        - 通讯机制：通过 iframeEl.contentWindow 去获取 iFrame 元素的 Window 对象是一个更简化的做法

      3. 自制框架

        参考[Mooa](https://github.com/phodal/mooa)

        Mooa也是基于iframe，唯一风险是第三方库不兼容

      4. 组合式集成：将应用微件化

        所有的依赖、Pollyfill 已经尽可能地在首次加载了，CSS 样式也不需要重复加载，其他功能再需要加载时，才加载业务组件或应用

        方式：归类生成chunk文件，独立开发，集成时合并，运行时加载runtime、代码、模板

        限制是必须使用同一框架

      5. 纯 Web Components 技术构建

        参考[oan](https://github.com/phodal/oan)

        可理解为应用组件化

      6. 混用

   - 代码

      1. 最简单的微前端实现方式(乞丐式)

          Vue和React、Jquery共同开发,通信

          babel配置
          ```json
          {
              "presets": [
                  "@babel/preset-react",
                  [
                      "@babel/preset-env",
                      {
                          "targets": {
                              "electron": "4"
                          },
                          "modules": false
                      }
                  ]
              ],
              "plugins": [
                  "@babel/plugin-proposal-class-properties",
                  "@babel/plugin-syntax-async-generators",
                  "@babel/plugin-syntax-dynamic-import"
              ]
          }
          ```

          React的入口
          ```jsx
          import React from 'react';
          import dva from 'dva';
          import App from './App';
          
          import demo from '../App/Dva-model/demo.js';
          const app = dva();
          
          app.model(demo);
          app.router(({ history, app: store }) => (
            <App history={history} getState={store._store.getState} dispatch={store._store.dispatch} />
          ));
          
          app.start('#root');
          ```

          定义vue入口文件
          ```js
          function vueRender(props) {
            new Vue({
              router,
              store,
              render: (h) => h(App),
            }).$mount('#test');
          }
          
          export default vueRender;
          ```

          在React组件中调用vue渲染
          ```js
          import vueRender from '@v/startVUe.js';
          ...
          componentDidMount() {
            vueRender(this.props);
          }
          ```

          这样vue能接受到React组件的props，然后也可以正常通过vue渲染，使用vue的技术栈了

      2. 目前主流的微前端实现方式（基座加载式）

          * 劫持前端路由,重写hashchange和popstate事件
          ```js
          const HIJACK_EVENTS_NAME = /^(hashchange|popstate)$/i;
          const EVENTS_POOL = {
            hashchange: [],
            popstate: [],
          };
          
          window.addEventListener('hashchange', loadApps);
          window.addEventListener('popstate', loadApps);
          
          const originalAddEventListener = window.addEventListener;
          const originalRemoveEventListener = window.removeEventListener;
          window.addEventListener = function (eventName, handler) {
            if (
              eventName &&
              HIJACK_EVENTS_NAME.test(eventName) &&
              typeof handler === 'function'
            ) {
              EVENTS_POOL[eventName].indexOf(handler) === -1 &&
                EVENTS_POOL[eventName].push(handler);
            }
            return originalAddEventListener.apply(this, arguments);
          };
          ```
          * 根据不同的入口，去拉取子应用的js、css等资源
          * 注册子应用后存入队列中
          ```js
          const Apps = [] //子应用队列
          function registryApp(entry,activeRule) {
              Apps.push({
                  entry,
                  activeRule
              })
          }
          ```
          * 注册完了之后，就要找到需要加载的app,并且拉取资源
          ```js
          export async function loadApp() {
            const shouldMountApp = Apps.filter(shouldBeActive);
            const App = shouldMountApp.pop();
            fetch(App.entry)
              .then(function (response) {
                return response.text();
              })
              .then(async function (text) {
                const dom = document.createElement('div');
                dom.innerHTML = text;
                const entryPath = App.entry;
                const scripts = dom.querySelectorAll('script');
                const subapp = document.querySelector('#subApp-content');
                const paromiseArr =
                  scripts &&
                  Array.from(scripts).map((item) => {
                    if (item.src) {
                      const url = window.location.protocol + '//' + window.location.host;
                      return fetch(`${entryPath}/${item.src}`.replace(url, '')).then(
                        function (response) {
                          return response.text();
                        }
                      );
                    } else {
                      return Promise.resolve(item.textContent);
                    }
                  });
                subapp.appendChild(dom);
                const res = await Promise.all(paromiseArr);
                if (res && res.length > 0) {
                  res.forEach((item) => {
                    const script = document.createElement('script');
                    script.innerText = item;
                    subapp.appendChild(script);
                  });
                }
              });
          }
          ```
          * 根据传入的规则去判断是否需要此时挂载
          ```js
          export function shouldBeActive(app){
              return app.activeRule(window.location)
          }
          ```
          * 处理脚本文件
          ```js
          export async function handleScripts(entryPath,subapp,dom) {
            const scripts = dom.querySelectorAll('script');
            const paromiseArr =
              scripts &&
              Array.from(scripts).map((item) => {
                if (item.src) {
                  const url = window.location.protocol + '//' + window.location.host;
                  return fetch(`${entryPath}/${item.src}`.replace(url, '')).then(
                    function (response) {
                      return response.text();
                    }
                  );
                } else {
                  return Promise.resolve(item.textContent);
                }
              });
            const res = await Promise.all(paromiseArr);
            if (res && res.length > 0) {
              res.forEach((item) => {
                const script = document.createElement('script');
                script.innerText = item;
                subapp.appendChild(script);
              });
            }
          }
          ```
          * 处理样式文件
          ```js
          export async function handleStyles(entryPath, subapp, dom) {
            const arr = [];
            const styles = dom.querySelectorAll('style');
            const links = Array.from(dom.querySelectorAll('link')).filter(
              (item) => item.rel === 'stylesheet'
            );
            const realArr = arr.concat(styles,links)
            const paromiseArr =
              arr &&
              Array.from(realArr).map((item) => {
                if (item.rel) {
                  const url = window.location.protocol + '//' + window.location.host;
                  return fetch(`${entryPath}/${item.href}`.replace(url, '')).then(
                    function (response) {
                      return response.text();
                    }
                  );
                } else {
                  return Promise.resolve(item.textContent);
                }
              });
            const res = await Promise.all(paromiseArr);
            if (res && res.length > 0) {
              res.forEach((item) => {
                const style = document.createElement('style');
                style.innerHTML = item;
                subapp.appendChild(style);
              });
            }
          }
          ```

   - qiankun

      * 总流程

        注册子应用->启动主应用->激活并初始化子应用(1次)->挂载子应用(多次)->卸载子应用(多次)

        single-spa注册子应用->设置子应用属性(name/callback激活子应用回调/activeRule/props传递给子应用参数)

        注入全局变量xx_QIANKUN_，指示子应用正运行在主应用中->初始化配置参数(prefetch是否开启预加载/singularMode是否单例模式/jsSandbox是否开启沙箱)->启动主应用->激活子应用->执行子应用callback->执行生命周期函数(bootstrap/mount/unmount)

        初始化子应用->单例模式下，不存在其它相同子应用->通过importEntry加载(fetch)子应用资源->调用子应用render，把html挂载到主容器->创建子应用沙箱sandbox->创建内部生命周期(beforeLoad/beforeMount/afterMount/beforeUnmount/afterUnmount)->指定执行上下文sandbox.proxy，执行子应用脚本execScript->查找子应用提供的3个生命周期(bootstrap/mount/unmount)，没则报错->初始化完毕，等待挂载

        沙箱：激活active/关闭inactive/子应用取值getter/子应用设置值setter/当前window状态windowSnapshot，用于还原当前沙箱环境/被修改的属性记录modifyPropsMap，用于还原沙箱激活前状态，清除主应用对主应用全局污染/子应用内部状态池updateValueMap['test']=true

        挂载子应用->单例模式下，不存在其它相同子应用->调用子应用render，把html挂载到主容器->触发全局生命周期beforeMount->挂载和激活沙箱，劫持各类全局监听mountSandbox->触发子应用生命周期mount->调用子应用render，loading为false->触发全局生命周期afterMount->设置prevAppUnmountedDeferred，单例模式存活期间，对其它相同子应用阻塞->挂载完成

        卸载子应用unmount->触发全局生命周期beforeUnmount->触发子应用生命周期unmount->卸载和关闭沙箱，释放各种全局监听unmountSandbox->触发全局生命周期afterUnmount->调用子应用render，清除主应用html内容->调用prevAppUnmountedDefferred.resolve()不再阻塞其它单例模式下子应用挂载->卸载完成

      * 详解沙箱隔离

        qiankun 做沙箱隔离主要分为三种：

        1. legacySandBox
        2. proxySandBox
        3. snapshotSandBox

        其中 legacySandBox、proxySandBox 是基于 Proxy API 来实现的，在不支持 Proxy API 的低版本浏览器中，会降级为 snapshotSandBox。在现版本中，legacySandBox 仅用于 singular 单实例模式，而多实例模式会使用 proxySandBox。

        * legacySandBox

          操作 window 对象，通过激活沙箱时还原子应用的状态，卸载时还原主应用的状态来实现沙箱隔离

          三个状态池：

          * addedPropsMapInSandbox： 存储在子应用运行时期间新增的全局变量，用于卸载子应用时还原主应用全局变量；
          * modifiedPropsOriginalValueMapInSandbox：存储在子应用运行期间更新的全局变量，用于卸载子应用时还原主应用全局变量；
          * currentUpdatedPropsValueMap：存储子应用全局变量的更新，用于运行时切换后还原子应用的状态；

          getter / setter
          ```js
          const rawWindow = window;
          const fakeWindow = Object.create(null) as Window;
          // 创建对fakeWindow的劫持，fakeWindow就是我们传递给自执行函数的window对象
          const proxy = new Proxy(fakeWindow, {
            set(_: Window, p: PropertyKey, value: any): boolean {
              // 运行时的判断
              if (sandboxRunning) {
                // 如果window对象上没有这个属性，那么就在状态池中记录状态的新增；
                if (!rawWindow.hasOwnProperty(p)) {
                  addedPropsMapInSandbox.set(p, value);
                  // 如果当前 window 对象存在该属性，并且状态池中没有该对象，那么证明改属性是运行时期间更新的值，记录在状态池中用于最后window对象的还原
                } else if (!modifiedPropsOriginalValueMapInSandbox.has(p)) {
                  const originalValue = (rawWindow as any)[p];
                  modifiedPropsOriginalValueMapInSandbox.set(p, originalValue);
                }
                // 记录全局对象修改值，用于后面子应用激活时还原子应用
                currentUpdatedPropsValueMap.set(p, value);
                (rawWindow as any)[p] = value;
                return true;
              }
              return true;
            },
            get(_: Window, p: PropertyKey): any {
              // iframe的window上下文
              if (p === "top" || p === "window" || p === "self") {
                return proxy;
              }

              const value = (rawWindow as any)[p];
              return getTargetValue(rawWindow, value);
            },
          });
          ```

          激活 / 卸载
          ```js
          // 子应用沙箱激活
          active() {
            // 通过状态池，还原子应用上一次写在前的状态
            if (!this.sandboxRunning) {
              this.currentUpdatedPropsValueMap.forEach((v, p) => setWindowProp(p, v));
            }

            this.sandboxRunning = true;
          }

          // 子应用沙箱卸载
          inactive() {
            // 还原运行时期间修改的全局变量
            this.modifiedPropsOriginalValueMapInSandbox.forEach((v, p) => setWindowProp(p, v));
            // 删除运行时期间新增的全局变量
            this.addedPropsMapInSandbox.forEach((_, p) => setWindowProp(p, undefined, true));

            this.sandboxRunning = false;
          }
          ```

        * proxySandBox

          用于多实例场景，某一个子应用聚合了多个业务域，这样的子应用往往会经历多个团队的多个同学共同维护自己的业务模块，这时候便可以采用多实例的模式聚合子模块（这种模式也可以叫微前端模块）

          为了支持多实例的场景，proxySandBox 不会直接操作 window 对象。并且为了避免子应用操作或者修改主应用上诸如 window、document、location 这些重要的属性，会遍历这些属性到子应用 window 副本（fakeWindow）上

          proxySandBox 不直接操作 window，所以在激活和卸载的时候也不需要操作状态池更新 / 还原主子应用的状态了。相比较看来，proxySandBox 是现阶段 qiankun 中最完备的沙箱模式

          ```js
          function createFakeWindow(global: Window) {
            // 这里qiankun给我们了一个知识点：在has和check的场景下，map有着更好的性能 
            const propertiesWithGetter = new Map<PropertyKey, boolean>();
            const fakeWindow = {} as FakeWindow;
            // 从window对象拷贝不可配置的属性
            // 举个例子：window、document、location这些都是挂在Window上的属性，他们都是不可配置的
            // 拷贝出来到fakeWindow上，就间接避免了子应用直接操作全局对象上的这些属性方法
            Object.getOwnPropertyNames(global)
              .filter((p) => {
                const descriptor = Object.getOwnPropertyDescriptor(global, p);
                // 如果属性不存在或者属性描述符的configurable的话
                return !descriptor?.configurable;
              })
              .forEach((p) => {
                const descriptor = Object.getOwnPropertyDescriptor(global, p);
                if (descriptor) {
                  // 判断当前的属性是否有getter
                  const hasGetter = Object.prototype.hasOwnProperty.call(
                    descriptor,
                    "get"
                  );
                  // 为有getter的属性设置查询索引
                  if (hasGetter) propertiesWithGetter.set(p, true);
                  // freeze the descriptor to avoid being modified by zone.js
                  // zone.js will overwrite Object.defineProperty
                  // const rawObjectDefineProperty = Object.defineProperty;
                  // 拷贝属性到fakeWindow对象上
                  rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));
                }
              });
            return {
              fakeWindow,
              propertiesWithGetter,
            };
          }
          ```

          getter/setter
          ```js
          const rawWindow = window;
          // window副本和上面说的有getter的属性的索引
          const { fakeWindow, propertiesWithGetter } = createFakeWindow(rawWindow);
          const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();
          const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || rawWindow.hasOwnProperty(key);
          const proxy = new Proxy(fakeWindow, {
            set(target: FakeWindow, p: PropertyKey, value: any): boolean {
              if (sandboxRunning) {
                // 在fakeWindow上设置属性值
                target[p] = value;
                // 记录属性值的变更
                updatedValueSet.add(p);
                // SystemJS属性拦截器
                interceptSystemJsProps(p, value);
                return true;
              }
              // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误
              return true;
            },
            get(target: FakeWindow, p: PropertyKey): any {
              if (p === Symbol.unscopables) return unscopables;
              // 避免window.window 或 window.self 或window.top 穿透sandbox
              if (p === "top" || p === "window" || p === "self") {
                return proxy;
              }
              if (p === "hasOwnProperty") {
                return hasOwnProperty;
              }
              // 批处理场景下会有场景使用，这里就不多赘述了
              const proxyPropertyGetter = getProxyPropertyGetter(proxy, p);
              if (proxyPropertyGetter) {
                return getProxyPropertyValue(proxyPropertyGetter);
              }
              // 取值
              const value = propertiesWithGetter.has(p)
                ? (rawWindow as any)[p]
                : (target as any)[p] || (rawWindow as any)[p];
              return getTargetValue(rawWindow, value);
            },
            // 还有一些对属性做操作的代码我就不一一列举了，可以自行查阅源码
          });
          ```
          激活 / 卸载
          ```js
          active() {
            this.sandboxRunning = true;
            // 当前激活的子应用沙箱实例数量
            activeSandboxCount++;
          }
          inactive() {
            clearSystemJsProps(this.proxy, --activeSandboxCount === 0);
        
            this.sandboxRunning = false;
          }
          ```

        * snapshotSandBox

          在不支持 Proxy 的场景下会降级为 snapshotSandBox,原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。

          对当前的 window 和记录的快照做 diff 来实现沙箱
          ```js
          active() {
            if (this.sandboxRunning) {
              return;
            }
            this.windowSnapshot = {} as Window;
            // iter方法就是遍历目标对象的属性然后分别执行回调函数
            // 记录当前快照
            iter(window, prop => {
              this.windowSnapshot[prop] = window[prop];
            });
        
            // 恢复之前运行时状态的变更
            Object.keys(this.modifyPropsMap).forEach((p: any) => {
              window[p] = this.modifyPropsMap[p];
            });
        
            this.sandboxRunning = true;
          }
        
          inactive() {
            this.modifyPropsMap = {};
        
            iter(window, prop => {
              if (window[prop] !== this.windowSnapshot[prop]) {
                // 记录变更，恢复环境
                this.modifyPropsMap[prop] = window[prop];
                window[prop] = this.windowSnapshot[prop];
              }
            });
        
            this.sandboxRunning = false;
          }
          ```

        * css 隔离

          1. 约定式编程

            * 尽量不要使用可能冲突全局的 class 或者直接为标签定义样式；
            * 定义唯一的 class 前缀，现在的项目都是用诸如 antd 这样的组件库，这类组件库都支持自定义组件 class 前缀；
            * 主应用一定要有自定义的 class 前缀；

          2. css in js:不利于后期的项目维护并且也比较难去抽离一些公共 css

      * 效果预告

        主应用主页基座vue，微应用页vue，微应用页react，微应用页angular

      * 将普通的项目改造成 qiankun 主应用基座

        1. 创建微应用容器 - 用于承载微应用，渲染显示微应用；
        2. 注册微应用 - 设置微应用激活条件，微应用地址等等；
        3. 启动 qiankun；

      * 创建微应用容器

        1. 设置路由
        ```ts
        // micro-app-main/src/routes/index.ts
        import Home from "@/pages/home/index.vue";

        const routes = [
          {
            /**
            * path: 路径为 / 时触发该路由规则
            * name: 路由的 name 为 Home
            * component: 触发路由时加载 `Home` 组件
            */
            path: "/",
            name: "Home",
            component: Home,
          },
        ];

        export default routes;
        ```

        2. 主文件引入路由
        ```ts
        // micro-app-main/src/main.ts
        //...
        import Vue from "vue";
        import VueRouter from "vue-router";

        import routes from "./routes";

        /**
        * 注册路由实例
        * 即将开始监听 location 变化，触发路由规则
        */
        const router = new VueRouter({
          mode: "history",
          routes,
        });

        // 创建 Vue 实例
        // 该实例将挂载/渲染在 id 为 main-app 的节点上
        new Vue({
          router,
          render: (h) => h(App),
        }).$mount("#main-app");
        ```

        3. 设置主应用的布局
        ```ts
        <template>
          <a-config-provider prefixCls="cns">
            <section id="cns-main-app">
              <section class="cns-menu-wrapper">
                <!-- 主应用菜单，用于渲染菜单 -->
                <main-menu :menus="menus" />
              </section>
              <section class="cns-frame-wrapper">
                <!-- 主应用渲染区，用于挂载主应用路由触发的组件，在触发主应用路由规则时，将渲染主应用的组件 -->
                <router-view v-show="$route.name" />
                <!-- 子应用渲染区，用于挂载子应用节点，在未触发主应用路由规则时，将渲染微应用节点 -->
                <section v-show="!$route.name" id="frame"></section>
              </section>
            </section>
          </a-config-provider prefixCls>
        </template>
        // micro-app-main/src/App.vue
        //...
        export default class App extends Vue {
          /**
          * 菜单列表
          * key: 唯一 Key 值
          * title: 菜单标题
          * path: 菜单对应的路径
          */
          menus = [
            {
              key: "Home",
              title: "主页",
              path: "/",
            },
          ];
        }
        // 省略了样式
        ```

      * 注册微应用

        1. 使用 qiankun 的 registerMicroApps 方法注册微应用
        ```ts
        // micro-app-main/src/micro/apps.ts
        // 此时我们还没有微应用，所以 apps 为空
        const apps = [];

        export default apps;

        // micro-app-main/src/micro/index.ts
        // 一个进度条插件
        import NProgress from "nprogress";
        import "nprogress/nprogress.css";
        import { message } from "ant-design-vue";
        import {
          registerMicroApps,
          addGlobalUncaughtErrorHandler,
          start,
        } from "qiankun";

        // 微应用注册信息
        import apps from "./apps";

        /**
        * 注册微应用
        * 第一个参数 - 微应用的注册信息
        * 第二个参数 - 全局生命周期钩子
        */
        registerMicroApps(apps, {
          // qiankun 生命周期钩子 - 微应用加载前
          beforeLoad: (app: any) => {
            // 加载微应用前，加载进度条
            NProgress.start();
            console.log("before load", app.name);
            return Promise.resolve();
          },
          // qiankun 生命周期钩子 - 微应用挂载后
          afterMount: (app: any) => {
            // 加载微应用前，进度条加载完成
            NProgress.done();
            console.log("after mount", app.name);
            return Promise.resolve();
          },
        });

        /**
        * 添加全局的未捕获异常处理器
        */
        addGlobalUncaughtErrorHandler((event: Event | string) => {
          console.error(event);
          const { message: msg } = event as any;
          // 加载失败时提示
          if (msg && msg.includes("died in status LOADING_SOURCE_CODE")) {
            message.error("微应用加载失败，请检查应用是否可运行");
          }
        });

        // 导出 qiankun 的启动函数
        export default start;
        ```

      * 启动主应用

        1. 入口文件启动 qiankun 主应用
        ```js
        // micro-app-main/src/main.ts
        //...
        import startQiankun from "./micro";

        startQiankun();
        ```

      * 接入微应用

        qiankun 内部通过 import-entry-html 加载微应用，要求微应用需要导出生命周期钩子函数:bootstrap/mount/unmount，如果微应用没有导出这三个生命周期钩子函数，则微应用会加载失败。

        如果我们使用了脚手架搭建微应用的话，我们可以通过 webpack 配置在入口文件处导出这三个生命周期钩子函数。如果没有使用脚手架的话，也可以直接在微应用的 window 上挂载这三个生命周期钩子函数。

        1. 接入 Vue 微应用

          * 创建vue项目(主应用的同级目录（micro-app-main 同级目录）)：vue create micro-app-vue
          * 创建几个路由、页面，写样式
          * 在主应用中注册该微应用的信息(接上面app.ts),进入 /vue 路由时将加载 Vue 微应用
            ```ts
            // micro-app-main/src/micro/apps.ts
            const apps = [
              /**
              * name: 微应用名称 - 具有唯一性
              * entry: 微应用入口 - 通过该地址加载微应用
              * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
              * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
              */
              {
                name: "VueMicroApp",
                entry: "//localhost:10200",
                container: "#frame",
                activeRule: "/vue",
              },
            ];

            export default apps;
            ```
          * 菜单配置处也加入 Vue 微应用的快捷入口
            ```ts
            // micro-app-main/src/App.vue
            //...
            export default class App extends Vue {
              /**
              * 菜单列表
              * key: 唯一 Key 值
              * title: 菜单标题
              * path: 菜单对应的路径
              */
              menus = [
                {
                  key: "Home",
                  title: "主页",
                  path: "/",
                },
                {
                  key: "VueMicroApp",
                  title: "Vue 主页",
                  path: "/vue",
                },
                {
                  key: "VueMicroAppList",
                  title: "Vue 列表页",
                  path: "/vue/list",
                },
              ];
            }
            ```
          * 导出 qiankun 主应用所需要的三个生命周期钩子函数
            ```ts
            // micro-app-vue/src/public-path.js
            if (window.__POWERED_BY_QIANKUN__) {
              // 动态设置 webpack publicPath，防止资源加载出错
              // eslint-disable-next-line no-undef
              __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
            }

            // micro-app-vue/src/main.js
            import Vue from "vue";
            import VueRouter from "vue-router";
            import Antd from "ant-design-vue";
            import "ant-design-vue/dist/antd.css";

            import "./public-path";//webpack 默认的 publicPath 为 "" 空字符串，会基于当前路径来加载资源。我们在主应用中加载微应用时需要重新设置 publicPath，这样才能正确加载微应用的相关资源。（public-path.js 具体实现在后面）
            import App from "./App.vue";
            import routes from "./routes";

            Vue.use(VueRouter);
            Vue.use(Antd);
            Vue.config.productionTip = false;

            let instance = null;
            let router = null;

            //微应用的挂载函数，在主应用中运行时将在 mount 生命周期钩子函数中调用，可以保证在沙箱内运行。
            /**
            * 渲染函数
            * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
            */
            function render() {
              // 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染
              router = new VueRouter({
                // 运行在主应用中时，添加路由命名空间 /vue
                base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
                mode: "history",
                routes,
              });

              // 挂载应用
              instance = new Vue({
                router,
                render: (h) => h(App),
              }).$mount("#app");
            }

            //微应用独立运行时，直接执行 render 函数挂载微应用。
            // 独立运行时，直接挂载应用
            if(!window.__POWER_BY_QIANKUN__){
              render()
            }

            //微应用导出的生命周期钩子函数 - bootstrap
            /**
            * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
            * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
            */
            export async function bootstrap() {
              console.log("VueMicroApp bootstraped");
            }

            //微应用导出的生命周期钩子函数 - mount
            /**
            * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
            */
            export async function mount(props) {
              console.log("VueMicroApp mount", props);
              render(props);
            }

            //微应用导出的生命周期钩子函数 - unmount
            /**
            * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
            */
            export async function unmount() {
              console.log("VueMicroApp unmount");
              instance.$destroy();
              instance = null;
              router = null;
            }
            ```
          * 配置 vue.config.js,配置 webpack，使 main.js 导出的生命周期钩子函数可以被 qiankun 识别获取。
            ```js
            // micro-app-vue/vue.config.js
            const path = require("path");

            module.exports = {
              devServer: {
                // 监听端口
                port: 10200,
                // 关闭主机检查，使微应用可以被 fetch
                disableHostCheck: true,
                // 配置跨域请求头，解决开发环境的跨域问题
                headers: {
                  "Access-Control-Allow-Origin": "*",
                },
              },
              configureWebpack: {
                resolve: {
                  alias: {
                    "@": path.resolve(__dirname, "src"),
                  },
                },
                output: {
                  // 微应用的包名，这里与主应用中注册的微应用名称一致
                  library: "VueMicroApp",
                  // 将你的 library 暴露为所有的模块定义下都可运行的方式
                  libraryTarget: "umd",
                  // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
                  jsonpFunction: `webpackJsonp_VueMicroApp`,
                },
              },
            };
            ```
          * 打开主基座，切换到vue微应用，能正确加载，控制台能看到执行的生命周期钩子

        2. 接入react应用

          * 创建react项目(在主应用的同级目录（micro-app-main 同级目录）):npx create-react-app micro-app-react,添加 .env 文件，设置项目监听的端口
            ```txt
            # micro-app-react/.env
            PORT=10100
            BROWSER=none
            ```
          * 创建几个路由、页面，加入样式
          * 主应用中注册该微应用的信息
            ```ts
            // micro-app-main/src/micro/apps.ts
            const apps = [
              /**
              * name: 微应用名称 - 具有唯一性
              * entry: 微应用入口 - 通过该地址加载微应用
              * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
              * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
              */
              {
                name: "ReactMicroApp",
                entry: "//localhost:10100",
                container: "#frame",
                activeRule: "/react",
              },
            ];

            export default apps;
            ```
          * 菜单配置处也加入 React 微应用的快捷入口
            ```ts
            // micro-app-main/src/App.vue
            //...
            export default class App extends Vue {
              /**
              * 菜单列表
              * key: 唯一 Key 值
              * title: 菜单标题
              * path: 菜单对应的路径
              */
              menus = [
                {
                  key: "Home",
                  title: "主页",
                  path: "/",
                },
                {
                  key: "ReactMicroApp",
                  title: "React 主页",
                  path: "/react",
                },
                {
                  key: "ReactMicroAppList",
                  title: "React 列表页",
                  path: "/react/list",
                },
              ];
            }
            ```
          * 在 React 的入口文件 index.js 中，导出 qiankun 主应用所需要的三个生命周期钩子函数
            ```ts
            // micro-app-react/src/public-path.js
            if (window.__POWERED_BY_QIANKUN__) {
              // 动态设置 webpack publicPath，防止资源加载出错
              // eslint-disable-next-line no-undef
              __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
            }

            // micro-app-react/src/index.js
            import React from "react";
            import ReactDOM from "react-dom";
            import "antd/dist/antd.css";

            import "./public-path";
            import App from "./App.jsx";

            /**
            * 渲染函数
            * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
            */
            function render() {
              ReactDOM.render(<App />, document.getElementById("root"));
            }

            // 独立运行时，直接挂载应用
            if (!window.__POWERED_BY_QIANKUN__) {
              render();
            }

            /**
            * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
            * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
            */
            export async function bootstrap() {
              console.log("ReactMicroApp bootstraped");
            }

            /**
            * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
            */
            export async function mount(props) {
              console.log("ReactMicroApp mount", props);
              render(props);
            }

            /**
            * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
            */
            export async function unmount() {
              console.log("ReactMicroApp unmount");
              ReactDOM.unmountComponentAtNode(document.getElementById("root"));
            }
            ```
          * 配置路由命名空间，以确保主应用可以正确加载微应用
            ```ts
            // micro-app-react/src/App.jsx
            const BASE_NAME = window.__POWERED_BY_QIANKUN__ ? "/react" : "";
            const App = () => {
              //...

              return (
                // 设置路由命名空间
                <Router basename={BASE_NAME}>{/* ... */}</Router>
              );
            };
            ```
          * 配置 webpack，使 index.js 导出的生命周期钩子函数可以被 qiankun 识别获取。借助 react-app-rewired 来帮助我们修改 webpack 的配置

            npm install react-app-rewired -D
            ```json
            // micro-app-react/package.json

            //...
            "scripts": {
              "start": "react-app-rewired start",
              "build": "react-app-rewired build",
              "test": "react-app-rewired test",
              "eject": "react-app-rewired eject"
            }
            ```
            新建 config-overrides.js 文件来配置 webpack
            ```ts
            const path = require("path");

            module.exports = {
              webpack: (config) => {
                // 微应用的包名，这里与主应用中注册的微应用名称一致
                config.output.library = `ReactMicroApp`;
                // 将你的 library 暴露为所有的模块定义下都可运行的方式
                config.output.libraryTarget = "umd";
                // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
                config.output.jsonpFunction = `webpackJsonp_ReactMicroApp`;

                config.resolve.alias = {
                  ...config.resolve.alias,
                  "@": path.resolve(__dirname, "src"),
                };
                return config;
              },

              devServer: function (configFunction) {
                return function (proxy, allowedHost) {
                  const config = configFunction(proxy, allowedHost);
                  // 关闭主机检查，使微应用可以被 fetch
                  config.disableHostCheck = true;
                  // 配置跨域请求头，解决开发环境的跨域问题
                  config.headers = {
                    "Access-Control-Allow-Origin": "*",
                  };
                  // 配置 history 模式
                  config.historyApiFallback = true;

                  return config;
                };
              },
            };
            ```
          * 打开主基座，切换到react微应用，能正确加载，控制台能看到执行的生命周期钩子

        3. 接入 Angular 微应用

          * 创建angular项目(主应用的同级目录（micro-app-main 同级目录）):ng new micro-app-angular
          * 创建路由、页面，加入样式
          * 注册微应用
            ```ts
            // micro-app-main/src/micro/apps.ts
            const apps = [
              /**
              * name: 微应用名称 - 具有唯一性
              * entry: 微应用入口 - 通过该地址加载微应用
              * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
              * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
              */
              {
                name: "AngularMicroApp",
                entry: "//localhost:10300",
                container: "#frame",
                activeRule: "/angular",
              },
            ];

            export default apps;
            ```
          * 菜单配置处也加入 Angular 微应用的快捷入口
            ```ts
            // micro-app-main/src/App.vue
            //...
            export default class App extends Vue {
              /**
              * 菜单列表
              * key: 唯一 Key 值
              * title: 菜单标题
              * path: 菜单对应的路径
              */
              menus = [
                {
                  key: "Home",
                  title: "主页",
                  path: "/",
                },
                {
                  key: "AngularMicroApp",
                  title: "Angular 主页",
                  path: "/angular",
                },
                {
                  key: "AngularMicroAppList",
                  title: "Angular 列表页",
                  path: "/angular/list",
                },
              ];
            }
            ```
          * 在主应用注入 zone.js
            ```ts
            // micro-app-main/src/main.js
            // 为 Angular 微应用所做的 zone 包注入
            import "zone.js/dist/zone";
            ```
          * 配置微应用,使用 single-spa-angular 生成一套配置:ng add single-spa-angular
          * 导出 qiankun 主应用所需要的三个生命周期钩子函数
            ```ts
            // micro-app-angular/src/main.single-spa.ts
            import { enableProdMode, NgZone } from "@angular/core";

            import { platformBrowserDynamic } from "@angular/platform-browser-dynamic";
            import { Router } from "@angular/router";
            import { ɵAnimationEngine as AnimationEngine } from "@angular/animations/browser";

            import {
              singleSpaAngular,
              getSingleSpaExtraProviders,
            } from "single-spa-angular";

            import { AppModule } from "./app/app.module";
            import { environment } from "./environments/environment";
            import { singleSpaPropsSubject } from "./single-spa/single-spa-props";

            if (environment.production) {
              enableProdMode();
            }

            // 微应用单独启动时运行
            if (!(window as any).__POWERED_BY_QIANKUN__) {
              platformBrowserDynamic()
                .bootstrapModule(AppModule)
                .catch((err) => console.error(err));
            }

            const { bootstrap, mount, unmount } = singleSpaAngular({
              bootstrapFunction: (singleSpaProps) => {
                singleSpaPropsSubject.next(singleSpaProps);
                return platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule(
                  AppModule
                );
              },
              template: "<app-root />",
              Router,
              NgZone,
              AnimationEngine,
            });

            /** 主应用生命周期钩子中运行 */
            export {
              /**
              * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
              * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
              */
              bootstrap,
              /**
              * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
              */
              mount,
              /**
              * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
              */
              unmount,
            };
            ```
          * 配置 webpack，使 main.single-spa.ts 导出的生命周期钩子函数可以被 qiankun 识别获取,直接配置 extra-webpack.config.js
            ```ts
            // micro-app-angular/extra-webpack.config.js
            const singleSpaAngularWebpack = require("single-spa-angular/lib/webpack")
              .default;
            const webpackMerge = require("webpack-merge");

            module.exports = (angularWebpackConfig, options) => {
              const singleSpaWebpackConfig = singleSpaAngularWebpack(
                angularWebpackConfig,
                options
              );

              const singleSpaConfig = {
                output: {
                  // 微应用的包名，这里与主应用中注册的微应用名称一致
                  library: "AngularMicroApp",
                  // 将你的 library 暴露为所有的模块定义下都可运行的方式
                  libraryTarget: "umd",
                },
              };
              const mergedConfig = webpackMerge.smart(
                singleSpaWebpackConfig,
                singleSpaConfig
              );
              return mergedConfig;
            };
            ```
          * 修改一下 package.json 中的启动命令
            ```json
            // micro-app-angular/package.json
            {
              //...
              "script": {
                //...
                // --disable-host-check: 关闭主机检查，使微应用可以被 fetch
                // --port: 监听端口
                // --base-href: 站点的起始路径，与主应用中配置的一致
                "start": "ng serve --disable-host-check --port 10300 --base-href /angular"
              }
            }
            ```
          * 打开主基座，切换到angular微应用，能正确加载，控制台能看到执行的生命周期钩子

        4. 接入 jquery 等其它微应用

          * 在主应用的同级目录（micro-app-main 同级目录），手动创建目录 micro-app-static
          * 使用 express 作为服务器加载静态 html，我们先编辑 package.json，设置启动命令和相关依赖。
            ```json
            // micro-app-static/package.json
            {
              "name": "micro-app-jquery",
              "version": "1.0.0",
              "description": "",
              "main": "index.js",
              "scripts": {
                "start": "nodemon index.js"
              },
              "author": "",
              "license": "ISC",
              "dependencies": {
                "express": "^4.17.1",
                "cors": "^2.8.5"
              },
              "devDependencies": {
                "nodemon": "^2.0.2"
              }
            }
            ```
          * 添加入口文件 index.js
            ```js
            // micro-app-static/index.js
            const express = require("express");
            const cors = require("cors");

            const app = express();
            // 解决跨域问题
            app.use(cors());
            app.use('/', express.static('static'));

            // 监听端口
            app.listen(10400, () => {
              console.log("server is listening in http://localhost:10400")
            });
            ```
          * npm install 安装相关依赖后，使用 npm start 启动应用
          * 注册微应用
            ```ts
            // micro-app-main/src/micro/apps.ts
            const apps = [
              /**
              * name: 微应用名称 - 具有唯一性
              * entry: 微应用入口 - 通过该地址加载微应用
              * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
              * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
              */
              {
                name: "StaticMicroApp",
                entry: "//localhost:10400",
                container: "#frame",
                activeRule: "/static"
              },
            ];

            export default apps;
            ```
          * 菜单配置处也加入 Static 微应用的快捷入口
            ```ts
            // micro-app-main/src/App.vue
            //...
            export default class App extends Vue {
              /**
              * 菜单列表
              * key: 唯一 Key 值
              * title: 菜单标题
              * path: 菜单对应的路径
              */
              menus = [
                {
                  key: "Home",
                  title: "主页",
                  path: "/"
                },
                {
                  key: "StaticMicroApp",
                  title: "Static 微应用",
                  path: "/static"
                }
              ];
            }
            ```
          * 配置微应用,新建 static 文件夹，在文件夹内新增一个静态页面 index.html
            ```html
            <!-- micro-app-static/static/index.html -->
            <!DOCTYPE html>
            <html lang="en">
              <head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <meta http-equiv="X-UA-Compatible" content="ie=edge" />
                <!-- 引入 bootstrap -->
                <link
                  href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css"
                  rel="stylesheet"
                />
                <title>Jquery App</title>
              </head>

              <body>
                <section
                  id="jquery-app-container"
                  style="padding: 20px; color: blue;"
                ></section>
              </body>
              <!-- 引入 jquery -->
              <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
              <script>
                /**
                * 请求接口数据，构建 HTML
                */
                async function buildHTML() {
                  const result = await fetch("http://dev-api.jt-gmall.com/mall", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    // graphql 的查询风格
                    body: JSON.stringify({
                      query: `{ vegetableList (page: 1, pageSize: 20) { page, pageSize, total, items { _id, name, poster, price } } }`,
                    }),
                  }).then((res) => res.json());
                  const list = result.data.vegetableList.items;
                  const html = `<table class="table">
                    <thead>
                      <tr>
                        <th scope="col">菜名</th>
                        <th scope="col">图片</th>
                        <th scope="col">报价</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${list
                        .map(
                          (item) => `
                      <tr>
                        <td>
                          <img style="width: 40px; height: 40px; border-radius: 100%;" src="${item.poster}"></img>
                        </td>
                        <td>${item.name}</td>
                        <td>￥ ${item.price}</td>
                      </tr>
                        `
                        )
                        .join("")}
                    </tbody>
                  </table>`;
                  return html;
                }

                /**
                * 渲染函数
                * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
                */
                const render = async ($) => {
                  const html = await buildHTML();
                  $("#jquery-app-container").html(html);
                  return Promise.resolve();
                };

                // 独立运行时，直接挂载应用
                if (!window.__POWERED_BY_QIANKUN__) {
                  render($);
                }

                ((global) => {
                  /**
                  * 注册微应用生命周期钩子函数
                  * global[appName] 中的 appName 与主应用中注册的微应用名称一致
                  */
                  global["StaticMicroApp"] = {
                    /**
                    * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
                    * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
                    */
                    bootstrap: () => {
                      console.log("MicroJqueryApp bootstraped");
                      return Promise.resolve();
                    },
                    /**
                    * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
                    */
                    mount: () => {
                      console.log("MicroJqueryApp mount");
                      return render($);
                    },
                    /**
                    * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
                    */
                    unmount: () => {
                      console.log("MicroJqueryApp unmount");
                      return Promise.resolve();
                    },
                  };
                })(window);
              </script>
            </html>
            ```
          * 打开主基座，切换到static微应用，能正确加载，控制台能看到执行的生命周期钩子


      * 通信

        1. 官方提供的通信方式 - Actions 通信，适合业务划分清晰，比较简单的微前端应用，一般来说可以满足大部分的应用场景需求
        2. 基于 redux 实现的通信方式 - Shared 通信，适合需要跟踪通信状态，子应用具备独立运行能力，较为复杂的微前端应用
        3. 使用Vuex来进行状态管理，这其实是对于上面通信方式中，第二种方式的补充

        * Actions 通信

          * Actions 通信优点：

            1. 使用简单；
            2. 官方支持性高；
            3. 适合通信较少的业务场景；

          * 缺点：

            1. 子应用独立运行时，需要额外配置无 Actions 时的逻辑；
            2. 子应用需要先了解状态池的细节，再进行通信；
            3. 由于状态池无法跟踪，通信场景较多时，容易出现状态混乱、维护困难等问题；

          qiankun 内部提供了 initGlobalState 方法用于注册 MicroAppStateActions 实例用于通信，该实例有三个方法，分别是：

          * setGlobalState：设置 globalState - 设置新的值时，内部将执行 浅检查，如果检查到 globalState 发生改变则触发通知，通知到所有的 观察者 函数。
          * onGlobalStateChange：注册 观察者 函数 - 响应 globalState 变化，在 globalState 发生改变时触发该 观察者 函数。
          * offGlobalStateChange：取消 观察者 函数 - 该实例不再响应 globalState 变化。

          实战

          * 主应用

            1. 在主应用中注册一个 MicroAppStateActions 实例并导出
            ```ts
            // micro-app-main/src/shared/actions.ts
            import { initGlobalState, MicroAppStateActions } from "qiankun";

            const initialState = {};
            const actions: MicroAppStateActions = initGlobalState(initialState);

            export default actions;
            ```

            2. 在需要通信的组件中使用该实例，并注册 观察者 函数，以登录功能为例

            在 Vue 组件 的 mounted 生命周期钩子函数中注册了一个 观察者 函数，然后定义了一个 login 方法，最后将 login 方法绑定在按钮中
            ```ts
            // micro-app-main/src/pages/login/index.vue
            import actions from "@/shared/actions";
            import { ApiLoginQuickly } from "@/apis";

            @Component
            export default class Login extends Vue {
              $router!: VueRouter;

              // `mounted` 是 Vue 的生命周期钩子函数，在组件挂载时执行
              mounted() {
                // 注册一个观察者函数
                actions.onGlobalStateChange((state, prevState) => {
                  // state: 变更后的状态; prevState: 变更前的状态
                  console.log("主应用观察者：token 改变前的值为 ", prevState.token);
                  console.log("主应用观察者：登录状态发生改变，改变后的 token 的值为 ", state.token);
                });
              }
              
              async login() {
                // ApiLoginQuickly 是一个远程登录函数，用于获取 token，详见 Demo
                const result = await ApiLoginQuickly();
                const { token } = result.data.loginQuickly;

                // 登录成功后，设置 token
                actions.setGlobalState({ token });

                //在登录后跳转到主页
                this.$router.push("/");
              }
            }
            ```

            3. 点击 2 次按钮

              * 第一次点击：原 token 值为 undefined，新 token 值为我们最新设置的值；
              * 第二次点击时：原 token 的值是我们上一次设置的值，新 token 值为我们最新设置的值；

          * 子应用

            上面已经完成了主应用的登录功能，将 token 信息记录在了 globalState 中。现在，我们进入子应用，使用 token 获取用户信息并展示在页面中。

            1. 改造 Vue 子应用，设置一个 Actions 实例
            ```ts
            // micro-app-vue/src/shared/actions.js
            function emptyAction() {
              // 警告：提示当前使用的是空 Action
              console.warn("Current execute action is empty!");
            }

            class Actions {
              // 默认值为空 Action
              actions = {
                onGlobalStateChange: emptyAction,
                setGlobalState: emptyAction
              };
              
              /**
              * 设置 actions
              */
              setActions(actions) {
                this.actions = actions;
              }

              /**
              * 映射
              */
              onGlobalStateChange(...args) {
                return this.actions.onGlobalStateChange(...args);
              }

              /**
              * 映射
              */
              setGlobalState(...args) {
                return this.actions.setGlobalState(...args);
              }
            }

            const actions = new Actions();
            export default actions;
            ```

            2. 在入口文件 main.js 的 render 函数中注入真实 Actions
            ```ts
            // micro-app-vue/src/main.js
            //...

            /**
            * 渲染函数
            * 主应用生命周期钩子中运行/子应用单独启动时运行
            */
            function render(props) {
              if (props) {
                // 注入 actions 实例
                actions.setActions(props);
              }

              router = new VueRouter({
                base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
                mode: "history",
                routes,
              });

              // 挂载应用
              instance = new Vue({
                router,
                render: (h) => h(App),
              }).$mount("#app");
            }
            ```

            3. 在子应用的 通讯页 获取 globalState 中的 token，使用 token 来获取用户信息，最后在页面中显示用户信息
            ```ts
            // micro-app-vue/src/pages/communication/index.vue
            // 引入 actions 实例
            import actions from "@/shared/actions";
            import { ApiGetUserInfo } from "@/apis";

            export default {
              name: "Communication",

              data() {
                return {
                  userInfo: {}
                };
              },

              mounted() {
                // 注册观察者函数
                // onGlobalStateChange 第二个参数为 true，表示立即执行一次观察者函数
                actions.onGlobalStateChange(state => {
                  const { token } = state;
                  // 未登录 - 返回主页
                  if (!token) {
                    this.$message.error("未检测到登录信息！");
                    return this.$router.push("/");
                  }

                  // 获取用户信息
                  this.getUserInfo(token);
                }, true);
              },

              methods: {
                async getUserInfo(token) {
                  // ApiGetUserInfo 是用于获取用户信息的函数
                  const result = await ApiGetUserInfo(token);
                  this.userInfo = result.data.getUserInfo;
                }
              }
            };
            ```

        * Shared 通信(redux)

          Shared 通信方案的原理就是，主应用基于 redux 维护一个状态池，通过 shared 实例暴露一些方法给子应用使用。同时，子应用需要单独维护一份 shared 实例，在独立运行时使用自身的 shared 实例，在嵌入主应用时使用主应用的 shared 实例，这样就可以保证在使用和表现上的一致性。

          Shared 通信方案需要自行维护状态池，这样会增加项目的复杂度。好处是可以使用市面上比较成熟的状态管理工具，如 redux、mobx，可以有更好的状态管理追踪和一些工具集。

          Shared 通信方案要求父子应用都各自维护一份属于自己的 shared 实例，同样会增加项目的复杂度。好处是子应用可以完全独立于父应用运行（不依赖状态池），子应用也能以最小的改动被嵌入到其他 第三方应用 中。

          Shared 通信方案也可以帮助主应用更好的管控子应用。子应用只可以通过 shared 实例来操作状态池，可以避免子应用对状态池随意操作引发的一系列问题。主应用的 Shared 相对于子应用来说是一个黑箱，子应用只需要了解 Shared 所暴露的 API 而无需关心实现细节。

          * 优点

            1. 可以自由选择状态管理库，更好的开发体验。 - 比如 redux 有专门配套的开发工具可以跟踪状态的变化。
            2. 子应用无需了解主应用的状态池实现细节，只需要了解 shared 的函数抽象，实现一套自身的 shared 甚至空 shared 即可，可以更好的规范子应用开发。
            3. 子应用无法随意污染主应用的状态池，只能通过主应用暴露的 shared 实例的特定方法操作状态池，从而避免状态池污染产生的问题。
            4. 子应用将具备独立运行的能力，Shared 通信使得父子应用有了更好的解耦性。

          * 缺点

            1. 主应用需要单独维护一套状态池，会增加维护成本和项目复杂度；
            2. 子应用需要单独维护一份 shared 实例，会增加维护成本；

          实战

          * 主应用

            1. 在主应用中创建 store 用于管理全局状态池
            ```ts
            // micro-app-main/src/shared/store.ts
            import { createStore } from "redux";

            export type State = {
              token?: string;
            };

            type Action = {
              type: string;
              payload: any;
            };

            const reducer = (state: State = {}, action: Action): State => {
              switch (action.type) {
                default:
                  return state;
                // 设置 Token
                case "SET_TOKEN":
                  return {
                    ...state,
                    token: action.payload,
                  };
              }
            };

            const store = createStore<State, Action, unknown, unknown>(reducer);

            export default store;
            ```

            2. 主应用的 shared 实例
            ```ts
            // micro-app-main/src/shared/index.ts
            import store from "./store";

            class Shared {
              /**
              * 获取 Token
              */
              public getToken(): string {
                const state = store.getState();
                return state.token || "";
              }

              /**
              * 设置 Token
              */
              public setToken(token: string): void {
                // 将 token 的值记录在 store 中
                store.dispatch({
                  type: "SET_TOKEN",
                  payload: token
                });
              }
            }

            const shared = new Shared();
            export default shared;
            ```

            3. 修改登录组件的login方法
            ```ts
            // micro-app-main/src/pages/login/index.vue
            // ...
            async login() {
              // ApiLoginQuickly 是一个远程登录函数，用于获取 token，详见 Demo
              const result = await ApiLoginQuickly();
              const { token } = result.data.loginQuickly;

              // 使用 shared 的 setToken 方法记录 token
              shared.setToken(token);
              this.$router.push("/");
            }
            ```

            4. 将 shared 实例通过 props 传递给子应用
            ```ts
            // micro-app-main/src/micro/apps.ts
            import shared from "@/shared";

            const apps = [
              {
                name: "ReactMicroApp",
                entry: "//localhost:10100",
                container: "#frame",
                activeRule: "/react",
                // 通过 props 将 shared 传递给子应用
                props: { shared },
              },
              {
                name: "VueMicroApp",
                entry: "//localhost:10200",
                container: "#frame",
                activeRule: "/vue",
                // 通过 props 将 shared 传递给子应用
                props: { shared },
              },
            ];

            export default apps;
            ```

          * 子应用

            1. 子应用也应该实现 shared，以便在独立运行时可以拥有兼容处理能力
            ```ts
            // micro-app-vue/src/shared/index.js
            //子应用自身的 shared，子应用独立运行时将使用该 shared，子应用的 shared 使用 localStorage 来操作 token
            class Shared {
              /**
              * 获取 Token
              */
              getToken() {
                // 子应用独立运行时，在 localStorage 中获取 token
                return localStorage.getItem("token") || "";
              }

              /**
              * 设置 Token
              */
              setToken(token) {
                // 子应用独立运行时，在 localStorage 中设置 token
                localStorage.setItem("token", token);
              }
            }

            //用于管理 shared，例如重载 shared 实例、获取 shared 实例等等
            class SharedModule {
              static shared = new Shared();

              /**
              * 重载 shared
              */
              static overloadShared(shared) {
                SharedModule.shared = shared;
              }

              /**
              * 获取 shared 实例
              */
              static getShared() {
                return SharedModule.shared;
              }
            }

            export default SharedModule;
            ```

            2. 在入口文件处注入 shared
            ```ts
            // micro-app-vue/src/main.js
            //...

            /**
            * 渲染函数
            * 主应用生命周期钩子中运行/子应用单独启动时运行
            */
            function render(props = {}) {
              // 当传入的 shared 为空时，使用子应用自身的 shared
              // 当传入的 shared 不为空时，主应用传入的 shared 将会重载子应用的 shared
              const { shared = SharedModule.getShared() } = props;
              SharedModule.overloadShared(shared);

              router = new VueRouter({
                base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
                mode: "history",
                routes,
              });

              // 挂载应用
              instance = new Vue({
                router,
                render: (h) => h(App),
              }).$mount("#app");
            }
            ```
            
            3. 修改子应用的 通讯页，使用 shared 实例获取 token
            ```ts
            // micro-app-vue/src/pages/communication/index.vue
            // 引入 SharedModule
            import SharedModule from "@/shared";
            import { ApiGetUserInfo } from "@/apis";

            export default {
              name: "Communication",

              data() {
                return {
                  userInfo: {}
                };
              },

              mounted() {
                const shared = SharedModule.getShared();
                // 使用 shared 获取 token
                const token = shared.getToken();

                // 未登录 - 返回主页
                if (!token) {
                  this.$message.error("未检测到登录信息！");
                  return this.$router.push("/");
                }

                this.getUserInfo(token);
              },

              methods: {
                async getUserInfo(token) {
                  // ApiGetUserInfo 是用于获取用户信息的函数
                  const result = await ApiGetUserInfo(token);
                  this.userInfo = result.data.getUserInfo;
                }
              }
            };
            ```

        * Shared 通信(vuex)

          1. 主应用向微应用传递store实例
          ```ts
          registerMicroApps(
                [
                    {
                        name: "chai-project",
                        entry: "//localhost:8080",
                        container: '#yourContainer',
                        activeRule: "/chaiQiankunTest/ffff",
                        props: {
                          store //共享主应用的store实例
                        }
                    }
                ],
                {
                    beforeLoad: [
                        app => {
                            console.log("before load", app);
                        }
                    ], // 挂载前回调
                    beforeMount: [
                        app => {
                            console.log("before mount", app);
                        }
                    ], // 挂载后回调
                    afterUnmount: [
                        app => {
                            console.log("after unload", app);
                        }
                    ] // 卸载后回调
                }
          )
          ```

          2. 微应用使用主应用共享的store实例
          ```ts
          import Vuex from 'vuex'
          Vue.use(Vuex);
          function render (props) {
            const store = props.store;
            // 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染
            router = new Router({
              // 运行在主应用中时，添加路由命名空间 /chaiQiankunTest/ffff
              base: window.__POWERED_BY_QIANKUN__ ? 'chaiQiankunTest/ffff' : '/',
              mode: 'history',
              routes
            });

            // 挂载应用
            instance = new Vue({
              router,
              store,//主应用共享的store实例
              render: (h) => h(App)
            }).$mount('#app');
          }
          ```

          3. 在微应用中将共享的store实例进行响应式设置

            Vue.observable(store)

          4. 子应用本身的store如何全局注册呢？

            Vue.prototype.microStore = microStore;

      * 问答

        1. 为什么不用iframe实现？

          * 父子应用之间通信问题
          * cookie共享问题（可做单点登陆SSO）
          * 交互视图效果不佳
        
        2. qiankun是如何注册子应用？

          qiankun是通过registerMicroApps(apps, lifeCycles)API来注册子应用的，当浏览器 url 发生变化时，自动加载相应的子应用的功能，主要包括：
          * entry: 子应用的 entry 地址
          * container：用来定义子应用的容器节点的选择器或者 Element 实例
          * activeRule：子应用的激活规则，即什么路由访问才会去fetch entry配置的域名或ip

          匹配成功后，qiankun 通过 fetch 去获取所匹配子应用的静态资源
        
        3. 资源访问跨域如何解决？

          由于 qiankun 是通过 fetch 去获取子应用注册时配置的静态资源url，所有静态资源必须是支持跨域的

          Access-Control-Allow-Origin：跨域在服务端是不允许的。只能通过给Nginx配置Access-Control-Allow-Origin *后，才能使服务器能接受所有的请求源（Origin）

          Access-Control-Allow-Headers: 设置支持的Content-Type

        4. 子应用加载失败是什么问题？(fetch不到子应用的静态资源？)

          output来配置输出的方式
          * pubilcPath: 资源打包路径，主要解决的是子应用动态载入的 脚本、样式、图片 等地址不正确的问题
          * output.library：需要与主应用注册子应用时的name一致且唯一
          * output.libraryTarget:umd : 导出umd格式，可以支持inport、require和script引入

          然后创建一个publichPath文件，并在main.js 引入
          ```js
          //子应用根目录public-path.js，并在main.js 引入
          if (window.__POWERED_BY_QIANKUN__) {
            // 动态设置 webpack publicPath，防止资源加载出错
            // eslint-disable-next-line no-undef
            __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
          }
          ```

        5. 如何保障原来的应用运行正常，但能集成到基座portal中？

          使用这个全局变量window.__POWERED_BY_QIANKUN__来区分当前是否运行在 qiankun 的主应用中
          * 独立运行：window.__POWERED_BY_QIANKUN__为false，执行mount创建vue对象
          * 运行在qiankun: window.__POWERED_BY_QIANKUN__为true，则不执行mount

        6. 父应用如何共享util和data给子应用?

          可以在注册子应用的时候，把定义好要共享的msg，通过props共享出去(参考share通信)

        7. history路由模式，需要如何配置ngnix，才能正常访问？

          try_files：用来解决nginx找不到client客户端所需要的资源时访问404的问题

          proxy_pass：主要是用来配置接口网关反向代理，可以使得父子应用下访问的api是一致的，防止接口跨域问

      * 部署

        考虑到主应用和子应用共用域名时可能会存在路由冲突的问题，子应用可能会源源不断地添加进来，因此我们将子应用都放在xx.com/subapp/这个二级目录下，根路径/留给主应用。

        1. 主应用main和所有子应用都打包出一份html,css,js,static，分目录上传到服务器，子应用统一放到subapp目录下
        ```txt
        ├── main
        │   └── index.html
        └── subapp
            ├── sub-react
            │   └── index.html
            └── sub-vue
                └── index.html
        ```

        2. 配置nginx，预期是xx.com根路径指向主应用，xx.com/subapp指向子应用,子应用的配置只需写一份，以后新增子应用也不需要改nginx配置，以下应该是微应用部署的最简洁的一份nginx配置了。
        ```conf
        server {
            listen       80;
            server_name qiankun.fengxianqi.com;
            location / {
                root   /data/web/qiankun/main;  # 主应用所在的目录
                index index.html;
                try_files $uri $uri/ /index.html;
            }
            location /subapp {
                alias /data/web/qiankun/subapp;
                try_files $uri $uri/ /index.html;
            }
        }
        ```

        其它问题

        1. react子应用启动后，主应用第一次渲染后会挂掉

          在复写react的webpack时禁用掉热重载（加了下面配置禁用后会导致没法热重载，react应用在开发时得手动刷新了）
          ```js
          module.exports = {
            webpack: function override(config, env) {
              // 解决主应用接入后会挂掉的问题：https://github.com/umijs/qiankun/issues/340
              config.entry = config.entry.filter(
                (e) => !e.includes('webpackHotDevClient')
              );
              // ...
              return config;
            }
          };
          ```

### 自动部署

1.  参考链接：

    [花椒前端基于 GitLab CI/CD 的自动化构建、发布实践](https://mp.weixin.qq.com/s/MbeW8UNZ1fPekWcaNqmsCQ?)

2.  详解：

    - 描述

    发布前端代码，操作流程长，有出错风险。因此需要自动化构建和部署。

    步骤：

    本地构建：

        1. 执行 build 命令，等待 build 完成。

        2. build 完成后，提交打包后的 HTML 文件。

    发布代码：

        1. 打开发布系统

        2. 选择发布项目及环境

        3. 打开发布页面

        4. 选择发布文件

        5. 填写发布信息

        6. 点击确认发布

    - 搭建 GitLab CI/CD

    1. 新建 GitLab 项目

    2. 配置 runner

       GitLab Runner 一般由 GitLab 系统维护者管理，配置后，同类项目可以共享，一般不需要进行修改。

       参考文档：[GitLab Runner 文档](https://docs.gitlab.com.cn/runner/)

       注意：

       - 配置 Runner 后，push 代码，触发了 pipeline，但一直处于 Pending 状态

       This job is stuck, because you don’t have any active runners that can run this job

       注册的 Runner，默认情况下，不会运用没有 tag 的 job，可以在 Settings→CI/CD→Runners Settings，去掉 Runner untagged jobs 即可。

       - GitLab Runner 的类型

       有三种类型的 Runner，Shared Runners 在整个系统所有项目都可以使用，Group Runners 注册后，同一个项目下的不同代码库共享，Specific Runners 需要给项目单独配置，使用 Specific Runners 注意考虑是否需要关闭 Shared Runners、和 Group Runners。

       1. Shared Runners

       2. Specific Runners

       3. Group Runners

       - 在 GitLab CI 中使用 docker

       在部署到阿里云时，需要在 GitLab CI/CD 中使用 docker 打镜像发布。可以参考 Building Docker images with GitLab CI/CD（https://docs.gitlab.com/ee/ci/docker/using_docker_build.html）

       - 在 GitLab CI/CD 中访问 Runner 宿主机目录

       活动项目 .gitlab-ci.yml 文件如下，下面主要通过活动项目的 .gitlab-ci.yml 文件来介绍我们的实践过程、.gitlab-ci.yml 详细的用法，可参考 GitLab CI/CD Pipeline Configuration Reference 文档（https://docs.gitlab.com/ee/ci/yaml/README.html）

    3. .gitlab-ci.yml

       拉取项目到本地;

       在项目根目录新建 .gitlab-ci.yml 文件;

       提交 .gitlab-ci.yml 文件;

       在项目的 CI/CD 中，可以看到 CI/CD 的运行情况

       ```yml
           # 执行 CI/CD 依赖的 Docker 基础镜像。镜像中有 Node、Yarn、Dalp
           image: node
           # 定义 stages,定义了pipeline 分为几个过程:
           # 下载依赖阶段 pre_build,构建阶段 build,发布阶段 deploy
           stages:
           - build
           - test
           # 定义 job
           build 阶段:
           stage: build # 声明当前的阶段，在 stages 中使用
           # before_script 执行 script 前的操作
           script: # 当前 stage 需要执行的操作
               - echo "build stage"
           # 定义 job
           发布到测试环境:
           stage: test
           script:
               - echo "test stage"
           # variables 用于定义变量
           # changes 指定 stage 触发条件
           # refs 指定 stage 触发的分支
       ```

       完整

       ```yml
       image: registry.huajiao.com/gitlab-ci/node-yarn:v1.4

       variables:
       # $CI_PROJECT_PATH  ：项目id,用于项目唯一区分本项目与其它项目
       # $CI_PROJECT_DIR   ：本地项目路径
       # $PROCESS_PATH     ：临时文件目录(包括日志和一些临时文件)
       NODE_MODULES_PATH: /runner-cache/frontend/$CI_PROJECT_PATH/$CI_BUILD_REF_NAME/node_modules

       stages:
       - pre_build
       - build
       - deploy

       下载依赖:
       before_script:
           # 无 node_modules 文件时，新建 node_modules 文件
           - /bin/bash ./ci/mkdir.sh $NODE_MODULES_PATH
           # 软链 node_modules 到宿主机
           - ln -s $NODE_MODULES_PATH .
           - cd webpack@next
       stage: pre_build
       script:
           - echo "yarn install"
           - yarn install  --network-timeout 60000
       only:
           changes:
           - webpack@next/package.json
           refs:
           - test
           - test-99
           - test-128
           - master
           - ci
           - feature/ci-test

       构建:
       stage: build
       variables:
           CI_COMMIT_BEFORE_SHA_PATH: /mnt/gv0/gitlab-runner-cache/$CI_PROJECT_PATH
           CI_COMMIT_BEFORE_SHA_FILE_NAME: $CI_BUILD_REF_NAME.sh
           CI_COMMIT_BEFORE_SHA_FILE: /mnt/gv0/gitlab-runner-cache/$CI_PROJECT_PATH/$CI_BUILD_REF_NAME.sh
       before_script:
           # 建存此次 CI CI_COMMIT_SHA 的文件
           - /bin/bash ./ci/mkfile.sh $CI_COMMIT_BEFORE_SHA_PATH $CI_COMMIT_BEFORE_SHA_FILE_NAME
           # 软链 node_modules 到宿主机
           - ln -s $NODE_MODULES_PATH .
           - rm -rf php/share/*
           - cd webpack@next
       script:
           # 缓存上次ci
           - source $CI_COMMIT_BEFORE_SHA_FILE
           - echo "CI_COMMIT_BEFORE_SHA=$CI_COMMIT_SHA" > $CI_COMMIT_BEFORE_SHA_FILE
           - python3 ../ci/build.py   # 编译
           - /bin/bash ../ci/commit.sh   # 提交编译结果
       only:
           changes:
           - www_src/**/*
           refs:
           - test
           - test-99
           - test-128
           - master
           - ci
       ```


        测试发布:
        stage: deploy
        variables:
            PROCESS_PATH: /mnt/gv0/gitlab-runner-cache/deploy/process/$CI_JOB_ID  # 目录不要换，用于日志服务器获取日志展示
        script:
            - mkdir $PROCESS_PATH # 建立发布临时路径，存放发布配置中间文件和结果日志用
            - dplt $CI_PROJECT_DIR/.deploy_test.yml $CI_PROJECT_PATH $CI_PROJECT_DIR/php/ $PROCESS_PATH
            # dplt 发布yml配置
            - echo "发布完成，错误日志查看http://new.admin.wolffy.qihoo.net/log?path="$PROCESS_PATH
            - echo `ls $PROCESS_PATH/*.log`
        only:
            changes:
            - php/**/*
            refs:
            - test
        ```

        * 下载依赖阶段（pre_build stage）

            下载依赖的方案是：当 package.json 文件发生变化时，触发 pre_build stage，执行 yarn install。下载的 node_modules 放在宿主机下，执行时通过软链获取依赖。

        * 构建阶段（build stage）

            1. diff 文件变化

                每次 CI 时，将当前 CI commit SHA（CI_COMMIT_SHA 变量）存在文件中，存为 CI_COMMIT_BEFORE_SHA 变量， diff 时，git diff 当前 CI 与上次 commit SHA 的变化。

            2. 前端 build

                根据 git diff 的变化情况，确定本次需要打包的项目。

            3. commit build 后结果

                在 GitLab CI/CD 提交代码时，使用 Git 凭证存储，提交打包后的 HTML 文件。Git 凭证存储细节可参考凭证存储文档(https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8)

        * 发布阶段（deploy stage）

            发布阶段，使用内部的 rsync 工具 dplt 将打包后的 HTML 文件部署。dplt 可配置集群、机器列表。

### 单点登录

1.  参考链接：

    [什么是 SSO 与 CAS?](https://juejin.im/post/5a002b536fb9a045132a1727)

    [js 怎样修改 cookie 的 domain](https://segmentfault.com/q/1010000007676568)

    [啥是单点登陆？淘宝和天猫是如何实现同时登陆的？](https://blog.csdn.net/u011277123/article/details/90714949)

    [SSO 单点登录(仿天猫淘宝)](https://www.jianshu.com/p/33e6be06617f)

2.  详解

- SSO(Single Sign On，单点登录，架构)优点

  - 提升用户体验：用户使用同一公司的不同产品，只需登录一次即可
  - 避免重复开发：后端不用开发多套登录逻辑
  - 提升安全系数：运维不需维护多个登录系统而导致疏忽修复漏洞

- CAS(Central Authentication Service，中心授权服务)

  - 1.0 称为基础模式，web 端单点登录。
  - 2.0 称为代理模式，适用于存在非 Web 应用之间的单点登录。

- SSO 的演进与分类

  - 同域 SSO

    共用同域 cookie 即可

  - 同父域 SSO

    共用同域 cookie，把 cookie 的 domain 设置为其父域，设置方法见参考链接 2

  - 跨域 SSO

    设置独立的 SSO 服务器，CAS 方案

  - CAS 1.0

    - 概念

      - TGT：Ticket Grangting Ticket

        TGT 是 CAS 为用户签发的登录票据，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。当 HTTP 请求到来时，CAS 以此 Cookie 值（TGC）为 key 查询缓存中有无 TGT ，如果有的话，则相信用户已登录过。

      - TGC：Ticket Granting Cookie

        CAS Server 生成 TGT 放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionId），以 Cookie 形式放到浏览器端，是 CAS Server 用来明确用户身份的凭证。

      - ST：Service Ticket

        ST 是 CAS 为用户签发的访问某一 service 的票据。用户访问 service 时，service 发现用户没有 ST，则要求用户去 CAS 获取 ST。用户向 CAS 发出获取 ST 的请求，CAS 发现用户有 TGT，则签发一个 ST，返回给用户。用户拿着 ST 去访问 service，service 拿 ST 去 CAS 验证，验证通过后，允许用户访问资源。

    - 流程

      1. 用户访问 a 网站，并首次登陆，因没有任何票据，重定向到 SSO 服务器登录页，并带上登陆成功后需要返回的地址
      2. 用户在 SSO 登录页登陆，SSO 后端产生 Session 票据 TGT，重定向到之前指定的页面，并在 response 带上 cookie 的票据 ST
      3. 用户回到 a 网站，根据返回的 ST 设置 cookie
      4. 用户继续访问 a 网站，判断到 cookie 中有 ST，a 服务器请求 SSO 服务器，SSO 验证成功，在 a 网站后端产生 session，更新 cookie 为 a 网站 session 的登录状态
      5. 用户访问 b 网站，因没有任何票据，重定向到 SSO 服务器登录页，此时 SSO 登录页 cookie 已存在票据 TGC，经过校验后，证实已经登录
      6. SSO 页面重定向到 b 网站，并带上新的 ST，设置 cookie
      7. 用户继续访问 b 网站的流程同第 4 步
      8. 登出流程核心为清除 SSO 对应的 session，再通知更网站清除 cookie

    - 淘宝天猫方案

      天猫中嵌淘宝 iframe，天猫登录后，从 SSO 中获取到 token，并设置天猫 cookie，再设置淘宝 iframe 的 src，传入 token，淘宝 onload 检测到 url 有 token，则设置淘宝的 cookie。

### codeReview

1.  参考链接：

    [有赞美业前端： 持续标准化 Code Review](https://mp.weixin.qq.com/s/INVeBwm0U2yx511MLZeuZA)

2.  详解

    * 背景

        * 每人需要维护

            1. PC:vue/react/angular/typescript/es6/eslint/prettier
            2. h5:flexible/ssr
            3. 多端:小程序/app/electron
            4. 后端:koa/express
            5. 测试:jest/puppeteer

        * 技术要求

            需要技术架构、开发流程、数据流处理、资产市场、最佳实践

        * 代码质量问题

            1. 项目Bug较多，同样的坑不同的人会踩
            2. 迭代后的代码难维护，包括代码可读性差、复用度低等
            3. 模块的整体设计也欠缺，扩展能力难以支撑业务发展。

    * 定义需求

        1. 从源头把控代码质量和效率

            * 统一代码评判标准和认知

            * 发现边界问题

            * 提出改进建议

        2. 共享和迭代集体代码智慧

            * 交流计思路和编码实践

            * 沉淀最佳实践

            * 迭代统一规范

    * 标准化方案

        * review 小组
        
            各端经验丰富的人员讨论对规范和原则的实践

        * 代码质量评价维度和标准

            * 基本

                * 是否符合基本规范

            * 架构

                * 是否按照设计文档思路来写代码
                * 是否发现了更好的解决方案
                * 是否提供了很好的解决思路

            * 代码

                * 是否明显重复代码
                * 是否合理抽取枚举值，禁止使用“魔法值”
                * 是否合理使用已有的组件和方法
                * 对已有的、不合理的代码进行重构和优化
                * 职责（组件、方法）、概念是否清晰

            * 健壮性

                * 边界和异常是否考虑完备
                * 在review阶段是否发现明显bug
                * 是否考虑安全性（xss）

            * 效率

                * 是否抽取共用常量
                * 否抽取沉淀基础组件和通用业务组件到组件库

        * review

            * 提供文档

                * 地址、产品文档、UI稿、技术设计、效率平台、接口文档

            * review人员分配

                * 技术栈、业务熟悉程度、空闲程度、

            * 要求

                * 在提测前进行
                * 各项评分、备注、解决方案
                * 提测体现review内容
                * 讨论和反馈，确认review有效
                * 记录、分享

    * 平台化方案

        * 标准化缺点

            1. 操作欠缺自动化

                * 流程的很多环节明显可以自动化，节省重复的工作量
                * 对流程的把控依赖人，容易执行不到位

            2. 信息欠缺数字化

                * 对 code review 的评分统计需要人工，工作量大
                * code review 的总览和数据分析可以支撑更好的判断团队问题和决策提升整体代码质量的策略

            3. 流程欠缺可视化

                * 所有流程应该是可以大盘总览，单个详情全面的
                * 每个code review事务的状态是可见的

        * 解决

            1. 程序自动同步信息到微信：相关负责人review状态
            2. 自动创建文档模板承载一次code review 全过程：立项、材料、评审、记录

### Serverless

1.  参考链接：

    [看懂 Serverless，这一篇就够了](https://blog.csdn.net/cc18868876837/article/details/90672971)

    [serverless](https://www.jianshu.com/p/92632d6c2269)

2.  详解

    * 概念

      简单理解为：把代码文件放到云平台，运维交给云平台处理，云平台按次/流量收费。

      无服务器（Serverless）计算，过去是“构建一个框架运行在一台服务器上，对多个事件进行响应”，Serverless则变为“构建或使用一个微服务或微功能来响应一个事件”，做到当访问时，调入相关资源开始运行，运行完成后，卸载所有开销，真正做到按需按次计费。这是云计算向纵深发展的一种自然而然的过程。

      它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时。

    * FaaS（Function as a Service，函数即服务）

      无须自行管理服务器系统或自己的服务器应用程序，即可直接运行后端代码。

    * BaaS（Backend as a Service，后端即服务）

      不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务（依赖第三方服务）。

    * 工作原理

      与使用虚拟机或一些底层的技术来部署和管理应用程序相比，无服务器计算提供了一种更高级别的抽象。因为它们有不同的抽象和“触发器”的集合。

      拿计算来讲，这种抽象有一个特定函数和抽象的触发器，它通常是一个事件。以数据库为例，这种抽象也许是一个表，而触发器相当于表的查询或搜索，或者通过在表中做一些事情而生成的事件。

      API接口一旦构建完成，应用程序的功能就可以在基于移动和基于 Web 的版本中重用。

    * 使用场景

        1. 在Web及移动端服务中，可以整合API网关和Serverles服务构建Web及移动后端，帮助开发者构建可弹性扩展、高可用的移动或 Web后端应用服务。
        2. 在IoT场景下可高效的处理实时流数据，由设备产生海量的实时信息流数据，通过Serverles服务分类处理并写入后端处理。
        3. 在实时媒体资讯内容处理场景里，用户上传的音视频到对象存储OBS，通过上传事件触发多个函数，分别完成高清转码、音频转码等功能，满足用户对实时性和并发能力的高要求。
        4. 还适合于任何事件驱动的各种不同的用例，这包括物联网，移动应用，基于网络的应用程序和聊天机器人等。
            * 应用负载有显著的波峰波谷

              当自有机器的利用率小于 30%，使用 Serverless 后会有显著的效率提升。对于云服务厂商，在具备了足够多的用户之后，各种波峰波谷叠加后平稳化，聚合之后资源复用性更高。

              如外卖企业负载高峰是在用餐时期，安防行业的负载高峰则是夜间，这是受各个企业业务定位所限的；而对于一个成熟的云服务厂商，如果其平台足够大，用户足够多，是不应该有明显的波峰波谷现象的。

            * 基于事件的数据处理

              视频转码、抽取数据、人脸识别等，这些均为通用计算任务，可由函数计算执行。

              开发者需要自己写出实现逻辑，再将任务按照控制流连接起来，每个任务的具体执行由云厂商来负责。如此，开发变得更便捷，并且构建的系统天然高可用、实时弹性伸缩，用户不需要关心机器层面问题。

      * 优点

          1. 支持Serverless计算的平台可以节省大量时间和成本，同时可以释放员工，让开发者得以开展更有价值的工作，而不是管理基础设施。
          2. 提高敏捷度，更快速地推出新应用和新服务，进而提高客户满意度。

      * 缺点

          1. 不适合长时间运行应用

              Serverless 在请求到来时才运行，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动时间。

              如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。

              如果你通过 CRON 的方式或者 CloudWatch 来定期唤醒应用，又会比较消耗资源。

              需要我们对它做优化，如果频繁调用，这个资源将会常驻内存，第一次冷启之后，就可以一直服务，直到一段时间内没有新的调用请求进来，则会转入“休眠”状态，甚至被回收，从而不消耗任何资源。

          2. 完全依赖于第三方服务

              当我们采用某云服务厂商的 Serverless 架构时，我们就和该服务供应商绑定了，那么我们再将服务迁到别的云服务商上就没有那么容易了。

              修改底层代码建立隔离层，就需要隔离 API 网关、隔离数据库层，市面上还没有成熟的 ORM 工具，让你既支持Firebase，又支持 DynamoDB等等。这些带给我们额外的成本。

          3. 缺乏调试和开发工具

              需要日志记录插件

          4. 配置复杂

              AWS Lambda的 CloudFormation配置是如此的复杂，并且难以阅读及编写（JSON 格式），虽然CloudFomation提供了Template模板，但想要使用它的话，需要创建一个Stack，在Stack中指定你要使用的Template,然后aws才会按照Template中的定义来创建及初始化资源。

              Serverless Framework的配置更加简单，采用的是 YAML 格式。在部署的时候，Serverless Framework 会根据我们的配置生成 CloudFormation 配置。然而这也并非是一个真正用于生产的配置,真实的应用场景远远比这复杂。

      * 工具

          k8s容器服务,docker